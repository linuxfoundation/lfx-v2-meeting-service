// Code generated by goa v3.21.1, DO NOT EDIT.
//
// Meeting Service HTTP server types
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package server

import (
	"unicode/utf8"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goa "goa.design/goa/v3/pkg"
)

// CreateMeetingRequestBody is the type of the "Meeting Service" service
// "create-meeting" endpoint HTTP request body.
type CreateMeetingRequestBody struct {
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceRequestBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeRequestBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// The organizers of the meeting. This is a list of LFIDs of the meeting
	// organizers.
	Organizers []string `form:"organizers,omitempty" json:"organizers,omitempty" xml:"organizers,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigPostRequestBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
}

// UpdateMeetingBaseRequestBody is the type of the "Meeting Service" service
// "update-meeting-base" endpoint HTTP request body.
type UpdateMeetingBaseRequestBody struct {
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceRequestBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeRequestBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigPostRequestBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
}

// UpdateMeetingSettingsRequestBody is the type of the "Meeting Service"
// service "update-meeting-settings" endpoint HTTP request body.
type UpdateMeetingSettingsRequestBody struct {
	// The organizers of the meeting. This is a list of LFIDs of the meeting
	// organizers.
	Organizers []string `form:"organizers,omitempty" json:"organizers,omitempty" xml:"organizers,omitempty"`
}

// CreateMeetingRegistrantRequestBody is the type of the "Meeting Service"
// service "create-meeting-registrant" endpoint HTTP request body.
type CreateMeetingRegistrantRequestBody struct {
	// User's email address
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// User's first name
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" xml:"first_name,omitempty"`
	// User's last name
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty" xml:"last_name,omitempty"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// UpdateMeetingRegistrantRequestBody is the type of the "Meeting Service"
// service "update-meeting-registrant" endpoint HTTP request body.
type UpdateMeetingRegistrantRequestBody struct {
	// User's email address
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// User's first name
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" xml:"first_name,omitempty"`
	// User's last name
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty" xml:"last_name,omitempty"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
}

// ZoomWebhookRequestBody is the type of the "Meeting Service" service
// "zoom-webhook" endpoint HTTP request body.
type ZoomWebhookRequestBody struct {
	// The type of event
	Event *string `form:"event,omitempty" json:"event,omitempty" xml:"event,omitempty"`
	// Event timestamp in milliseconds
	EventTs *int64 `form:"event_ts,omitempty" json:"event_ts,omitempty" xml:"event_ts,omitempty"`
	// Contains meeting, participant, or recording data depending on event type
	Payload any `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
}

// CreatePastMeetingRequestBody is the type of the "Meeting Service" service
// "create-past-meeting" endpoint HTTP request body.
type CreatePastMeetingRequestBody struct {
	// The UID of the original meeting
	MeetingUID *string `form:"meeting_uid,omitempty" json:"meeting_uid,omitempty" xml:"meeting_uid,omitempty"`
	// The occurrence ID for recurring meetings
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The scheduled start time of the past meeting
	ScheduledStartTime *string `form:"scheduled_start_time,omitempty" json:"scheduled_start_time,omitempty" xml:"scheduled_start_time,omitempty"`
	// The scheduled end time of the past meeting
	ScheduledEndTime *string `form:"scheduled_end_time,omitempty" json:"scheduled_end_time,omitempty" xml:"scheduled_end_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceRequestBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeRequestBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The ID of the meeting in the platform (e.g. Zoom meeting ID)
	PlatformMeetingID *string `form:"platform_meeting_id,omitempty" json:"platform_meeting_id,omitempty" xml:"platform_meeting_id,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullRequestBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// Sessions represent individual start/end periods if a meeting was stopped and
	// restarted
	Sessions []*SessionRequestBody `form:"sessions,omitempty" json:"sessions,omitempty" xml:"sessions,omitempty"`
}

// CreatePastMeetingParticipantRequestBody is the type of the "Meeting Service"
// service "create-past-meeting-participant" endpoint HTTP request body.
type CreatePastMeetingParticipantRequestBody struct {
	// The unique identifier of the past meeting
	PastMeetingUID *string `form:"past_meeting_uid,omitempty" json:"past_meeting_uid,omitempty" xml:"past_meeting_uid,omitempty"`
	// User's email address
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// User's first name
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" xml:"first_name,omitempty"`
	// User's last name
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty" xml:"last_name,omitempty"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// Whether the participant was invited to this past meeting
	IsInvited *bool `form:"is_invited,omitempty" json:"is_invited,omitempty" xml:"is_invited,omitempty"`
	// Whether the participant attended this past meeting
	IsAttended *bool `form:"is_attended,omitempty" json:"is_attended,omitempty" xml:"is_attended,omitempty"`
}

// UpdatePastMeetingParticipantRequestBody is the type of the "Meeting Service"
// service "update-past-meeting-participant" endpoint HTTP request body.
type UpdatePastMeetingParticipantRequestBody struct {
	// User's email address
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// User's first name
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" xml:"first_name,omitempty"`
	// User's last name
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty" xml:"last_name,omitempty"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// Whether the participant was invited to this past meeting
	IsInvited *bool `form:"is_invited,omitempty" json:"is_invited,omitempty" xml:"is_invited,omitempty"`
	// Whether the participant attended this past meeting
	IsAttended *bool `form:"is_attended,omitempty" json:"is_attended,omitempty" xml:"is_attended,omitempty"`
}

// GetMeetingsResponseBody is the type of the "Meeting Service" service
// "get-meetings" endpoint HTTP response body.
type GetMeetingsResponseBody struct {
	// Resources found
	Meetings []*MeetingFullResponseBody `form:"meetings" json:"meetings" xml:"meetings"`
}

// CreateMeetingResponseBody is the type of the "Meeting Service" service
// "create-meeting" endpoint HTTP response body.
type CreateMeetingResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	JoinURL *string `form:"join_url,omitempty" json:"join_url,omitempty" xml:"join_url,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// The number of registrants that have an email delivery error with their
	// invite. The delivery errors are counted as the last invite that was sent to
	// the registrant, so if a registrant previously had a delivery error but not
	// in their most recent invite received, then it does not count towards this
	// field value.
	EmailDeliveryErrorCount *int `form:"email_delivery_error_count,omitempty" json:"email_delivery_error_count,omitempty" xml:"email_delivery_error_count,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// The number of registrants for the meeting
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// The number of registrants that have declined the meeting invitation
	RegistrantResponseDeclinedCount *int `form:"registrant_response_declined_count,omitempty" json:"registrant_response_declined_count,omitempty" xml:"registrant_response_declined_count,omitempty"`
	// The number of registrants that have accepted the meeting invitation
	RegistrantResponseAcceptedCount *int `form:"registrant_response_accepted_count,omitempty" json:"registrant_response_accepted_count,omitempty" xml:"registrant_response_accepted_count,omitempty"`
	// Array of meeting occurrences (read-only from platform API)
	Occurrences []*OccurrenceResponseBody `form:"occurrences,omitempty" json:"occurrences,omitempty" xml:"occurrences,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// The organizers of the meeting. This is a list of LFIDs of the meeting
	// organizers.
	Organizers []string `form:"organizers,omitempty" json:"organizers,omitempty" xml:"organizers,omitempty"`
}

// GetMeetingBaseResponseBody is the type of the "Meeting Service" service
// "get-meeting-base" endpoint HTTP response body.
type GetMeetingBaseResponseBody MeetingBaseResponseBody

// GetMeetingSettingsResponseBody is the type of the "Meeting Service" service
// "get-meeting-settings" endpoint HTTP response body.
type GetMeetingSettingsResponseBody MeetingSettingsResponseBody

// UpdateMeetingBaseResponseBody is the type of the "Meeting Service" service
// "update-meeting-base" endpoint HTTP response body.
type UpdateMeetingBaseResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	JoinURL *string `form:"join_url,omitempty" json:"join_url,omitempty" xml:"join_url,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// The number of registrants that have an email delivery error with their
	// invite. The delivery errors are counted as the last invite that was sent to
	// the registrant, so if a registrant previously had a delivery error but not
	// in their most recent invite received, then it does not count towards this
	// field value.
	EmailDeliveryErrorCount *int `form:"email_delivery_error_count,omitempty" json:"email_delivery_error_count,omitempty" xml:"email_delivery_error_count,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// The number of registrants for the meeting
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// The number of registrants that have declined the meeting invitation
	RegistrantResponseDeclinedCount *int `form:"registrant_response_declined_count,omitempty" json:"registrant_response_declined_count,omitempty" xml:"registrant_response_declined_count,omitempty"`
	// The number of registrants that have accepted the meeting invitation
	RegistrantResponseAcceptedCount *int `form:"registrant_response_accepted_count,omitempty" json:"registrant_response_accepted_count,omitempty" xml:"registrant_response_accepted_count,omitempty"`
	// Array of meeting occurrences (read-only from platform API)
	Occurrences []*OccurrenceResponseBody `form:"occurrences,omitempty" json:"occurrences,omitempty" xml:"occurrences,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// UpdateMeetingSettingsResponseBody is the type of the "Meeting Service"
// service "update-meeting-settings" endpoint HTTP response body.
type UpdateMeetingSettingsResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The organizers of the meeting. This is a list of LFIDs of the meeting
	// organizers.
	Organizers []string `form:"organizers,omitempty" json:"organizers,omitempty" xml:"organizers,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetMeetingRegistrantsResponseBody is the type of the "Meeting Service"
// service "get-meeting-registrants" endpoint HTTP response body.
type GetMeetingRegistrantsResponseBody struct {
	// Meeting registrants
	Registrants []*RegistrantResponseBody `form:"registrants" json:"registrants" xml:"registrants"`
}

// CreateMeetingRegistrantResponseBody is the type of the "Meeting Service"
// service "create-meeting-registrant" endpoint HTTP response body.
type CreateMeetingRegistrantResponseBody struct {
	// The UID of the registrant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetMeetingRegistrantResponseBody is the type of the "Meeting Service"
// service "get-meeting-registrant" endpoint HTTP response body.
type GetMeetingRegistrantResponseBody RegistrantResponseBody

// UpdateMeetingRegistrantResponseBody is the type of the "Meeting Service"
// service "update-meeting-registrant" endpoint HTTP response body.
type UpdateMeetingRegistrantResponseBody struct {
	// The UID of the registrant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// ZoomWebhookResponseBody is the type of the "Meeting Service" service
// "zoom-webhook" endpoint HTTP response body.
type ZoomWebhookResponseBody struct {
	// Processing status
	Status string `form:"status" json:"status" xml:"status"`
	// Optional message
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
}

// GetPastMeetingsResponseBody is the type of the "Meeting Service" service
// "get-past-meetings" endpoint HTTP response body.
type GetPastMeetingsResponseBody struct {
	// Past meetings found
	PastMeetings []*PastMeetingResponseBody `form:"past_meetings" json:"past_meetings" xml:"past_meetings"`
}

// CreatePastMeetingResponseBody is the type of the "Meeting Service" service
// "create-past-meeting" endpoint HTTP response body.
type CreatePastMeetingResponseBody struct {
	// The unique identifier of the past meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the original meeting
	MeetingUID *string `form:"meeting_uid,omitempty" json:"meeting_uid,omitempty" xml:"meeting_uid,omitempty"`
	// The occurrence ID for recurring meetings
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The scheduled start time of the past meeting
	ScheduledStartTime *string `form:"scheduled_start_time,omitempty" json:"scheduled_start_time,omitempty" xml:"scheduled_start_time,omitempty"`
	// The scheduled end time of the past meeting
	ScheduledEndTime *string `form:"scheduled_end_time,omitempty" json:"scheduled_end_time,omitempty" xml:"scheduled_end_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The ID of the meeting in the platform (e.g. Zoom meeting ID)
	PlatformMeetingID *string `form:"platform_meeting_id,omitempty" json:"platform_meeting_id,omitempty" xml:"platform_meeting_id,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// Sessions represent individual start/end periods if a meeting was stopped and
	// restarted
	Sessions []*SessionResponseBody `form:"sessions,omitempty" json:"sessions,omitempty" xml:"sessions,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetPastMeetingResponseBody is the type of the "Meeting Service" service
// "get-past-meeting" endpoint HTTP response body.
type GetPastMeetingResponseBody PastMeetingResponseBody

// GetPastMeetingParticipantsResponseBody is the type of the "Meeting Service"
// service "get-past-meeting-participants" endpoint HTTP response body.
type GetPastMeetingParticipantsResponseBody struct {
	// Past meeting participants
	Participants []*PastMeetingParticipantResponseBody `form:"participants" json:"participants" xml:"participants"`
}

// CreatePastMeetingParticipantResponseBody is the type of the "Meeting
// Service" service "create-past-meeting-participant" endpoint HTTP response
// body.
type CreatePastMeetingParticipantResponseBody struct {
	// The UID of the past meeting participant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The unique identifier of the past meeting
	PastMeetingUID string `form:"past_meeting_uid" json:"past_meeting_uid" xml:"past_meeting_uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// Whether the participant was invited to this past meeting
	IsInvited *bool `form:"is_invited,omitempty" json:"is_invited,omitempty" xml:"is_invited,omitempty"`
	// Whether the participant attended this past meeting
	IsAttended *bool `form:"is_attended,omitempty" json:"is_attended,omitempty" xml:"is_attended,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetPastMeetingParticipantResponseBody is the type of the "Meeting Service"
// service "get-past-meeting-participant" endpoint HTTP response body.
type GetPastMeetingParticipantResponseBody PastMeetingParticipantResponseBody

// UpdatePastMeetingParticipantResponseBody is the type of the "Meeting
// Service" service "update-past-meeting-participant" endpoint HTTP response
// body.
type UpdatePastMeetingParticipantResponseBody struct {
	// The UID of the past meeting participant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The unique identifier of the past meeting
	PastMeetingUID string `form:"past_meeting_uid" json:"past_meeting_uid" xml:"past_meeting_uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// Whether the participant was invited to this past meeting
	IsInvited *bool `form:"is_invited,omitempty" json:"is_invited,omitempty" xml:"is_invited,omitempty"`
	// Whether the participant attended this past meeting
	IsAttended *bool `form:"is_attended,omitempty" json:"is_attended,omitempty" xml:"is_attended,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetMeetingsBadRequestResponseBody is the type of the "Meeting Service"
// service "get-meetings" endpoint HTTP response body for the "BadRequest"
// error.
type GetMeetingsBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingsInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "get-meetings" endpoint HTTP response body for the
// "InternalServerError" error.
type GetMeetingsInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingsServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "get-meetings" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type GetMeetingsServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingBadRequestResponseBody is the type of the "Meeting Service"
// service "create-meeting" endpoint HTTP response body for the "BadRequest"
// error.
type CreateMeetingBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingConflictResponseBody is the type of the "Meeting Service"
// service "create-meeting" endpoint HTTP response body for the "Conflict"
// error.
type CreateMeetingConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "create-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type CreateMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "create-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type CreateMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingBaseInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "get-meeting-base" endpoint HTTP response body for the
// "InternalServerError" error.
type GetMeetingBaseInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingBaseNotFoundResponseBody is the type of the "Meeting Service"
// service "get-meeting-base" endpoint HTTP response body for the "NotFound"
// error.
type GetMeetingBaseNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingBaseServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "get-meeting-base" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type GetMeetingBaseServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingSettingsInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "get-meeting-settings" endpoint HTTP response body
// for the "InternalServerError" error.
type GetMeetingSettingsInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingSettingsNotFoundResponseBody is the type of the "Meeting Service"
// service "get-meeting-settings" endpoint HTTP response body for the
// "NotFound" error.
type GetMeetingSettingsNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingSettingsServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "get-meeting-settings" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type GetMeetingSettingsServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingBaseBadRequestResponseBody is the type of the "Meeting Service"
// service "update-meeting-base" endpoint HTTP response body for the
// "BadRequest" error.
type UpdateMeetingBaseBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingBaseConflictResponseBody is the type of the "Meeting Service"
// service "update-meeting-base" endpoint HTTP response body for the "Conflict"
// error.
type UpdateMeetingBaseConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingBaseInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "update-meeting-base" endpoint HTTP response body for the
// "InternalServerError" error.
type UpdateMeetingBaseInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingBaseNotFoundResponseBody is the type of the "Meeting Service"
// service "update-meeting-base" endpoint HTTP response body for the "NotFound"
// error.
type UpdateMeetingBaseNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingBaseServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "update-meeting-base" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type UpdateMeetingBaseServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingSettingsBadRequestResponseBody is the type of the "Meeting
// Service" service "update-meeting-settings" endpoint HTTP response body for
// the "BadRequest" error.
type UpdateMeetingSettingsBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingSettingsInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "update-meeting-settings" endpoint HTTP response
// body for the "InternalServerError" error.
type UpdateMeetingSettingsInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingSettingsNotFoundResponseBody is the type of the "Meeting
// Service" service "update-meeting-settings" endpoint HTTP response body for
// the "NotFound" error.
type UpdateMeetingSettingsNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingSettingsServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "update-meeting-settings" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type UpdateMeetingSettingsServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingBadRequestResponseBody is the type of the "Meeting Service"
// service "delete-meeting" endpoint HTTP response body for the "BadRequest"
// error.
type DeleteMeetingBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "delete-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type DeleteMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingNotFoundResponseBody is the type of the "Meeting Service"
// service "delete-meeting" endpoint HTTP response body for the "NotFound"
// error.
type DeleteMeetingNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "delete-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type DeleteMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantsInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "get-meeting-registrants" endpoint HTTP response
// body for the "InternalServerError" error.
type GetMeetingRegistrantsInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantsNotFoundResponseBody is the type of the "Meeting
// Service" service "get-meeting-registrants" endpoint HTTP response body for
// the "NotFound" error.
type GetMeetingRegistrantsNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantsServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "get-meeting-registrants" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type GetMeetingRegistrantsServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantBadRequestResponseBody is the type of the "Meeting
// Service" service "create-meeting-registrant" endpoint HTTP response body for
// the "BadRequest" error.
type CreateMeetingRegistrantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantConflictResponseBody is the type of the "Meeting
// Service" service "create-meeting-registrant" endpoint HTTP response body for
// the "Conflict" error.
type CreateMeetingRegistrantConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "create-meeting-registrant" endpoint HTTP response
// body for the "InternalServerError" error.
type CreateMeetingRegistrantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantNotFoundResponseBody is the type of the "Meeting
// Service" service "create-meeting-registrant" endpoint HTTP response body for
// the "NotFound" error.
type CreateMeetingRegistrantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "create-meeting-registrant" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type CreateMeetingRegistrantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "get-meeting-registrant" endpoint HTTP response
// body for the "InternalServerError" error.
type GetMeetingRegistrantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantNotFoundResponseBody is the type of the "Meeting
// Service" service "get-meeting-registrant" endpoint HTTP response body for
// the "NotFound" error.
type GetMeetingRegistrantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "get-meeting-registrant" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type GetMeetingRegistrantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantBadRequestResponseBody is the type of the "Meeting
// Service" service "update-meeting-registrant" endpoint HTTP response body for
// the "BadRequest" error.
type UpdateMeetingRegistrantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantConflictResponseBody is the type of the "Meeting
// Service" service "update-meeting-registrant" endpoint HTTP response body for
// the "Conflict" error.
type UpdateMeetingRegistrantConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "update-meeting-registrant" endpoint HTTP response
// body for the "InternalServerError" error.
type UpdateMeetingRegistrantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantNotFoundResponseBody is the type of the "Meeting
// Service" service "update-meeting-registrant" endpoint HTTP response body for
// the "NotFound" error.
type UpdateMeetingRegistrantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "update-meeting-registrant" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type UpdateMeetingRegistrantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingRegistrantBadRequestResponseBody is the type of the "Meeting
// Service" service "delete-meeting-registrant" endpoint HTTP response body for
// the "BadRequest" error.
type DeleteMeetingRegistrantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingRegistrantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "delete-meeting-registrant" endpoint HTTP response
// body for the "InternalServerError" error.
type DeleteMeetingRegistrantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingRegistrantNotFoundResponseBody is the type of the "Meeting
// Service" service "delete-meeting-registrant" endpoint HTTP response body for
// the "NotFound" error.
type DeleteMeetingRegistrantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingRegistrantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "delete-meeting-registrant" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type DeleteMeetingRegistrantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// ZoomWebhookBadRequestResponseBody is the type of the "Meeting Service"
// service "zoom-webhook" endpoint HTTP response body for the "BadRequest"
// error.
type ZoomWebhookBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// ZoomWebhookInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "zoom-webhook" endpoint HTTP response body for the
// "InternalServerError" error.
type ZoomWebhookInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// ZoomWebhookUnauthorizedResponseBody is the type of the "Meeting Service"
// service "zoom-webhook" endpoint HTTP response body for the "Unauthorized"
// error.
type ZoomWebhookUnauthorizedResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingsBadRequestResponseBody is the type of the "Meeting Service"
// service "get-past-meetings" endpoint HTTP response body for the "BadRequest"
// error.
type GetPastMeetingsBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingsInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "get-past-meetings" endpoint HTTP response body for the
// "InternalServerError" error.
type GetPastMeetingsInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingsServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "get-past-meetings" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type GetPastMeetingsServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingBadRequestResponseBody is the type of the "Meeting Service"
// service "create-past-meeting" endpoint HTTP response body for the
// "BadRequest" error.
type CreatePastMeetingBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingConflictResponseBody is the type of the "Meeting Service"
// service "create-past-meeting" endpoint HTTP response body for the "Conflict"
// error.
type CreatePastMeetingConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "create-past-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type CreatePastMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "create-past-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type CreatePastMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "get-past-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type GetPastMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingNotFoundResponseBody is the type of the "Meeting Service"
// service "get-past-meeting" endpoint HTTP response body for the "NotFound"
// error.
type GetPastMeetingNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "get-past-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type GetPastMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeletePastMeetingBadRequestResponseBody is the type of the "Meeting Service"
// service "delete-past-meeting" endpoint HTTP response body for the
// "BadRequest" error.
type DeletePastMeetingBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeletePastMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "delete-past-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type DeletePastMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeletePastMeetingNotFoundResponseBody is the type of the "Meeting Service"
// service "delete-past-meeting" endpoint HTTP response body for the "NotFound"
// error.
type DeletePastMeetingNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeletePastMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "delete-past-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type DeletePastMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingParticipantsInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "get-past-meeting-participants" endpoint HTTP
// response body for the "InternalServerError" error.
type GetPastMeetingParticipantsInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingParticipantsNotFoundResponseBody is the type of the "Meeting
// Service" service "get-past-meeting-participants" endpoint HTTP response body
// for the "NotFound" error.
type GetPastMeetingParticipantsNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingParticipantsServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "get-past-meeting-participants" endpoint HTTP
// response body for the "ServiceUnavailable" error.
type GetPastMeetingParticipantsServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingParticipantBadRequestResponseBody is the type of the
// "Meeting Service" service "create-past-meeting-participant" endpoint HTTP
// response body for the "BadRequest" error.
type CreatePastMeetingParticipantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingParticipantConflictResponseBody is the type of the "Meeting
// Service" service "create-past-meeting-participant" endpoint HTTP response
// body for the "Conflict" error.
type CreatePastMeetingParticipantConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingParticipantInternalServerErrorResponseBody is the type of
// the "Meeting Service" service "create-past-meeting-participant" endpoint
// HTTP response body for the "InternalServerError" error.
type CreatePastMeetingParticipantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingParticipantNotFoundResponseBody is the type of the "Meeting
// Service" service "create-past-meeting-participant" endpoint HTTP response
// body for the "NotFound" error.
type CreatePastMeetingParticipantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreatePastMeetingParticipantServiceUnavailableResponseBody is the type of
// the "Meeting Service" service "create-past-meeting-participant" endpoint
// HTTP response body for the "ServiceUnavailable" error.
type CreatePastMeetingParticipantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingParticipantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "get-past-meeting-participant" endpoint HTTP
// response body for the "InternalServerError" error.
type GetPastMeetingParticipantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingParticipantNotFoundResponseBody is the type of the "Meeting
// Service" service "get-past-meeting-participant" endpoint HTTP response body
// for the "NotFound" error.
type GetPastMeetingParticipantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetPastMeetingParticipantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "get-past-meeting-participant" endpoint HTTP
// response body for the "ServiceUnavailable" error.
type GetPastMeetingParticipantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdatePastMeetingParticipantBadRequestResponseBody is the type of the
// "Meeting Service" service "update-past-meeting-participant" endpoint HTTP
// response body for the "BadRequest" error.
type UpdatePastMeetingParticipantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdatePastMeetingParticipantConflictResponseBody is the type of the "Meeting
// Service" service "update-past-meeting-participant" endpoint HTTP response
// body for the "Conflict" error.
type UpdatePastMeetingParticipantConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdatePastMeetingParticipantInternalServerErrorResponseBody is the type of
// the "Meeting Service" service "update-past-meeting-participant" endpoint
// HTTP response body for the "InternalServerError" error.
type UpdatePastMeetingParticipantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdatePastMeetingParticipantNotFoundResponseBody is the type of the "Meeting
// Service" service "update-past-meeting-participant" endpoint HTTP response
// body for the "NotFound" error.
type UpdatePastMeetingParticipantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdatePastMeetingParticipantServiceUnavailableResponseBody is the type of
// the "Meeting Service" service "update-past-meeting-participant" endpoint
// HTTP response body for the "ServiceUnavailable" error.
type UpdatePastMeetingParticipantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeletePastMeetingParticipantBadRequestResponseBody is the type of the
// "Meeting Service" service "delete-past-meeting-participant" endpoint HTTP
// response body for the "BadRequest" error.
type DeletePastMeetingParticipantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeletePastMeetingParticipantInternalServerErrorResponseBody is the type of
// the "Meeting Service" service "delete-past-meeting-participant" endpoint
// HTTP response body for the "InternalServerError" error.
type DeletePastMeetingParticipantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeletePastMeetingParticipantNotFoundResponseBody is the type of the "Meeting
// Service" service "delete-past-meeting-participant" endpoint HTTP response
// body for the "NotFound" error.
type DeletePastMeetingParticipantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeletePastMeetingParticipantServiceUnavailableResponseBody is the type of
// the "Meeting Service" service "delete-past-meeting-participant" endpoint
// HTTP response body for the "ServiceUnavailable" error.
type DeletePastMeetingParticipantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// ReadyzServiceUnavailableResponseBody is the type of the "Meeting Service"
// service "readyz" endpoint HTTP response body for the "ServiceUnavailable"
// error.
type ReadyzServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// MeetingFullResponseBody is used to define fields on response body types.
type MeetingFullResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	JoinURL *string `form:"join_url,omitempty" json:"join_url,omitempty" xml:"join_url,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// The number of registrants that have an email delivery error with their
	// invite. The delivery errors are counted as the last invite that was sent to
	// the registrant, so if a registrant previously had a delivery error but not
	// in their most recent invite received, then it does not count towards this
	// field value.
	EmailDeliveryErrorCount *int `form:"email_delivery_error_count,omitempty" json:"email_delivery_error_count,omitempty" xml:"email_delivery_error_count,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// The number of registrants for the meeting
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// The number of registrants that have declined the meeting invitation
	RegistrantResponseDeclinedCount *int `form:"registrant_response_declined_count,omitempty" json:"registrant_response_declined_count,omitempty" xml:"registrant_response_declined_count,omitempty"`
	// The number of registrants that have accepted the meeting invitation
	RegistrantResponseAcceptedCount *int `form:"registrant_response_accepted_count,omitempty" json:"registrant_response_accepted_count,omitempty" xml:"registrant_response_accepted_count,omitempty"`
	// Array of meeting occurrences (read-only from platform API)
	Occurrences []*OccurrenceResponseBody `form:"occurrences,omitempty" json:"occurrences,omitempty" xml:"occurrences,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
	// The organizers of the meeting. This is a list of LFIDs of the meeting
	// organizers.
	Organizers []string `form:"organizers,omitempty" json:"organizers,omitempty" xml:"organizers,omitempty"`
}

// RecurrenceResponseBody is used to define fields on response body types.
type RecurrenceResponseBody struct {
	// The recurrence type
	Type int `form:"type" json:"type" xml:"type"`
	// Define the interval at which the meeting should recur.
	// For instance, if you would like to schedule a meeting that recurs every two
	// months,
	// you must set the value of this field as '2' and the value of the 'type'
	// parameter as '3'.
	// For a daily meeting, the maximum interval you can set is '90' days.
	// For a weekly meeting the maximum interval that you can set is of '12' weeks.
	// For a monthly meeting, there is a maximum of '3' months.
	RepeatInterval int `form:"repeat_interval" json:"repeat_interval" xml:"repeat_interval"`
	// This field is required if you're scheduling a recurring meeting of type '2'
	// to state which day(s)
	// of the week the meeting should repeat. The value for this field could be a
	// number between '1' to '7' in string format.
	// For instance, if the meeting should recur on Sunday, provide '1' as the
	// value of this field.
	// If you would like the meeting to occur on multiple days of a week, you
	// should provide comma separated values for this field.
	// For instance, if the meeting should recur on Sundays and Tuesdays provide
	// '1,3' as the value of this field.
	// 1 - Sunday
	// 2 - Monday
	// 3 - Tuesday
	// 4 - Wednesday
	// 5 - Thursday
	// 6 - Friday
	// 7 - Saturday
	WeeklyDays *string `form:"weekly_days,omitempty" json:"weekly_days,omitempty" xml:"weekly_days,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state which day in a month, the meeting should recur. The value range is
	// from 1 to 31. For instance, if you would like the meeting to recur on 23rd
	// of each month, provide '23' as the value of this field and '1' as the value
	// of the 'repeat_interval' field. Instead, if you would like the meeting to
	// recur every three months, on 23rd of the month, change the value of the
	// 'repeat_interval' field to '3'.
	MonthlyDay *int `form:"monthly_day,omitempty" json:"monthly_day,omitempty" xml:"monthly_day,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state the week of the month when the meeting should recur. If you use this
	// field, you must also use the 'monthly_week_day' field to state the day of
	// the week when the meeting should recur. '-1' - Last week of the month. 1 -
	// First week of the month. 2 - Second week of the month. 3 - Third week of the
	// month. 4 - Fourth week of the month.
	MonthlyWeek *int `form:"monthly_week,omitempty" json:"monthly_week,omitempty" xml:"monthly_week,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state a specific day in a week when the monthly meeting should recur. To use
	// this field, you must also use the 'monthly_week' field. 1 - Sunday 2 -
	// Monday 3 - Tuesday 4 - Wednesday 5 - Thursday 6 - Friday 7 - Saturday
	MonthlyWeekDay *int `form:"monthly_week_day,omitempty" json:"monthly_week_day,omitempty" xml:"monthly_week_day,omitempty"`
	// Select how many times the meeting should recur before it is canceled. Cannot
	// be used with 'end_date_time'.
	EndTimes *int `form:"end_times,omitempty" json:"end_times,omitempty" xml:"end_times,omitempty"`
	// Select the final date on which the meeting will recur before it is canceled.
	// Cannot be used with 'end_times'. should be in GMT. should be in
	// 'yyyy-MM-ddTHH:mm:ssZ' format.
	EndDateTime *string `form:"end_date_time,omitempty" json:"end_date_time,omitempty" xml:"end_date_time,omitempty"`
}

// CommitteeResponseBody is used to define fields on response body types.
type CommitteeResponseBody struct {
	// The UID of the committee
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The committee voting statuses required for committee members to be added to
	// the meeting
	AllowedVotingStatuses []string `form:"allowed_voting_statuses" json:"allowed_voting_statuses" xml:"allowed_voting_statuses"`
}

// ZoomConfigFullResponseBody is used to define fields on response body types.
type ZoomConfigFullResponseBody struct {
	// The ID of the created meeting in Zoom
	MeetingID *string `form:"meeting_id,omitempty" json:"meeting_id,omitempty" xml:"meeting_id,omitempty"`
	// The zoom-defined passcode for the meeting. Required if joining via dial-in,
	// or by clicking 'join meeting' in the zoom client & putting in the meeting id
	// and passcode.
	Passcode *string `form:"passcode,omitempty" json:"passcode,omitempty" xml:"passcode,omitempty"`
	// For zoom platform meetings: whether Zoom AI companion is enabled
	AiCompanionEnabled *bool `form:"ai_companion_enabled,omitempty" json:"ai_companion_enabled,omitempty" xml:"ai_companion_enabled,omitempty"`
	// For zoom platform meetings: whether AI summary approval is required
	AiSummaryRequireApproval *bool `form:"ai_summary_require_approval,omitempty" json:"ai_summary_require_approval,omitempty" xml:"ai_summary_require_approval,omitempty"`
}

// OccurrenceResponseBody is used to define fields on response body types.
type OccurrenceResponseBody struct {
	// ID of the occurrence, also the start time in unix time
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// GMT start time of occurrence
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// Meeting title for this occurrence
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Meeting description for this occurrence
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Occurrence duration in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The recurrence pattern for this occurrence onwards if there is one
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// Number of registrants for this meeting occurrence
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// Number of registrants who declined the invite for this occurrence
	ResponseCountNo *int `form:"response_count_no,omitempty" json:"response_count_no,omitempty" xml:"response_count_no,omitempty"`
	// Number of registrants who accepted the invite for this occurrence
	ResponseCountYes *int `form:"response_count_yes,omitempty" json:"response_count_yes,omitempty" xml:"response_count_yes,omitempty"`
	// Occurrence status from platform
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// MeetingBaseResponseBody is used to define fields on response body types.
type MeetingBaseResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	JoinURL *string `form:"join_url,omitempty" json:"join_url,omitempty" xml:"join_url,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// The number of registrants that have an email delivery error with their
	// invite. The delivery errors are counted as the last invite that was sent to
	// the registrant, so if a registrant previously had a delivery error but not
	// in their most recent invite received, then it does not count towards this
	// field value.
	EmailDeliveryErrorCount *int `form:"email_delivery_error_count,omitempty" json:"email_delivery_error_count,omitempty" xml:"email_delivery_error_count,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// The number of registrants for the meeting
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// The number of registrants that have declined the meeting invitation
	RegistrantResponseDeclinedCount *int `form:"registrant_response_declined_count,omitempty" json:"registrant_response_declined_count,omitempty" xml:"registrant_response_declined_count,omitempty"`
	// The number of registrants that have accepted the meeting invitation
	RegistrantResponseAcceptedCount *int `form:"registrant_response_accepted_count,omitempty" json:"registrant_response_accepted_count,omitempty" xml:"registrant_response_accepted_count,omitempty"`
	// Array of meeting occurrences (read-only from platform API)
	Occurrences []*OccurrenceResponseBody `form:"occurrences,omitempty" json:"occurrences,omitempty" xml:"occurrences,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// MeetingSettingsResponseBody is used to define fields on response body types.
type MeetingSettingsResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The organizers of the meeting. This is a list of LFIDs of the meeting
	// organizers.
	Organizers []string `form:"organizers,omitempty" json:"organizers,omitempty" xml:"organizers,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// RegistrantResponseBody is used to define fields on response body types.
type RegistrantResponseBody struct {
	// The UID of the registrant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// PastMeetingResponseBody is used to define fields on response body types.
type PastMeetingResponseBody struct {
	// The unique identifier of the past meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the original meeting
	MeetingUID *string `form:"meeting_uid,omitempty" json:"meeting_uid,omitempty" xml:"meeting_uid,omitempty"`
	// The occurrence ID for recurring meetings
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The scheduled start time of the past meeting
	ScheduledStartTime *string `form:"scheduled_start_time,omitempty" json:"scheduled_start_time,omitempty" xml:"scheduled_start_time,omitempty"`
	// The scheduled end time of the past meeting
	ScheduledEndTime *string `form:"scheduled_end_time,omitempty" json:"scheduled_end_time,omitempty" xml:"scheduled_end_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The ID of the meeting in the platform (e.g. Zoom meeting ID)
	PlatformMeetingID *string `form:"platform_meeting_id,omitempty" json:"platform_meeting_id,omitempty" xml:"platform_meeting_id,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// Sessions represent individual start/end periods if a meeting was stopped and
	// restarted
	Sessions []*SessionResponseBody `form:"sessions,omitempty" json:"sessions,omitempty" xml:"sessions,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// SessionResponseBody is used to define fields on response body types.
type SessionResponseBody struct {
	// The unique identifier of the session
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The start time of the session
	StartTime string `form:"start_time" json:"start_time" xml:"start_time"`
	// The end time of the session (may be null if session is ongoing)
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty" xml:"end_time,omitempty"`
}

// PastMeetingParticipantResponseBody is used to define fields on response body
// types.
type PastMeetingParticipantResponseBody struct {
	// The UID of the past meeting participant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The unique identifier of the past meeting
	PastMeetingUID string `form:"past_meeting_uid" json:"past_meeting_uid" xml:"past_meeting_uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	Username *string `form:"username,omitempty" json:"username,omitempty" xml:"username,omitempty"`
	// Whether the participant was invited to this past meeting
	IsInvited *bool `form:"is_invited,omitempty" json:"is_invited,omitempty" xml:"is_invited,omitempty"`
	// Whether the participant attended this past meeting
	IsAttended *bool `form:"is_attended,omitempty" json:"is_attended,omitempty" xml:"is_attended,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// RecurrenceRequestBody is used to define fields on request body types.
type RecurrenceRequestBody struct {
	// The recurrence type
	Type *int `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Define the interval at which the meeting should recur.
	// For instance, if you would like to schedule a meeting that recurs every two
	// months,
	// you must set the value of this field as '2' and the value of the 'type'
	// parameter as '3'.
	// For a daily meeting, the maximum interval you can set is '90' days.
	// For a weekly meeting the maximum interval that you can set is of '12' weeks.
	// For a monthly meeting, there is a maximum of '3' months.
	RepeatInterval *int `form:"repeat_interval,omitempty" json:"repeat_interval,omitempty" xml:"repeat_interval,omitempty"`
	// This field is required if you're scheduling a recurring meeting of type '2'
	// to state which day(s)
	// of the week the meeting should repeat. The value for this field could be a
	// number between '1' to '7' in string format.
	// For instance, if the meeting should recur on Sunday, provide '1' as the
	// value of this field.
	// If you would like the meeting to occur on multiple days of a week, you
	// should provide comma separated values for this field.
	// For instance, if the meeting should recur on Sundays and Tuesdays provide
	// '1,3' as the value of this field.
	// 1 - Sunday
	// 2 - Monday
	// 3 - Tuesday
	// 4 - Wednesday
	// 5 - Thursday
	// 6 - Friday
	// 7 - Saturday
	WeeklyDays *string `form:"weekly_days,omitempty" json:"weekly_days,omitempty" xml:"weekly_days,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state which day in a month, the meeting should recur. The value range is
	// from 1 to 31. For instance, if you would like the meeting to recur on 23rd
	// of each month, provide '23' as the value of this field and '1' as the value
	// of the 'repeat_interval' field. Instead, if you would like the meeting to
	// recur every three months, on 23rd of the month, change the value of the
	// 'repeat_interval' field to '3'.
	MonthlyDay *int `form:"monthly_day,omitempty" json:"monthly_day,omitempty" xml:"monthly_day,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state the week of the month when the meeting should recur. If you use this
	// field, you must also use the 'monthly_week_day' field to state the day of
	// the week when the meeting should recur. '-1' - Last week of the month. 1 -
	// First week of the month. 2 - Second week of the month. 3 - Third week of the
	// month. 4 - Fourth week of the month.
	MonthlyWeek *int `form:"monthly_week,omitempty" json:"monthly_week,omitempty" xml:"monthly_week,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state a specific day in a week when the monthly meeting should recur. To use
	// this field, you must also use the 'monthly_week' field. 1 - Sunday 2 -
	// Monday 3 - Tuesday 4 - Wednesday 5 - Thursday 6 - Friday 7 - Saturday
	MonthlyWeekDay *int `form:"monthly_week_day,omitempty" json:"monthly_week_day,omitempty" xml:"monthly_week_day,omitempty"`
	// Select how many times the meeting should recur before it is canceled. Cannot
	// be used with 'end_date_time'.
	EndTimes *int `form:"end_times,omitempty" json:"end_times,omitempty" xml:"end_times,omitempty"`
	// Select the final date on which the meeting will recur before it is canceled.
	// Cannot be used with 'end_times'. should be in GMT. should be in
	// 'yyyy-MM-ddTHH:mm:ssZ' format.
	EndDateTime *string `form:"end_date_time,omitempty" json:"end_date_time,omitempty" xml:"end_date_time,omitempty"`
}

// CommitteeRequestBody is used to define fields on request body types.
type CommitteeRequestBody struct {
	// The UID of the committee
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The committee voting statuses required for committee members to be added to
	// the meeting
	AllowedVotingStatuses []string `form:"allowed_voting_statuses,omitempty" json:"allowed_voting_statuses,omitempty" xml:"allowed_voting_statuses,omitempty"`
}

// ZoomConfigPostRequestBody is used to define fields on request body types.
type ZoomConfigPostRequestBody struct {
	// For zoom platform meetings: whether Zoom AI companion is enabled
	AiCompanionEnabled *bool `form:"ai_companion_enabled,omitempty" json:"ai_companion_enabled,omitempty" xml:"ai_companion_enabled,omitempty"`
	// For zoom platform meetings: whether AI summary approval is required
	AiSummaryRequireApproval *bool `form:"ai_summary_require_approval,omitempty" json:"ai_summary_require_approval,omitempty" xml:"ai_summary_require_approval,omitempty"`
}

// ZoomConfigFullRequestBody is used to define fields on request body types.
type ZoomConfigFullRequestBody struct {
	// The ID of the created meeting in Zoom
	MeetingID *string `form:"meeting_id,omitempty" json:"meeting_id,omitempty" xml:"meeting_id,omitempty"`
	// The zoom-defined passcode for the meeting. Required if joining via dial-in,
	// or by clicking 'join meeting' in the zoom client & putting in the meeting id
	// and passcode.
	Passcode *string `form:"passcode,omitempty" json:"passcode,omitempty" xml:"passcode,omitempty"`
	// For zoom platform meetings: whether Zoom AI companion is enabled
	AiCompanionEnabled *bool `form:"ai_companion_enabled,omitempty" json:"ai_companion_enabled,omitempty" xml:"ai_companion_enabled,omitempty"`
	// For zoom platform meetings: whether AI summary approval is required
	AiSummaryRequireApproval *bool `form:"ai_summary_require_approval,omitempty" json:"ai_summary_require_approval,omitempty" xml:"ai_summary_require_approval,omitempty"`
}

// SessionRequestBody is used to define fields on request body types.
type SessionRequestBody struct {
	// The unique identifier of the session
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The start time of the session
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The end time of the session (may be null if session is ongoing)
	EndTime *string `form:"end_time,omitempty" json:"end_time,omitempty" xml:"end_time,omitempty"`
}

// NewGetMeetingsResponseBody builds the HTTP response body from the result of
// the "get-meetings" endpoint of the "Meeting Service" service.
func NewGetMeetingsResponseBody(res *meetingservice.GetMeetingsResult) *GetMeetingsResponseBody {
	body := &GetMeetingsResponseBody{}
	if res.Meetings != nil {
		body.Meetings = make([]*MeetingFullResponseBody, len(res.Meetings))
		for i, val := range res.Meetings {
			body.Meetings[i] = marshalMeetingserviceMeetingFullToMeetingFullResponseBody(val)
		}
	} else {
		body.Meetings = []*MeetingFullResponseBody{}
	}
	return body
}

// NewCreateMeetingResponseBody builds the HTTP response body from the result
// of the "create-meeting" endpoint of the "Meeting Service" service.
func NewCreateMeetingResponseBody(res *meetingservice.MeetingFull) *CreateMeetingResponseBody {
	body := &CreateMeetingResponseBody{
		UID:                             res.UID,
		ProjectUID:                      res.ProjectUID,
		StartTime:                       res.StartTime,
		Duration:                        res.Duration,
		Timezone:                        res.Timezone,
		Title:                           res.Title,
		Description:                     res.Description,
		Platform:                        res.Platform,
		EarlyJoinTimeMinutes:            res.EarlyJoinTimeMinutes,
		MeetingType:                     res.MeetingType,
		Visibility:                      res.Visibility,
		Restricted:                      res.Restricted,
		ArtifactVisibility:              res.ArtifactVisibility,
		JoinURL:                         res.JoinURL,
		PublicLink:                      res.PublicLink,
		EmailDeliveryErrorCount:         res.EmailDeliveryErrorCount,
		RecordingEnabled:                res.RecordingEnabled,
		TranscriptEnabled:               res.TranscriptEnabled,
		YoutubeUploadEnabled:            res.YoutubeUploadEnabled,
		RegistrantCount:                 res.RegistrantCount,
		RegistrantResponseDeclinedCount: res.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: res.RegistrantResponseAcceptedCount,
		CreatedAt:                       res.CreatedAt,
		UpdatedAt:                       res.UpdatedAt,
	}
	if res.Recurrence != nil {
		body.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(res.Recurrence)
	}
	if res.Committees != nil {
		body.Committees = make([]*CommitteeResponseBody, len(res.Committees))
		for i, val := range res.Committees {
			body.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if res.ZoomConfig != nil {
		body.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(res.ZoomConfig)
	}
	if res.Occurrences != nil {
		body.Occurrences = make([]*OccurrenceResponseBody, len(res.Occurrences))
		for i, val := range res.Occurrences {
			body.Occurrences[i] = marshalMeetingserviceOccurrenceToOccurrenceResponseBody(val)
		}
	}
	if res.Organizers != nil {
		body.Organizers = make([]string, len(res.Organizers))
		for i, val := range res.Organizers {
			body.Organizers[i] = val
		}
	}
	return body
}

// NewGetMeetingBaseResponseBody builds the HTTP response body from the result
// of the "get-meeting-base" endpoint of the "Meeting Service" service.
func NewGetMeetingBaseResponseBody(res *meetingservice.GetMeetingBaseResult) *GetMeetingBaseResponseBody {
	body := &GetMeetingBaseResponseBody{
		UID:                             res.Meeting.UID,
		ProjectUID:                      res.Meeting.ProjectUID,
		StartTime:                       res.Meeting.StartTime,
		Duration:                        res.Meeting.Duration,
		Timezone:                        res.Meeting.Timezone,
		Title:                           res.Meeting.Title,
		Description:                     res.Meeting.Description,
		Platform:                        res.Meeting.Platform,
		EarlyJoinTimeMinutes:            res.Meeting.EarlyJoinTimeMinutes,
		MeetingType:                     res.Meeting.MeetingType,
		Visibility:                      res.Meeting.Visibility,
		Restricted:                      res.Meeting.Restricted,
		ArtifactVisibility:              res.Meeting.ArtifactVisibility,
		JoinURL:                         res.Meeting.JoinURL,
		PublicLink:                      res.Meeting.PublicLink,
		EmailDeliveryErrorCount:         res.Meeting.EmailDeliveryErrorCount,
		RecordingEnabled:                res.Meeting.RecordingEnabled,
		TranscriptEnabled:               res.Meeting.TranscriptEnabled,
		YoutubeUploadEnabled:            res.Meeting.YoutubeUploadEnabled,
		RegistrantCount:                 res.Meeting.RegistrantCount,
		RegistrantResponseDeclinedCount: res.Meeting.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: res.Meeting.RegistrantResponseAcceptedCount,
		CreatedAt:                       res.Meeting.CreatedAt,
		UpdatedAt:                       res.Meeting.UpdatedAt,
	}
	if res.Meeting.Recurrence != nil {
		body.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(res.Meeting.Recurrence)
	}
	if res.Meeting.Committees != nil {
		body.Committees = make([]*CommitteeResponseBody, len(res.Meeting.Committees))
		for i, val := range res.Meeting.Committees {
			body.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if res.Meeting.ZoomConfig != nil {
		body.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(res.Meeting.ZoomConfig)
	}
	if res.Meeting.Occurrences != nil {
		body.Occurrences = make([]*OccurrenceResponseBody, len(res.Meeting.Occurrences))
		for i, val := range res.Meeting.Occurrences {
			body.Occurrences[i] = marshalMeetingserviceOccurrenceToOccurrenceResponseBody(val)
		}
	}
	return body
}

// NewGetMeetingSettingsResponseBody builds the HTTP response body from the
// result of the "get-meeting-settings" endpoint of the "Meeting Service"
// service.
func NewGetMeetingSettingsResponseBody(res *meetingservice.GetMeetingSettingsResult) *GetMeetingSettingsResponseBody {
	body := &GetMeetingSettingsResponseBody{
		UID:       res.MeetingSettings.UID,
		CreatedAt: res.MeetingSettings.CreatedAt,
		UpdatedAt: res.MeetingSettings.UpdatedAt,
	}
	if res.MeetingSettings.Organizers != nil {
		body.Organizers = make([]string, len(res.MeetingSettings.Organizers))
		for i, val := range res.MeetingSettings.Organizers {
			body.Organizers[i] = val
		}
	}
	return body
}

// NewUpdateMeetingBaseResponseBody builds the HTTP response body from the
// result of the "update-meeting-base" endpoint of the "Meeting Service"
// service.
func NewUpdateMeetingBaseResponseBody(res *meetingservice.MeetingBase) *UpdateMeetingBaseResponseBody {
	body := &UpdateMeetingBaseResponseBody{
		UID:                             res.UID,
		ProjectUID:                      res.ProjectUID,
		StartTime:                       res.StartTime,
		Duration:                        res.Duration,
		Timezone:                        res.Timezone,
		Title:                           res.Title,
		Description:                     res.Description,
		Platform:                        res.Platform,
		EarlyJoinTimeMinutes:            res.EarlyJoinTimeMinutes,
		MeetingType:                     res.MeetingType,
		Visibility:                      res.Visibility,
		Restricted:                      res.Restricted,
		ArtifactVisibility:              res.ArtifactVisibility,
		JoinURL:                         res.JoinURL,
		PublicLink:                      res.PublicLink,
		EmailDeliveryErrorCount:         res.EmailDeliveryErrorCount,
		RecordingEnabled:                res.RecordingEnabled,
		TranscriptEnabled:               res.TranscriptEnabled,
		YoutubeUploadEnabled:            res.YoutubeUploadEnabled,
		RegistrantCount:                 res.RegistrantCount,
		RegistrantResponseDeclinedCount: res.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: res.RegistrantResponseAcceptedCount,
		CreatedAt:                       res.CreatedAt,
		UpdatedAt:                       res.UpdatedAt,
	}
	if res.Recurrence != nil {
		body.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(res.Recurrence)
	}
	if res.Committees != nil {
		body.Committees = make([]*CommitteeResponseBody, len(res.Committees))
		for i, val := range res.Committees {
			body.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if res.ZoomConfig != nil {
		body.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(res.ZoomConfig)
	}
	if res.Occurrences != nil {
		body.Occurrences = make([]*OccurrenceResponseBody, len(res.Occurrences))
		for i, val := range res.Occurrences {
			body.Occurrences[i] = marshalMeetingserviceOccurrenceToOccurrenceResponseBody(val)
		}
	}
	return body
}

// NewUpdateMeetingSettingsResponseBody builds the HTTP response body from the
// result of the "update-meeting-settings" endpoint of the "Meeting Service"
// service.
func NewUpdateMeetingSettingsResponseBody(res *meetingservice.MeetingSettings) *UpdateMeetingSettingsResponseBody {
	body := &UpdateMeetingSettingsResponseBody{
		UID:       res.UID,
		CreatedAt: res.CreatedAt,
		UpdatedAt: res.UpdatedAt,
	}
	if res.Organizers != nil {
		body.Organizers = make([]string, len(res.Organizers))
		for i, val := range res.Organizers {
			body.Organizers[i] = val
		}
	}
	return body
}

// NewGetMeetingRegistrantsResponseBody builds the HTTP response body from the
// result of the "get-meeting-registrants" endpoint of the "Meeting Service"
// service.
func NewGetMeetingRegistrantsResponseBody(res *meetingservice.GetMeetingRegistrantsResult) *GetMeetingRegistrantsResponseBody {
	body := &GetMeetingRegistrantsResponseBody{}
	if res.Registrants != nil {
		body.Registrants = make([]*RegistrantResponseBody, len(res.Registrants))
		for i, val := range res.Registrants {
			body.Registrants[i] = marshalMeetingserviceRegistrantToRegistrantResponseBody(val)
		}
	} else {
		body.Registrants = []*RegistrantResponseBody{}
	}
	return body
}

// NewCreateMeetingRegistrantResponseBody builds the HTTP response body from
// the result of the "create-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewCreateMeetingRegistrantResponseBody(res *meetingservice.Registrant) *CreateMeetingRegistrantResponseBody {
	body := &CreateMeetingRegistrantResponseBody{
		UID:                res.UID,
		MeetingUID:         res.MeetingUID,
		Email:              res.Email,
		FirstName:          res.FirstName,
		LastName:           res.LastName,
		Host:               res.Host,
		JobTitle:           res.JobTitle,
		OccurrenceID:       res.OccurrenceID,
		OrgName:            res.OrgName,
		OrgIsMember:        res.OrgIsMember,
		OrgIsProjectMember: res.OrgIsProjectMember,
		AvatarURL:          res.AvatarURL,
		Username:           res.Username,
		CreatedAt:          res.CreatedAt,
		UpdatedAt:          res.UpdatedAt,
	}
	return body
}

// NewGetMeetingRegistrantResponseBody builds the HTTP response body from the
// result of the "get-meeting-registrant" endpoint of the "Meeting Service"
// service.
func NewGetMeetingRegistrantResponseBody(res *meetingservice.GetMeetingRegistrantResult) *GetMeetingRegistrantResponseBody {
	body := &GetMeetingRegistrantResponseBody{
		UID:                res.Registrant.UID,
		MeetingUID:         res.Registrant.MeetingUID,
		Email:              res.Registrant.Email,
		FirstName:          res.Registrant.FirstName,
		LastName:           res.Registrant.LastName,
		Host:               res.Registrant.Host,
		JobTitle:           res.Registrant.JobTitle,
		OccurrenceID:       res.Registrant.OccurrenceID,
		OrgName:            res.Registrant.OrgName,
		OrgIsMember:        res.Registrant.OrgIsMember,
		OrgIsProjectMember: res.Registrant.OrgIsProjectMember,
		AvatarURL:          res.Registrant.AvatarURL,
		Username:           res.Registrant.Username,
		CreatedAt:          res.Registrant.CreatedAt,
		UpdatedAt:          res.Registrant.UpdatedAt,
	}
	return body
}

// NewUpdateMeetingRegistrantResponseBody builds the HTTP response body from
// the result of the "update-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingRegistrantResponseBody(res *meetingservice.Registrant) *UpdateMeetingRegistrantResponseBody {
	body := &UpdateMeetingRegistrantResponseBody{
		UID:                res.UID,
		MeetingUID:         res.MeetingUID,
		Email:              res.Email,
		FirstName:          res.FirstName,
		LastName:           res.LastName,
		Host:               res.Host,
		JobTitle:           res.JobTitle,
		OccurrenceID:       res.OccurrenceID,
		OrgName:            res.OrgName,
		OrgIsMember:        res.OrgIsMember,
		OrgIsProjectMember: res.OrgIsProjectMember,
		AvatarURL:          res.AvatarURL,
		Username:           res.Username,
		CreatedAt:          res.CreatedAt,
		UpdatedAt:          res.UpdatedAt,
	}
	return body
}

// NewZoomWebhookResponseBody builds the HTTP response body from the result of
// the "zoom-webhook" endpoint of the "Meeting Service" service.
func NewZoomWebhookResponseBody(res *meetingservice.ZoomWebhookResponse) *ZoomWebhookResponseBody {
	body := &ZoomWebhookResponseBody{
		Status:  res.Status,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingsResponseBody builds the HTTP response body from the result
// of the "get-past-meetings" endpoint of the "Meeting Service" service.
func NewGetPastMeetingsResponseBody(res *meetingservice.GetPastMeetingsResult) *GetPastMeetingsResponseBody {
	body := &GetPastMeetingsResponseBody{}
	if res.PastMeetings != nil {
		body.PastMeetings = make([]*PastMeetingResponseBody, len(res.PastMeetings))
		for i, val := range res.PastMeetings {
			body.PastMeetings[i] = marshalMeetingservicePastMeetingToPastMeetingResponseBody(val)
		}
	} else {
		body.PastMeetings = []*PastMeetingResponseBody{}
	}
	return body
}

// NewCreatePastMeetingResponseBody builds the HTTP response body from the
// result of the "create-past-meeting" endpoint of the "Meeting Service"
// service.
func NewCreatePastMeetingResponseBody(res *meetingservice.PastMeeting) *CreatePastMeetingResponseBody {
	body := &CreatePastMeetingResponseBody{
		UID:                  res.UID,
		MeetingUID:           res.MeetingUID,
		OccurrenceID:         res.OccurrenceID,
		ProjectUID:           res.ProjectUID,
		ScheduledStartTime:   res.ScheduledStartTime,
		ScheduledEndTime:     res.ScheduledEndTime,
		Duration:             res.Duration,
		Timezone:             res.Timezone,
		Title:                res.Title,
		Description:          res.Description,
		Platform:             res.Platform,
		PlatformMeetingID:    res.PlatformMeetingID,
		EarlyJoinTimeMinutes: res.EarlyJoinTimeMinutes,
		MeetingType:          res.MeetingType,
		Visibility:           res.Visibility,
		Restricted:           res.Restricted,
		ArtifactVisibility:   res.ArtifactVisibility,
		PublicLink:           res.PublicLink,
		RecordingEnabled:     res.RecordingEnabled,
		TranscriptEnabled:    res.TranscriptEnabled,
		YoutubeUploadEnabled: res.YoutubeUploadEnabled,
		CreatedAt:            res.CreatedAt,
		UpdatedAt:            res.UpdatedAt,
	}
	if res.Recurrence != nil {
		body.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(res.Recurrence)
	}
	if res.Committees != nil {
		body.Committees = make([]*CommitteeResponseBody, len(res.Committees))
		for i, val := range res.Committees {
			body.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if res.ZoomConfig != nil {
		body.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(res.ZoomConfig)
	}
	if res.Sessions != nil {
		body.Sessions = make([]*SessionResponseBody, len(res.Sessions))
		for i, val := range res.Sessions {
			body.Sessions[i] = marshalMeetingserviceSessionToSessionResponseBody(val)
		}
	}
	return body
}

// NewGetPastMeetingResponseBody builds the HTTP response body from the result
// of the "get-past-meeting" endpoint of the "Meeting Service" service.
func NewGetPastMeetingResponseBody(res *meetingservice.GetPastMeetingResult) *GetPastMeetingResponseBody {
	body := &GetPastMeetingResponseBody{
		UID:                  res.PastMeeting.UID,
		MeetingUID:           res.PastMeeting.MeetingUID,
		OccurrenceID:         res.PastMeeting.OccurrenceID,
		ProjectUID:           res.PastMeeting.ProjectUID,
		ScheduledStartTime:   res.PastMeeting.ScheduledStartTime,
		ScheduledEndTime:     res.PastMeeting.ScheduledEndTime,
		Duration:             res.PastMeeting.Duration,
		Timezone:             res.PastMeeting.Timezone,
		Title:                res.PastMeeting.Title,
		Description:          res.PastMeeting.Description,
		Platform:             res.PastMeeting.Platform,
		PlatformMeetingID:    res.PastMeeting.PlatformMeetingID,
		EarlyJoinTimeMinutes: res.PastMeeting.EarlyJoinTimeMinutes,
		MeetingType:          res.PastMeeting.MeetingType,
		Visibility:           res.PastMeeting.Visibility,
		Restricted:           res.PastMeeting.Restricted,
		ArtifactVisibility:   res.PastMeeting.ArtifactVisibility,
		PublicLink:           res.PastMeeting.PublicLink,
		RecordingEnabled:     res.PastMeeting.RecordingEnabled,
		TranscriptEnabled:    res.PastMeeting.TranscriptEnabled,
		YoutubeUploadEnabled: res.PastMeeting.YoutubeUploadEnabled,
		CreatedAt:            res.PastMeeting.CreatedAt,
		UpdatedAt:            res.PastMeeting.UpdatedAt,
	}
	if res.PastMeeting.Recurrence != nil {
		body.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(res.PastMeeting.Recurrence)
	}
	if res.PastMeeting.Committees != nil {
		body.Committees = make([]*CommitteeResponseBody, len(res.PastMeeting.Committees))
		for i, val := range res.PastMeeting.Committees {
			body.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if res.PastMeeting.ZoomConfig != nil {
		body.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(res.PastMeeting.ZoomConfig)
	}
	if res.PastMeeting.Sessions != nil {
		body.Sessions = make([]*SessionResponseBody, len(res.PastMeeting.Sessions))
		for i, val := range res.PastMeeting.Sessions {
			body.Sessions[i] = marshalMeetingserviceSessionToSessionResponseBody(val)
		}
	}
	return body
}

// NewGetPastMeetingParticipantsResponseBody builds the HTTP response body from
// the result of the "get-past-meeting-participants" endpoint of the "Meeting
// Service" service.
func NewGetPastMeetingParticipantsResponseBody(res *meetingservice.GetPastMeetingParticipantsResult) *GetPastMeetingParticipantsResponseBody {
	body := &GetPastMeetingParticipantsResponseBody{}
	if res.Participants != nil {
		body.Participants = make([]*PastMeetingParticipantResponseBody, len(res.Participants))
		for i, val := range res.Participants {
			body.Participants[i] = marshalMeetingservicePastMeetingParticipantToPastMeetingParticipantResponseBody(val)
		}
	} else {
		body.Participants = []*PastMeetingParticipantResponseBody{}
	}
	return body
}

// NewCreatePastMeetingParticipantResponseBody builds the HTTP response body
// from the result of the "create-past-meeting-participant" endpoint of the
// "Meeting Service" service.
func NewCreatePastMeetingParticipantResponseBody(res *meetingservice.PastMeetingParticipant) *CreatePastMeetingParticipantResponseBody {
	body := &CreatePastMeetingParticipantResponseBody{
		UID:                res.UID,
		PastMeetingUID:     res.PastMeetingUID,
		MeetingUID:         res.MeetingUID,
		Email:              res.Email,
		FirstName:          res.FirstName,
		LastName:           res.LastName,
		Host:               res.Host,
		JobTitle:           res.JobTitle,
		OrgName:            res.OrgName,
		OrgIsMember:        res.OrgIsMember,
		OrgIsProjectMember: res.OrgIsProjectMember,
		AvatarURL:          res.AvatarURL,
		Username:           res.Username,
		IsInvited:          res.IsInvited,
		IsAttended:         res.IsAttended,
		CreatedAt:          res.CreatedAt,
		UpdatedAt:          res.UpdatedAt,
	}
	return body
}

// NewGetPastMeetingParticipantResponseBody builds the HTTP response body from
// the result of the "get-past-meeting-participant" endpoint of the "Meeting
// Service" service.
func NewGetPastMeetingParticipantResponseBody(res *meetingservice.GetPastMeetingParticipantResult) *GetPastMeetingParticipantResponseBody {
	body := &GetPastMeetingParticipantResponseBody{
		UID:                res.Participant.UID,
		PastMeetingUID:     res.Participant.PastMeetingUID,
		MeetingUID:         res.Participant.MeetingUID,
		Email:              res.Participant.Email,
		FirstName:          res.Participant.FirstName,
		LastName:           res.Participant.LastName,
		Host:               res.Participant.Host,
		JobTitle:           res.Participant.JobTitle,
		OrgName:            res.Participant.OrgName,
		OrgIsMember:        res.Participant.OrgIsMember,
		OrgIsProjectMember: res.Participant.OrgIsProjectMember,
		AvatarURL:          res.Participant.AvatarURL,
		Username:           res.Participant.Username,
		IsInvited:          res.Participant.IsInvited,
		IsAttended:         res.Participant.IsAttended,
		CreatedAt:          res.Participant.CreatedAt,
		UpdatedAt:          res.Participant.UpdatedAt,
	}
	return body
}

// NewUpdatePastMeetingParticipantResponseBody builds the HTTP response body
// from the result of the "update-past-meeting-participant" endpoint of the
// "Meeting Service" service.
func NewUpdatePastMeetingParticipantResponseBody(res *meetingservice.PastMeetingParticipant) *UpdatePastMeetingParticipantResponseBody {
	body := &UpdatePastMeetingParticipantResponseBody{
		UID:                res.UID,
		PastMeetingUID:     res.PastMeetingUID,
		MeetingUID:         res.MeetingUID,
		Email:              res.Email,
		FirstName:          res.FirstName,
		LastName:           res.LastName,
		Host:               res.Host,
		JobTitle:           res.JobTitle,
		OrgName:            res.OrgName,
		OrgIsMember:        res.OrgIsMember,
		OrgIsProjectMember: res.OrgIsProjectMember,
		AvatarURL:          res.AvatarURL,
		Username:           res.Username,
		IsInvited:          res.IsInvited,
		IsAttended:         res.IsAttended,
		CreatedAt:          res.CreatedAt,
		UpdatedAt:          res.UpdatedAt,
	}
	return body
}

// NewGetMeetingsBadRequestResponseBody builds the HTTP response body from the
// result of the "get-meetings" endpoint of the "Meeting Service" service.
func NewGetMeetingsBadRequestResponseBody(res *meetingservice.BadRequestError) *GetMeetingsBadRequestResponseBody {
	body := &GetMeetingsBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingsInternalServerErrorResponseBody builds the HTTP response body
// from the result of the "get-meetings" endpoint of the "Meeting Service"
// service.
func NewGetMeetingsInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingsInternalServerErrorResponseBody {
	body := &GetMeetingsInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingsServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "get-meetings" endpoint of the "Meeting Service"
// service.
func NewGetMeetingsServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingsServiceUnavailableResponseBody {
	body := &GetMeetingsServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingBadRequestResponseBody builds the HTTP response body from
// the result of the "create-meeting" endpoint of the "Meeting Service" service.
func NewCreateMeetingBadRequestResponseBody(res *meetingservice.BadRequestError) *CreateMeetingBadRequestResponseBody {
	body := &CreateMeetingBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingConflictResponseBody builds the HTTP response body from the
// result of the "create-meeting" endpoint of the "Meeting Service" service.
func NewCreateMeetingConflictResponseBody(res *meetingservice.ConflictError) *CreateMeetingConflictResponseBody {
	body := &CreateMeetingConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "create-meeting" endpoint of the "Meeting
// Service" service.
func NewCreateMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *CreateMeetingInternalServerErrorResponseBody {
	body := &CreateMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "create-meeting" endpoint of the "Meeting Service"
// service.
func NewCreateMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *CreateMeetingServiceUnavailableResponseBody {
	body := &CreateMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingBaseInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "get-meeting-base" endpoint of the "Meeting
// Service" service.
func NewGetMeetingBaseInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingBaseInternalServerErrorResponseBody {
	body := &GetMeetingBaseInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingBaseNotFoundResponseBody builds the HTTP response body from the
// result of the "get-meeting-base" endpoint of the "Meeting Service" service.
func NewGetMeetingBaseNotFoundResponseBody(res *meetingservice.NotFoundError) *GetMeetingBaseNotFoundResponseBody {
	body := &GetMeetingBaseNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingBaseServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "get-meeting-base" endpoint of the "Meeting
// Service" service.
func NewGetMeetingBaseServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingBaseServiceUnavailableResponseBody {
	body := &GetMeetingBaseServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingSettingsInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "get-meeting-settings" endpoint of the
// "Meeting Service" service.
func NewGetMeetingSettingsInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingSettingsInternalServerErrorResponseBody {
	body := &GetMeetingSettingsInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingSettingsNotFoundResponseBody builds the HTTP response body from
// the result of the "get-meeting-settings" endpoint of the "Meeting Service"
// service.
func NewGetMeetingSettingsNotFoundResponseBody(res *meetingservice.NotFoundError) *GetMeetingSettingsNotFoundResponseBody {
	body := &GetMeetingSettingsNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingSettingsServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "get-meeting-settings" endpoint of the "Meeting
// Service" service.
func NewGetMeetingSettingsServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingSettingsServiceUnavailableResponseBody {
	body := &GetMeetingSettingsServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingBaseBadRequestResponseBody builds the HTTP response body
// from the result of the "update-meeting-base" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingBaseBadRequestResponseBody(res *meetingservice.BadRequestError) *UpdateMeetingBaseBadRequestResponseBody {
	body := &UpdateMeetingBaseBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingBaseConflictResponseBody builds the HTTP response body from
// the result of the "update-meeting-base" endpoint of the "Meeting Service"
// service.
func NewUpdateMeetingBaseConflictResponseBody(res *meetingservice.ConflictError) *UpdateMeetingBaseConflictResponseBody {
	body := &UpdateMeetingBaseConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingBaseInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "update-meeting-base" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingBaseInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *UpdateMeetingBaseInternalServerErrorResponseBody {
	body := &UpdateMeetingBaseInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingBaseNotFoundResponseBody builds the HTTP response body from
// the result of the "update-meeting-base" endpoint of the "Meeting Service"
// service.
func NewUpdateMeetingBaseNotFoundResponseBody(res *meetingservice.NotFoundError) *UpdateMeetingBaseNotFoundResponseBody {
	body := &UpdateMeetingBaseNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingBaseServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "update-meeting-base" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingBaseServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *UpdateMeetingBaseServiceUnavailableResponseBody {
	body := &UpdateMeetingBaseServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingSettingsBadRequestResponseBody builds the HTTP response body
// from the result of the "update-meeting-settings" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingSettingsBadRequestResponseBody(res *meetingservice.BadRequestError) *UpdateMeetingSettingsBadRequestResponseBody {
	body := &UpdateMeetingSettingsBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingSettingsInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "update-meeting-settings" endpoint of
// the "Meeting Service" service.
func NewUpdateMeetingSettingsInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *UpdateMeetingSettingsInternalServerErrorResponseBody {
	body := &UpdateMeetingSettingsInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingSettingsNotFoundResponseBody builds the HTTP response body
// from the result of the "update-meeting-settings" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingSettingsNotFoundResponseBody(res *meetingservice.NotFoundError) *UpdateMeetingSettingsNotFoundResponseBody {
	body := &UpdateMeetingSettingsNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingSettingsServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "update-meeting-settings" endpoint of
// the "Meeting Service" service.
func NewUpdateMeetingSettingsServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *UpdateMeetingSettingsServiceUnavailableResponseBody {
	body := &UpdateMeetingSettingsServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingBadRequestResponseBody builds the HTTP response body from
// the result of the "delete-meeting" endpoint of the "Meeting Service" service.
func NewDeleteMeetingBadRequestResponseBody(res *meetingservice.BadRequestError) *DeleteMeetingBadRequestResponseBody {
	body := &DeleteMeetingBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "delete-meeting" endpoint of the "Meeting
// Service" service.
func NewDeleteMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *DeleteMeetingInternalServerErrorResponseBody {
	body := &DeleteMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingNotFoundResponseBody builds the HTTP response body from the
// result of the "delete-meeting" endpoint of the "Meeting Service" service.
func NewDeleteMeetingNotFoundResponseBody(res *meetingservice.NotFoundError) *DeleteMeetingNotFoundResponseBody {
	body := &DeleteMeetingNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "delete-meeting" endpoint of the "Meeting Service"
// service.
func NewDeleteMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *DeleteMeetingServiceUnavailableResponseBody {
	body := &DeleteMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantsInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "get-meeting-registrants" endpoint of
// the "Meeting Service" service.
func NewGetMeetingRegistrantsInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingRegistrantsInternalServerErrorResponseBody {
	body := &GetMeetingRegistrantsInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantsNotFoundResponseBody builds the HTTP response body
// from the result of the "get-meeting-registrants" endpoint of the "Meeting
// Service" service.
func NewGetMeetingRegistrantsNotFoundResponseBody(res *meetingservice.NotFoundError) *GetMeetingRegistrantsNotFoundResponseBody {
	body := &GetMeetingRegistrantsNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantsServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "get-meeting-registrants" endpoint of
// the "Meeting Service" service.
func NewGetMeetingRegistrantsServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingRegistrantsServiceUnavailableResponseBody {
	body := &GetMeetingRegistrantsServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantBadRequestResponseBody builds the HTTP response
// body from the result of the "create-meeting-registrant" endpoint of the
// "Meeting Service" service.
func NewCreateMeetingRegistrantBadRequestResponseBody(res *meetingservice.BadRequestError) *CreateMeetingRegistrantBadRequestResponseBody {
	body := &CreateMeetingRegistrantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantConflictResponseBody builds the HTTP response body
// from the result of the "create-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewCreateMeetingRegistrantConflictResponseBody(res *meetingservice.ConflictError) *CreateMeetingRegistrantConflictResponseBody {
	body := &CreateMeetingRegistrantConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "create-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewCreateMeetingRegistrantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *CreateMeetingRegistrantInternalServerErrorResponseBody {
	body := &CreateMeetingRegistrantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantNotFoundResponseBody builds the HTTP response body
// from the result of the "create-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewCreateMeetingRegistrantNotFoundResponseBody(res *meetingservice.NotFoundError) *CreateMeetingRegistrantNotFoundResponseBody {
	body := &CreateMeetingRegistrantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "create-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewCreateMeetingRegistrantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *CreateMeetingRegistrantServiceUnavailableResponseBody {
	body := &CreateMeetingRegistrantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "get-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewGetMeetingRegistrantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingRegistrantInternalServerErrorResponseBody {
	body := &GetMeetingRegistrantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantNotFoundResponseBody builds the HTTP response body
// from the result of the "get-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewGetMeetingRegistrantNotFoundResponseBody(res *meetingservice.NotFoundError) *GetMeetingRegistrantNotFoundResponseBody {
	body := &GetMeetingRegistrantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "get-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewGetMeetingRegistrantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingRegistrantServiceUnavailableResponseBody {
	body := &GetMeetingRegistrantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantBadRequestResponseBody builds the HTTP response
// body from the result of the "update-meeting-registrant" endpoint of the
// "Meeting Service" service.
func NewUpdateMeetingRegistrantBadRequestResponseBody(res *meetingservice.BadRequestError) *UpdateMeetingRegistrantBadRequestResponseBody {
	body := &UpdateMeetingRegistrantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantConflictResponseBody builds the HTTP response body
// from the result of the "update-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingRegistrantConflictResponseBody(res *meetingservice.ConflictError) *UpdateMeetingRegistrantConflictResponseBody {
	body := &UpdateMeetingRegistrantConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "update-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewUpdateMeetingRegistrantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *UpdateMeetingRegistrantInternalServerErrorResponseBody {
	body := &UpdateMeetingRegistrantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantNotFoundResponseBody builds the HTTP response body
// from the result of the "update-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingRegistrantNotFoundResponseBody(res *meetingservice.NotFoundError) *UpdateMeetingRegistrantNotFoundResponseBody {
	body := &UpdateMeetingRegistrantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "update-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewUpdateMeetingRegistrantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *UpdateMeetingRegistrantServiceUnavailableResponseBody {
	body := &UpdateMeetingRegistrantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingRegistrantBadRequestResponseBody builds the HTTP response
// body from the result of the "delete-meeting-registrant" endpoint of the
// "Meeting Service" service.
func NewDeleteMeetingRegistrantBadRequestResponseBody(res *meetingservice.BadRequestError) *DeleteMeetingRegistrantBadRequestResponseBody {
	body := &DeleteMeetingRegistrantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingRegistrantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "delete-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewDeleteMeetingRegistrantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *DeleteMeetingRegistrantInternalServerErrorResponseBody {
	body := &DeleteMeetingRegistrantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingRegistrantNotFoundResponseBody builds the HTTP response body
// from the result of the "delete-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewDeleteMeetingRegistrantNotFoundResponseBody(res *meetingservice.NotFoundError) *DeleteMeetingRegistrantNotFoundResponseBody {
	body := &DeleteMeetingRegistrantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingRegistrantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "delete-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewDeleteMeetingRegistrantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *DeleteMeetingRegistrantServiceUnavailableResponseBody {
	body := &DeleteMeetingRegistrantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewZoomWebhookBadRequestResponseBody builds the HTTP response body from the
// result of the "zoom-webhook" endpoint of the "Meeting Service" service.
func NewZoomWebhookBadRequestResponseBody(res *meetingservice.BadRequestError) *ZoomWebhookBadRequestResponseBody {
	body := &ZoomWebhookBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewZoomWebhookInternalServerErrorResponseBody builds the HTTP response body
// from the result of the "zoom-webhook" endpoint of the "Meeting Service"
// service.
func NewZoomWebhookInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *ZoomWebhookInternalServerErrorResponseBody {
	body := &ZoomWebhookInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewZoomWebhookUnauthorizedResponseBody builds the HTTP response body from
// the result of the "zoom-webhook" endpoint of the "Meeting Service" service.
func NewZoomWebhookUnauthorizedResponseBody(res *meetingservice.UnauthorizedError) *ZoomWebhookUnauthorizedResponseBody {
	body := &ZoomWebhookUnauthorizedResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingsBadRequestResponseBody builds the HTTP response body from
// the result of the "get-past-meetings" endpoint of the "Meeting Service"
// service.
func NewGetPastMeetingsBadRequestResponseBody(res *meetingservice.BadRequestError) *GetPastMeetingsBadRequestResponseBody {
	body := &GetPastMeetingsBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingsInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "get-past-meetings" endpoint of the "Meeting
// Service" service.
func NewGetPastMeetingsInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetPastMeetingsInternalServerErrorResponseBody {
	body := &GetPastMeetingsInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingsServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "get-past-meetings" endpoint of the "Meeting
// Service" service.
func NewGetPastMeetingsServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetPastMeetingsServiceUnavailableResponseBody {
	body := &GetPastMeetingsServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingBadRequestResponseBody builds the HTTP response body
// from the result of the "create-past-meeting" endpoint of the "Meeting
// Service" service.
func NewCreatePastMeetingBadRequestResponseBody(res *meetingservice.BadRequestError) *CreatePastMeetingBadRequestResponseBody {
	body := &CreatePastMeetingBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingConflictResponseBody builds the HTTP response body from
// the result of the "create-past-meeting" endpoint of the "Meeting Service"
// service.
func NewCreatePastMeetingConflictResponseBody(res *meetingservice.ConflictError) *CreatePastMeetingConflictResponseBody {
	body := &CreatePastMeetingConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "create-past-meeting" endpoint of the "Meeting
// Service" service.
func NewCreatePastMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *CreatePastMeetingInternalServerErrorResponseBody {
	body := &CreatePastMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "create-past-meeting" endpoint of the "Meeting
// Service" service.
func NewCreatePastMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *CreatePastMeetingServiceUnavailableResponseBody {
	body := &CreatePastMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "get-past-meeting" endpoint of the "Meeting
// Service" service.
func NewGetPastMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetPastMeetingInternalServerErrorResponseBody {
	body := &GetPastMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingNotFoundResponseBody builds the HTTP response body from the
// result of the "get-past-meeting" endpoint of the "Meeting Service" service.
func NewGetPastMeetingNotFoundResponseBody(res *meetingservice.NotFoundError) *GetPastMeetingNotFoundResponseBody {
	body := &GetPastMeetingNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "get-past-meeting" endpoint of the "Meeting
// Service" service.
func NewGetPastMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetPastMeetingServiceUnavailableResponseBody {
	body := &GetPastMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeletePastMeetingBadRequestResponseBody builds the HTTP response body
// from the result of the "delete-past-meeting" endpoint of the "Meeting
// Service" service.
func NewDeletePastMeetingBadRequestResponseBody(res *meetingservice.BadRequestError) *DeletePastMeetingBadRequestResponseBody {
	body := &DeletePastMeetingBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeletePastMeetingInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "delete-past-meeting" endpoint of the "Meeting
// Service" service.
func NewDeletePastMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *DeletePastMeetingInternalServerErrorResponseBody {
	body := &DeletePastMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeletePastMeetingNotFoundResponseBody builds the HTTP response body from
// the result of the "delete-past-meeting" endpoint of the "Meeting Service"
// service.
func NewDeletePastMeetingNotFoundResponseBody(res *meetingservice.NotFoundError) *DeletePastMeetingNotFoundResponseBody {
	body := &DeletePastMeetingNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeletePastMeetingServiceUnavailableResponseBody builds the HTTP response
// body from the result of the "delete-past-meeting" endpoint of the "Meeting
// Service" service.
func NewDeletePastMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *DeletePastMeetingServiceUnavailableResponseBody {
	body := &DeletePastMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingParticipantsInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "get-past-meeting-participants"
// endpoint of the "Meeting Service" service.
func NewGetPastMeetingParticipantsInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetPastMeetingParticipantsInternalServerErrorResponseBody {
	body := &GetPastMeetingParticipantsInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingParticipantsNotFoundResponseBody builds the HTTP response
// body from the result of the "get-past-meeting-participants" endpoint of the
// "Meeting Service" service.
func NewGetPastMeetingParticipantsNotFoundResponseBody(res *meetingservice.NotFoundError) *GetPastMeetingParticipantsNotFoundResponseBody {
	body := &GetPastMeetingParticipantsNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingParticipantsServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "get-past-meeting-participants"
// endpoint of the "Meeting Service" service.
func NewGetPastMeetingParticipantsServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetPastMeetingParticipantsServiceUnavailableResponseBody {
	body := &GetPastMeetingParticipantsServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingParticipantBadRequestResponseBody builds the HTTP
// response body from the result of the "create-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewCreatePastMeetingParticipantBadRequestResponseBody(res *meetingservice.BadRequestError) *CreatePastMeetingParticipantBadRequestResponseBody {
	body := &CreatePastMeetingParticipantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingParticipantConflictResponseBody builds the HTTP response
// body from the result of the "create-past-meeting-participant" endpoint of
// the "Meeting Service" service.
func NewCreatePastMeetingParticipantConflictResponseBody(res *meetingservice.ConflictError) *CreatePastMeetingParticipantConflictResponseBody {
	body := &CreatePastMeetingParticipantConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingParticipantInternalServerErrorResponseBody builds the
// HTTP response body from the result of the "create-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewCreatePastMeetingParticipantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *CreatePastMeetingParticipantInternalServerErrorResponseBody {
	body := &CreatePastMeetingParticipantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingParticipantNotFoundResponseBody builds the HTTP response
// body from the result of the "create-past-meeting-participant" endpoint of
// the "Meeting Service" service.
func NewCreatePastMeetingParticipantNotFoundResponseBody(res *meetingservice.NotFoundError) *CreatePastMeetingParticipantNotFoundResponseBody {
	body := &CreatePastMeetingParticipantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreatePastMeetingParticipantServiceUnavailableResponseBody builds the
// HTTP response body from the result of the "create-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewCreatePastMeetingParticipantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *CreatePastMeetingParticipantServiceUnavailableResponseBody {
	body := &CreatePastMeetingParticipantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingParticipantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "get-past-meeting-participant" endpoint
// of the "Meeting Service" service.
func NewGetPastMeetingParticipantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetPastMeetingParticipantInternalServerErrorResponseBody {
	body := &GetPastMeetingParticipantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingParticipantNotFoundResponseBody builds the HTTP response
// body from the result of the "get-past-meeting-participant" endpoint of the
// "Meeting Service" service.
func NewGetPastMeetingParticipantNotFoundResponseBody(res *meetingservice.NotFoundError) *GetPastMeetingParticipantNotFoundResponseBody {
	body := &GetPastMeetingParticipantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetPastMeetingParticipantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "get-past-meeting-participant" endpoint
// of the "Meeting Service" service.
func NewGetPastMeetingParticipantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetPastMeetingParticipantServiceUnavailableResponseBody {
	body := &GetPastMeetingParticipantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdatePastMeetingParticipantBadRequestResponseBody builds the HTTP
// response body from the result of the "update-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewUpdatePastMeetingParticipantBadRequestResponseBody(res *meetingservice.BadRequestError) *UpdatePastMeetingParticipantBadRequestResponseBody {
	body := &UpdatePastMeetingParticipantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdatePastMeetingParticipantConflictResponseBody builds the HTTP response
// body from the result of the "update-past-meeting-participant" endpoint of
// the "Meeting Service" service.
func NewUpdatePastMeetingParticipantConflictResponseBody(res *meetingservice.ConflictError) *UpdatePastMeetingParticipantConflictResponseBody {
	body := &UpdatePastMeetingParticipantConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdatePastMeetingParticipantInternalServerErrorResponseBody builds the
// HTTP response body from the result of the "update-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewUpdatePastMeetingParticipantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *UpdatePastMeetingParticipantInternalServerErrorResponseBody {
	body := &UpdatePastMeetingParticipantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdatePastMeetingParticipantNotFoundResponseBody builds the HTTP response
// body from the result of the "update-past-meeting-participant" endpoint of
// the "Meeting Service" service.
func NewUpdatePastMeetingParticipantNotFoundResponseBody(res *meetingservice.NotFoundError) *UpdatePastMeetingParticipantNotFoundResponseBody {
	body := &UpdatePastMeetingParticipantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdatePastMeetingParticipantServiceUnavailableResponseBody builds the
// HTTP response body from the result of the "update-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewUpdatePastMeetingParticipantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *UpdatePastMeetingParticipantServiceUnavailableResponseBody {
	body := &UpdatePastMeetingParticipantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeletePastMeetingParticipantBadRequestResponseBody builds the HTTP
// response body from the result of the "delete-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewDeletePastMeetingParticipantBadRequestResponseBody(res *meetingservice.BadRequestError) *DeletePastMeetingParticipantBadRequestResponseBody {
	body := &DeletePastMeetingParticipantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeletePastMeetingParticipantInternalServerErrorResponseBody builds the
// HTTP response body from the result of the "delete-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewDeletePastMeetingParticipantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *DeletePastMeetingParticipantInternalServerErrorResponseBody {
	body := &DeletePastMeetingParticipantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeletePastMeetingParticipantNotFoundResponseBody builds the HTTP response
// body from the result of the "delete-past-meeting-participant" endpoint of
// the "Meeting Service" service.
func NewDeletePastMeetingParticipantNotFoundResponseBody(res *meetingservice.NotFoundError) *DeletePastMeetingParticipantNotFoundResponseBody {
	body := &DeletePastMeetingParticipantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeletePastMeetingParticipantServiceUnavailableResponseBody builds the
// HTTP response body from the result of the "delete-past-meeting-participant"
// endpoint of the "Meeting Service" service.
func NewDeletePastMeetingParticipantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *DeletePastMeetingParticipantServiceUnavailableResponseBody {
	body := &DeletePastMeetingParticipantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewReadyzServiceUnavailableResponseBody builds the HTTP response body from
// the result of the "readyz" endpoint of the "Meeting Service" service.
func NewReadyzServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *ReadyzServiceUnavailableResponseBody {
	body := &ReadyzServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingsPayload builds a Meeting Service service get-meetings endpoint
// payload.
func NewGetMeetingsPayload(version *string, bearerToken *string) *meetingservice.GetMeetingsPayload {
	v := &meetingservice.GetMeetingsPayload{}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewCreateMeetingPayload builds a Meeting Service service create-meeting
// endpoint payload.
func NewCreateMeetingPayload(body *CreateMeetingRequestBody, version *string, bearerToken *string) *meetingservice.CreateMeetingPayload {
	v := &meetingservice.CreateMeetingPayload{
		ProjectUID:           *body.ProjectUID,
		StartTime:            *body.StartTime,
		Duration:             *body.Duration,
		Timezone:             *body.Timezone,
		Title:                *body.Title,
		Description:          *body.Description,
		Platform:             body.Platform,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		MeetingType:          body.MeetingType,
		Visibility:           body.Visibility,
		Restricted:           body.Restricted,
		ArtifactVisibility:   body.ArtifactVisibility,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
	}
	if body.Recurrence != nil {
		v.Recurrence = unmarshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			v.Committees[i] = unmarshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.Organizers != nil {
		v.Organizers = make([]string, len(body.Organizers))
		for i, val := range body.Organizers {
			v.Organizers[i] = val
		}
	}
	if body.ZoomConfig != nil {
		v.ZoomConfig = unmarshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(body.ZoomConfig)
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetMeetingBasePayload builds a Meeting Service service get-meeting-base
// endpoint payload.
func NewGetMeetingBasePayload(uid string, version *string, bearerToken *string) *meetingservice.GetMeetingBasePayload {
	v := &meetingservice.GetMeetingBasePayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetMeetingSettingsPayload builds a Meeting Service service
// get-meeting-settings endpoint payload.
func NewGetMeetingSettingsPayload(uid string, version *string, bearerToken *string) *meetingservice.GetMeetingSettingsPayload {
	v := &meetingservice.GetMeetingSettingsPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewUpdateMeetingBasePayload builds a Meeting Service service
// update-meeting-base endpoint payload.
func NewUpdateMeetingBasePayload(body *UpdateMeetingBaseRequestBody, uid string, version *string, bearerToken *string, ifMatch *string) *meetingservice.UpdateMeetingBasePayload {
	v := &meetingservice.UpdateMeetingBasePayload{
		ProjectUID:           *body.ProjectUID,
		StartTime:            *body.StartTime,
		Duration:             *body.Duration,
		Timezone:             *body.Timezone,
		Title:                *body.Title,
		Description:          *body.Description,
		Platform:             body.Platform,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		MeetingType:          body.MeetingType,
		Visibility:           body.Visibility,
		Restricted:           body.Restricted,
		ArtifactVisibility:   body.ArtifactVisibility,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
	}
	if body.Recurrence != nil {
		v.Recurrence = unmarshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			v.Committees[i] = unmarshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.ZoomConfig != nil {
		v.ZoomConfig = unmarshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(body.ZoomConfig)
	}
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewUpdateMeetingSettingsPayload builds a Meeting Service service
// update-meeting-settings endpoint payload.
func NewUpdateMeetingSettingsPayload(body *UpdateMeetingSettingsRequestBody, uid string, version *string, bearerToken *string, ifMatch *string) *meetingservice.UpdateMeetingSettingsPayload {
	v := &meetingservice.UpdateMeetingSettingsPayload{}
	if body.Organizers != nil {
		v.Organizers = make([]string, len(body.Organizers))
		for i, val := range body.Organizers {
			v.Organizers[i] = val
		}
	}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewDeleteMeetingPayload builds a Meeting Service service delete-meeting
// endpoint payload.
func NewDeleteMeetingPayload(uid string, version *string, bearerToken *string, ifMatch *string) *meetingservice.DeleteMeetingPayload {
	v := &meetingservice.DeleteMeetingPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewGetMeetingRegistrantsPayload builds a Meeting Service service
// get-meeting-registrants endpoint payload.
func NewGetMeetingRegistrantsPayload(uid string, version *string, bearerToken *string) *meetingservice.GetMeetingRegistrantsPayload {
	v := &meetingservice.GetMeetingRegistrantsPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewCreateMeetingRegistrantPayload builds a Meeting Service service
// create-meeting-registrant endpoint payload.
func NewCreateMeetingRegistrantPayload(body *CreateMeetingRegistrantRequestBody, meetingUID string, version *string, bearerToken *string) *meetingservice.CreateMeetingRegistrantPayload {
	v := &meetingservice.CreateMeetingRegistrantPayload{
		Email:        *body.Email,
		FirstName:    *body.FirstName,
		LastName:     *body.LastName,
		Host:         body.Host,
		JobTitle:     body.JobTitle,
		OrgName:      body.OrgName,
		OccurrenceID: body.OccurrenceID,
		AvatarURL:    body.AvatarURL,
		Username:     body.Username,
	}
	v.MeetingUID = meetingUID
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetMeetingRegistrantPayload builds a Meeting Service service
// get-meeting-registrant endpoint payload.
func NewGetMeetingRegistrantPayload(meetingUID string, uid string, version *string, bearerToken *string) *meetingservice.GetMeetingRegistrantPayload {
	v := &meetingservice.GetMeetingRegistrantPayload{}
	v.MeetingUID = &meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewUpdateMeetingRegistrantPayload builds a Meeting Service service
// update-meeting-registrant endpoint payload.
func NewUpdateMeetingRegistrantPayload(body *UpdateMeetingRegistrantRequestBody, meetingUID string, uid string, version *string, bearerToken *string, ifMatch *string) *meetingservice.UpdateMeetingRegistrantPayload {
	v := &meetingservice.UpdateMeetingRegistrantPayload{
		Email:        *body.Email,
		FirstName:    *body.FirstName,
		LastName:     *body.LastName,
		Host:         body.Host,
		JobTitle:     body.JobTitle,
		OrgName:      body.OrgName,
		OccurrenceID: body.OccurrenceID,
		AvatarURL:    body.AvatarURL,
		Username:     body.Username,
	}
	v.MeetingUID = meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewDeleteMeetingRegistrantPayload builds a Meeting Service service
// delete-meeting-registrant endpoint payload.
func NewDeleteMeetingRegistrantPayload(meetingUID string, uid string, version *string, bearerToken *string, ifMatch *string) *meetingservice.DeleteMeetingRegistrantPayload {
	v := &meetingservice.DeleteMeetingRegistrantPayload{}
	v.MeetingUID = &meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewZoomWebhookPayload builds a Meeting Service service zoom-webhook endpoint
// payload.
func NewZoomWebhookPayload(body *ZoomWebhookRequestBody, zoomSignature *string, zoomTimestamp *string) *meetingservice.ZoomWebhookPayload {
	v := &meetingservice.ZoomWebhookPayload{
		Event:   *body.Event,
		EventTs: *body.EventTs,
		Payload: body.Payload,
	}
	v.ZoomSignature = zoomSignature
	v.ZoomTimestamp = zoomTimestamp

	return v
}

// NewGetPastMeetingsPayload builds a Meeting Service service get-past-meetings
// endpoint payload.
func NewGetPastMeetingsPayload(version *string, bearerToken *string) *meetingservice.GetPastMeetingsPayload {
	v := &meetingservice.GetPastMeetingsPayload{}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewCreatePastMeetingPayload builds a Meeting Service service
// create-past-meeting endpoint payload.
func NewCreatePastMeetingPayload(body *CreatePastMeetingRequestBody, version *string, bearerToken *string) *meetingservice.CreatePastMeetingPayload {
	v := &meetingservice.CreatePastMeetingPayload{
		MeetingUID:           *body.MeetingUID,
		OccurrenceID:         body.OccurrenceID,
		ProjectUID:           *body.ProjectUID,
		ScheduledStartTime:   *body.ScheduledStartTime,
		ScheduledEndTime:     *body.ScheduledEndTime,
		Duration:             *body.Duration,
		Timezone:             *body.Timezone,
		Title:                *body.Title,
		Description:          *body.Description,
		Platform:             *body.Platform,
		PlatformMeetingID:    body.PlatformMeetingID,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		MeetingType:          body.MeetingType,
		Visibility:           body.Visibility,
		Restricted:           body.Restricted,
		ArtifactVisibility:   body.ArtifactVisibility,
		PublicLink:           body.PublicLink,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
	}
	if body.Recurrence != nil {
		v.Recurrence = unmarshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			v.Committees[i] = unmarshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.ZoomConfig != nil {
		v.ZoomConfig = unmarshalZoomConfigFullRequestBodyToMeetingserviceZoomConfigFull(body.ZoomConfig)
	}
	if body.Sessions != nil {
		v.Sessions = make([]*meetingservice.Session, len(body.Sessions))
		for i, val := range body.Sessions {
			v.Sessions[i] = unmarshalSessionRequestBodyToMeetingserviceSession(val)
		}
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetPastMeetingPayload builds a Meeting Service service get-past-meeting
// endpoint payload.
func NewGetPastMeetingPayload(uid string, version *string, bearerToken *string) *meetingservice.GetPastMeetingPayload {
	v := &meetingservice.GetPastMeetingPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewDeletePastMeetingPayload builds a Meeting Service service
// delete-past-meeting endpoint payload.
func NewDeletePastMeetingPayload(uid string, version *string, bearerToken *string, ifMatch *string) *meetingservice.DeletePastMeetingPayload {
	v := &meetingservice.DeletePastMeetingPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewGetPastMeetingParticipantsPayload builds a Meeting Service service
// get-past-meeting-participants endpoint payload.
func NewGetPastMeetingParticipantsPayload(uid string, version *string, bearerToken *string) *meetingservice.GetPastMeetingParticipantsPayload {
	v := &meetingservice.GetPastMeetingParticipantsPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewCreatePastMeetingParticipantPayload builds a Meeting Service service
// create-past-meeting-participant endpoint payload.
func NewCreatePastMeetingParticipantPayload(body *CreatePastMeetingParticipantRequestBody, uid string, version *string, bearerToken *string) *meetingservice.CreatePastMeetingParticipantPayload {
	v := &meetingservice.CreatePastMeetingParticipantPayload{
		PastMeetingUID: *body.PastMeetingUID,
		Email:          *body.Email,
		FirstName:      *body.FirstName,
		LastName:       *body.LastName,
		Host:           body.Host,
		JobTitle:       body.JobTitle,
		OrgName:        body.OrgName,
		AvatarURL:      body.AvatarURL,
		Username:       body.Username,
		IsInvited:      body.IsInvited,
		IsAttended:     body.IsAttended,
	}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetPastMeetingParticipantPayload builds a Meeting Service service
// get-past-meeting-participant endpoint payload.
func NewGetPastMeetingParticipantPayload(pastMeetingUID string, uid string, version *string, bearerToken *string) *meetingservice.GetPastMeetingParticipantPayload {
	v := &meetingservice.GetPastMeetingParticipantPayload{}
	v.PastMeetingUID = &pastMeetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewUpdatePastMeetingParticipantPayload builds a Meeting Service service
// update-past-meeting-participant endpoint payload.
func NewUpdatePastMeetingParticipantPayload(body *UpdatePastMeetingParticipantRequestBody, pastMeetingUID string, uid string, version *string, bearerToken *string, ifMatch *string) *meetingservice.UpdatePastMeetingParticipantPayload {
	v := &meetingservice.UpdatePastMeetingParticipantPayload{
		Email:      *body.Email,
		FirstName:  *body.FirstName,
		LastName:   *body.LastName,
		Host:       body.Host,
		JobTitle:   body.JobTitle,
		OrgName:    body.OrgName,
		AvatarURL:  body.AvatarURL,
		Username:   body.Username,
		IsInvited:  body.IsInvited,
		IsAttended: body.IsAttended,
	}
	v.PastMeetingUID = pastMeetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// NewDeletePastMeetingParticipantPayload builds a Meeting Service service
// delete-past-meeting-participant endpoint payload.
func NewDeletePastMeetingParticipantPayload(pastMeetingUID string, uid string, version *string, bearerToken *string, ifMatch *string) *meetingservice.DeletePastMeetingParticipantPayload {
	v := &meetingservice.DeletePastMeetingParticipantPayload{}
	v.PastMeetingUID = &pastMeetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.IfMatch = ifMatch

	return v
}

// ValidateCreateMeetingRequestBody runs the validations defined on
// Create-MeetingRequestBody
func ValidateCreateMeetingRequestBody(body *CreateMeetingRequestBody) (err error) {
	if body.ProjectUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("project_uid", "body"))
	}
	if body.StartTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("start_time", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	if body.Timezone == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timezone", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.ProjectUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
	}
	if body.StartTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
	}
	if body.Duration != nil {
		if *body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 0, true))
		}
	}
	if body.Duration != nil {
		if *body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 600, false))
		}
	}
	if body.Recurrence != nil {
		if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Committees {
		if e != nil {
			if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.Platform != nil {
		if !(*body.Platform == "Zoom") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes < 10 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes > 60 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
		}
	}
	if body.MeetingType != nil {
		if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
		}
	}
	if body.Visibility != nil {
		if !(*body.Visibility == "public" || *body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
		}
	}
	if body.ArtifactVisibility != nil {
		if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_registrants" || *body.ArtifactVisibility == "public") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_registrants", "public"}))
		}
	}
	return
}

// ValidateUpdateMeetingBaseRequestBody runs the validations defined on
// Update-Meeting-BaseRequestBody
func ValidateUpdateMeetingBaseRequestBody(body *UpdateMeetingBaseRequestBody) (err error) {
	if body.ProjectUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("project_uid", "body"))
	}
	if body.StartTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("start_time", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	if body.Timezone == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timezone", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.ProjectUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
	}
	if body.StartTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
	}
	if body.Duration != nil {
		if *body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 0, true))
		}
	}
	if body.Duration != nil {
		if *body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 600, false))
		}
	}
	if body.Recurrence != nil {
		if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Committees {
		if e != nil {
			if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.Platform != nil {
		if !(*body.Platform == "Zoom") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes < 10 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes > 60 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
		}
	}
	if body.MeetingType != nil {
		if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
		}
	}
	if body.Visibility != nil {
		if !(*body.Visibility == "public" || *body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
		}
	}
	if body.ArtifactVisibility != nil {
		if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_registrants" || *body.ArtifactVisibility == "public") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_registrants", "public"}))
		}
	}
	return
}

// ValidateCreateMeetingRegistrantRequestBody runs the validations defined on
// Create-Meeting-RegistrantRequestBody
func ValidateCreateMeetingRegistrantRequestBody(body *CreateMeetingRegistrantRequestBody) (err error) {
	if body.Email == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("email", "body"))
	}
	if body.FirstName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("first_name", "body"))
	}
	if body.LastName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("last_name", "body"))
	}
	if body.Email != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
		}
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
		}
	}
	if body.OccurrenceID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.occurrence_id", *body.OccurrenceID, "^[0-9]*$"))
	}
	if body.AvatarURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
	}
	return
}

// ValidateUpdateMeetingRegistrantRequestBody runs the validations defined on
// Update-Meeting-RegistrantRequestBody
func ValidateUpdateMeetingRegistrantRequestBody(body *UpdateMeetingRegistrantRequestBody) (err error) {
	if body.Email == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("email", "body"))
	}
	if body.FirstName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("first_name", "body"))
	}
	if body.LastName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("last_name", "body"))
	}
	if body.Email != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
		}
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
		}
	}
	if body.OccurrenceID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.occurrence_id", *body.OccurrenceID, "^[0-9]*$"))
	}
	if body.AvatarURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
	}
	return
}

// ValidateZoomWebhookRequestBody runs the validations defined on
// Zoom-WebhookRequestBody
func ValidateZoomWebhookRequestBody(body *ZoomWebhookRequestBody) (err error) {
	if body.Event == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("event", "body"))
	}
	if body.EventTs == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("event_ts", "body"))
	}
	if body.Payload == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("payload", "body"))
	}
	if body.Event != nil {
		if !(*body.Event == "meeting.started" || *body.Event == "meeting.ended" || *body.Event == "meeting.deleted" || *body.Event == "meeting.participant_joined" || *body.Event == "meeting.participant_left" || *body.Event == "recording.completed" || *body.Event == "recording.transcript_completed" || *body.Event == "meeting.summary_completed") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.event", *body.Event, []any{"meeting.started", "meeting.ended", "meeting.deleted", "meeting.participant_joined", "meeting.participant_left", "recording.completed", "recording.transcript_completed", "meeting.summary_completed"}))
		}
	}
	return
}

// ValidateCreatePastMeetingRequestBody runs the validations defined on
// Create-Past-MeetingRequestBody
func ValidateCreatePastMeetingRequestBody(body *CreatePastMeetingRequestBody) (err error) {
	if body.MeetingUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("meeting_uid", "body"))
	}
	if body.ProjectUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("project_uid", "body"))
	}
	if body.ScheduledStartTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("scheduled_start_time", "body"))
	}
	if body.ScheduledEndTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("scheduled_end_time", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	if body.Timezone == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timezone", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.Platform == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("platform", "body"))
	}
	if body.MeetingUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.meeting_uid", *body.MeetingUID, goa.FormatUUID))
	}
	if body.ProjectUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
	}
	if body.ScheduledStartTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.scheduled_start_time", *body.ScheduledStartTime, goa.FormatDateTime))
	}
	if body.ScheduledEndTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.scheduled_end_time", *body.ScheduledEndTime, goa.FormatDateTime))
	}
	if body.Duration != nil {
		if *body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 0, true))
		}
	}
	if body.Duration != nil {
		if *body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 600, false))
		}
	}
	if body.Recurrence != nil {
		if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Committees {
		if e != nil {
			if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.Platform != nil {
		if !(*body.Platform == "Zoom") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes < 10 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes > 60 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
		}
	}
	if body.MeetingType != nil {
		if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
		}
	}
	if body.Visibility != nil {
		if !(*body.Visibility == "public" || *body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
		}
	}
	if body.ArtifactVisibility != nil {
		if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_registrants" || *body.ArtifactVisibility == "public") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_registrants", "public"}))
		}
	}
	if body.PublicLink != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.public_link", *body.PublicLink, goa.FormatURI))
	}
	if body.ZoomConfig != nil {
		if err2 := ValidateZoomConfigFullRequestBody(body.ZoomConfig); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Sessions {
		if e != nil {
			if err2 := ValidateSessionRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateCreatePastMeetingParticipantRequestBody runs the validations defined
// on Create-Past-Meeting-ParticipantRequestBody
func ValidateCreatePastMeetingParticipantRequestBody(body *CreatePastMeetingParticipantRequestBody) (err error) {
	if body.PastMeetingUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("past_meeting_uid", "body"))
	}
	if body.Email == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("email", "body"))
	}
	if body.FirstName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("first_name", "body"))
	}
	if body.LastName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("last_name", "body"))
	}
	if body.PastMeetingUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.past_meeting_uid", *body.PastMeetingUID, goa.FormatUUID))
	}
	if body.Email != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
		}
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
		}
	}
	if body.AvatarURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
	}
	return
}

// ValidateUpdatePastMeetingParticipantRequestBody runs the validations defined
// on Update-Past-Meeting-ParticipantRequestBody
func ValidateUpdatePastMeetingParticipantRequestBody(body *UpdatePastMeetingParticipantRequestBody) (err error) {
	if body.Email == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("email", "body"))
	}
	if body.FirstName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("first_name", "body"))
	}
	if body.LastName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("last_name", "body"))
	}
	if body.Email != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
		}
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
		}
	}
	if body.AvatarURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
	}
	return
}

// ValidateRecurrenceRequestBody runs the validations defined on
// RecurrenceRequestBody
func ValidateRecurrenceRequestBody(body *RecurrenceRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.RepeatInterval == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repeat_interval", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == 1 || *body.Type == 2 || *body.Type == 3) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{1, 2, 3}))
		}
	}
	if body.WeeklyDays != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.weekly_days", *body.WeeklyDays, "^[1-7](,[1-7])*$"))
	}
	if body.MonthlyDay != nil {
		if *body.MonthlyDay < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.monthly_day", *body.MonthlyDay, 1, true))
		}
	}
	if body.MonthlyDay != nil {
		if *body.MonthlyDay > 31 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.monthly_day", *body.MonthlyDay, 31, false))
		}
	}
	if body.MonthlyWeek != nil {
		if !(*body.MonthlyWeek == -1 || *body.MonthlyWeek == 1 || *body.MonthlyWeek == 2 || *body.MonthlyWeek == 3 || *body.MonthlyWeek == 4) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.monthly_week", *body.MonthlyWeek, []any{-1, 1, 2, 3, 4}))
		}
	}
	if body.MonthlyWeekDay != nil {
		if !(*body.MonthlyWeekDay == 1 || *body.MonthlyWeekDay == 2 || *body.MonthlyWeekDay == 3 || *body.MonthlyWeekDay == 4 || *body.MonthlyWeekDay == 5 || *body.MonthlyWeekDay == 6 || *body.MonthlyWeekDay == 7) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.monthly_week_day", *body.MonthlyWeekDay, []any{1, 2, 3, 4, 5, 6, 7}))
		}
	}
	if body.EndDateTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.end_date_time", *body.EndDateTime, goa.FormatDateTime))
	}
	return
}

// ValidateCommitteeRequestBody runs the validations defined on
// CommitteeRequestBody
func ValidateCommitteeRequestBody(body *CommitteeRequestBody) (err error) {
	if body.UID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("uid", "body"))
	}
	if body.AllowedVotingStatuses == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("allowed_voting_statuses", "body"))
	}
	return
}

// ValidateZoomConfigFullRequestBody runs the validations defined on
// ZoomConfigFullRequestBody
func ValidateZoomConfigFullRequestBody(body *ZoomConfigFullRequestBody) (err error) {
	if body.MeetingID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.meeting_id", *body.MeetingID, "^\\d{9,11}$"))
	}
	if body.MeetingID != nil {
		if utf8.RuneCountInString(*body.MeetingID) < 9 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.meeting_id", *body.MeetingID, utf8.RuneCountInString(*body.MeetingID), 9, true))
		}
	}
	if body.MeetingID != nil {
		if utf8.RuneCountInString(*body.MeetingID) > 11 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.meeting_id", *body.MeetingID, utf8.RuneCountInString(*body.MeetingID), 11, false))
		}
	}
	if body.Passcode != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.passcode", *body.Passcode, "^\\d{6,10}$"))
	}
	if body.Passcode != nil {
		if utf8.RuneCountInString(*body.Passcode) < 6 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.passcode", *body.Passcode, utf8.RuneCountInString(*body.Passcode), 6, true))
		}
	}
	if body.Passcode != nil {
		if utf8.RuneCountInString(*body.Passcode) > 10 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.passcode", *body.Passcode, utf8.RuneCountInString(*body.Passcode), 10, false))
		}
	}
	return
}

// ValidateSessionRequestBody runs the validations defined on SessionRequestBody
func ValidateSessionRequestBody(body *SessionRequestBody) (err error) {
	if body.UID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("uid", "body"))
	}
	if body.StartTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("start_time", "body"))
	}
	if body.UID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.uid", *body.UID, goa.FormatUUID))
	}
	if body.StartTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
	}
	if body.EndTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.end_time", *body.EndTime, goa.FormatDateTime))
	}
	return
}
