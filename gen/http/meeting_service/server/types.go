// Code generated by goa v3.21.1, DO NOT EDIT.
//
// Meeting Service HTTP server types
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package server

import (
	"unicode/utf8"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goa "goa.design/goa/v3/pkg"
)

// CreateMeetingRequestBody is the type of the "Meeting Service" service
// "create-meeting" endpoint HTTP request body.
type CreateMeetingRequestBody struct {
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceRequestBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeRequestBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigPostRequestBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
}

// UpdateMeetingRequestBody is the type of the "Meeting Service" service
// "update-meeting" endpoint HTTP request body.
type UpdateMeetingRequestBody struct {
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceRequestBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeRequestBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigPostRequestBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
}

// CreateMeetingRegistrantRequestBody is the type of the "Meeting Service"
// service "create-meeting-registrant" endpoint HTTP request body.
type CreateMeetingRegistrantRequestBody struct {
	// The UID of the meeting
	MeetingUID *string `form:"meeting_uid,omitempty" json:"meeting_uid,omitempty" xml:"meeting_uid,omitempty"`
	// User's email address
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// User's first name
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" xml:"first_name,omitempty"`
	// User's last name
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty" xml:"last_name,omitempty"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	UserID *string `form:"user_id,omitempty" json:"user_id,omitempty" xml:"user_id,omitempty"`
}

// UpdateMeetingRegistrantRequestBody is the type of the "Meeting Service"
// service "update-meeting-registrant" endpoint HTTP request body.
type UpdateMeetingRegistrantRequestBody struct {
	// User's email address
	Email *string `form:"email,omitempty" json:"email,omitempty" xml:"email,omitempty"`
	// User's first name
	FirstName *string `form:"first_name,omitempty" json:"first_name,omitempty" xml:"first_name,omitempty"`
	// User's last name
	LastName *string `form:"last_name,omitempty" json:"last_name,omitempty" xml:"last_name,omitempty"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	UserID *string `form:"user_id,omitempty" json:"user_id,omitempty" xml:"user_id,omitempty"`
}

// GetMeetingsResponseBody is the type of the "Meeting Service" service
// "get-meetings" endpoint HTTP response body.
type GetMeetingsResponseBody struct {
	// Resources found
	Meetings []*MeetingResponseBody `form:"meetings" json:"meetings" xml:"meetings"`
}

// CreateMeetingResponseBody is the type of the "Meeting Service" service
// "create-meeting" endpoint HTTP response body.
type CreateMeetingResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// The number of registrants that have an email delivery error with their
	// invite. The delivery errors are counted as the last invite that was sent to
	// the registrant, so if a registrant previously had a delivery error but not
	// in their most recent invite received, then it does not count towards this
	// field value.
	EmailDeliveryErrorCount *int `form:"email_delivery_error_count,omitempty" json:"email_delivery_error_count,omitempty" xml:"email_delivery_error_count,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// The number of registrants for the meeting
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// The number of registrants that have declined the meeting invitation
	RegistrantResponseDeclinedCount *int `form:"registrant_response_declined_count,omitempty" json:"registrant_response_declined_count,omitempty" xml:"registrant_response_declined_count,omitempty"`
	// The number of registrants that have accepted the meeting invitation
	RegistrantResponseAcceptedCount *int `form:"registrant_response_accepted_count,omitempty" json:"registrant_response_accepted_count,omitempty" xml:"registrant_response_accepted_count,omitempty"`
	// Array of meeting occurrences (read-only from platform API)
	Occurrences []*OccurrenceResponseBody `form:"occurrences,omitempty" json:"occurrences,omitempty" xml:"occurrences,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetMeetingResponseBody is the type of the "Meeting Service" service
// "get-meeting" endpoint HTTP response body.
type GetMeetingResponseBody MeetingResponseBody

// UpdateMeetingResponseBody is the type of the "Meeting Service" service
// "update-meeting" endpoint HTTP response body.
type UpdateMeetingResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// The number of registrants that have an email delivery error with their
	// invite. The delivery errors are counted as the last invite that was sent to
	// the registrant, so if a registrant previously had a delivery error but not
	// in their most recent invite received, then it does not count towards this
	// field value.
	EmailDeliveryErrorCount *int `form:"email_delivery_error_count,omitempty" json:"email_delivery_error_count,omitempty" xml:"email_delivery_error_count,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// The number of registrants for the meeting
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// The number of registrants that have declined the meeting invitation
	RegistrantResponseDeclinedCount *int `form:"registrant_response_declined_count,omitempty" json:"registrant_response_declined_count,omitempty" xml:"registrant_response_declined_count,omitempty"`
	// The number of registrants that have accepted the meeting invitation
	RegistrantResponseAcceptedCount *int `form:"registrant_response_accepted_count,omitempty" json:"registrant_response_accepted_count,omitempty" xml:"registrant_response_accepted_count,omitempty"`
	// Array of meeting occurrences (read-only from platform API)
	Occurrences []*OccurrenceResponseBody `form:"occurrences,omitempty" json:"occurrences,omitempty" xml:"occurrences,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetMeetingRegistrantsResponseBody is the type of the "Meeting Service"
// service "get-meeting-registrants" endpoint HTTP response body.
type GetMeetingRegistrantsResponseBody struct {
	// Meeting registrants
	Registrants []*RegistrantResponseBody `form:"registrants" json:"registrants" xml:"registrants"`
}

// CreateMeetingRegistrantResponseBody is the type of the "Meeting Service"
// service "create-meeting-registrant" endpoint HTTP response body.
type CreateMeetingRegistrantResponseBody struct {
	// The UID of the registrant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	UserID *string `form:"user_id,omitempty" json:"user_id,omitempty" xml:"user_id,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetMeetingRegistrantResponseBody is the type of the "Meeting Service"
// service "get-meeting-registrant" endpoint HTTP response body.
type GetMeetingRegistrantResponseBody RegistrantResponseBody

// UpdateMeetingRegistrantResponseBody is the type of the "Meeting Service"
// service "update-meeting-registrant" endpoint HTTP response body.
type UpdateMeetingRegistrantResponseBody struct {
	// The UID of the registrant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	UserID *string `form:"user_id,omitempty" json:"user_id,omitempty" xml:"user_id,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// GetMeetingsBadRequestResponseBody is the type of the "Meeting Service"
// service "get-meetings" endpoint HTTP response body for the "BadRequest"
// error.
type GetMeetingsBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingsInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "get-meetings" endpoint HTTP response body for the
// "InternalServerError" error.
type GetMeetingsInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingsServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "get-meetings" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type GetMeetingsServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingBadRequestResponseBody is the type of the "Meeting Service"
// service "create-meeting" endpoint HTTP response body for the "BadRequest"
// error.
type CreateMeetingBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingConflictResponseBody is the type of the "Meeting Service"
// service "create-meeting" endpoint HTTP response body for the "Conflict"
// error.
type CreateMeetingConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "create-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type CreateMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "create-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type CreateMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "get-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type GetMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingNotFoundResponseBody is the type of the "Meeting Service" service
// "get-meeting" endpoint HTTP response body for the "NotFound" error.
type GetMeetingNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "get-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type GetMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingBadRequestResponseBody is the type of the "Meeting Service"
// service "update-meeting" endpoint HTTP response body for the "BadRequest"
// error.
type UpdateMeetingBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingConflictResponseBody is the type of the "Meeting Service"
// service "update-meeting" endpoint HTTP response body for the "Conflict"
// error.
type UpdateMeetingConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "update-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type UpdateMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingNotFoundResponseBody is the type of the "Meeting Service"
// service "update-meeting" endpoint HTTP response body for the "NotFound"
// error.
type UpdateMeetingNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "update-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type UpdateMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingBadRequestResponseBody is the type of the "Meeting Service"
// service "delete-meeting" endpoint HTTP response body for the "BadRequest"
// error.
type DeleteMeetingBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingInternalServerErrorResponseBody is the type of the "Meeting
// Service" service "delete-meeting" endpoint HTTP response body for the
// "InternalServerError" error.
type DeleteMeetingInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingNotFoundResponseBody is the type of the "Meeting Service"
// service "delete-meeting" endpoint HTTP response body for the "NotFound"
// error.
type DeleteMeetingNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingServiceUnavailableResponseBody is the type of the "Meeting
// Service" service "delete-meeting" endpoint HTTP response body for the
// "ServiceUnavailable" error.
type DeleteMeetingServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantsInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "get-meeting-registrants" endpoint HTTP response
// body for the "InternalServerError" error.
type GetMeetingRegistrantsInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantsNotFoundResponseBody is the type of the "Meeting
// Service" service "get-meeting-registrants" endpoint HTTP response body for
// the "NotFound" error.
type GetMeetingRegistrantsNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantsServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "get-meeting-registrants" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type GetMeetingRegistrantsServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantBadRequestResponseBody is the type of the "Meeting
// Service" service "create-meeting-registrant" endpoint HTTP response body for
// the "BadRequest" error.
type CreateMeetingRegistrantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantConflictResponseBody is the type of the "Meeting
// Service" service "create-meeting-registrant" endpoint HTTP response body for
// the "Conflict" error.
type CreateMeetingRegistrantConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "create-meeting-registrant" endpoint HTTP response
// body for the "InternalServerError" error.
type CreateMeetingRegistrantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantNotFoundResponseBody is the type of the "Meeting
// Service" service "create-meeting-registrant" endpoint HTTP response body for
// the "NotFound" error.
type CreateMeetingRegistrantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// CreateMeetingRegistrantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "create-meeting-registrant" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type CreateMeetingRegistrantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "get-meeting-registrant" endpoint HTTP response
// body for the "InternalServerError" error.
type GetMeetingRegistrantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantNotFoundResponseBody is the type of the "Meeting
// Service" service "get-meeting-registrant" endpoint HTTP response body for
// the "NotFound" error.
type GetMeetingRegistrantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// GetMeetingRegistrantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "get-meeting-registrant" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type GetMeetingRegistrantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantBadRequestResponseBody is the type of the "Meeting
// Service" service "update-meeting-registrant" endpoint HTTP response body for
// the "BadRequest" error.
type UpdateMeetingRegistrantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantConflictResponseBody is the type of the "Meeting
// Service" service "update-meeting-registrant" endpoint HTTP response body for
// the "Conflict" error.
type UpdateMeetingRegistrantConflictResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "update-meeting-registrant" endpoint HTTP response
// body for the "InternalServerError" error.
type UpdateMeetingRegistrantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantNotFoundResponseBody is the type of the "Meeting
// Service" service "update-meeting-registrant" endpoint HTTP response body for
// the "NotFound" error.
type UpdateMeetingRegistrantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// UpdateMeetingRegistrantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "update-meeting-registrant" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type UpdateMeetingRegistrantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingRegistrantBadRequestResponseBody is the type of the "Meeting
// Service" service "delete-meeting-registrant" endpoint HTTP response body for
// the "BadRequest" error.
type DeleteMeetingRegistrantBadRequestResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingRegistrantInternalServerErrorResponseBody is the type of the
// "Meeting Service" service "delete-meeting-registrant" endpoint HTTP response
// body for the "InternalServerError" error.
type DeleteMeetingRegistrantInternalServerErrorResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingRegistrantNotFoundResponseBody is the type of the "Meeting
// Service" service "delete-meeting-registrant" endpoint HTTP response body for
// the "NotFound" error.
type DeleteMeetingRegistrantNotFoundResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// DeleteMeetingRegistrantServiceUnavailableResponseBody is the type of the
// "Meeting Service" service "delete-meeting-registrant" endpoint HTTP response
// body for the "ServiceUnavailable" error.
type DeleteMeetingRegistrantServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// ReadyzServiceUnavailableResponseBody is the type of the "Meeting Service"
// service "readyz" endpoint HTTP response body for the "ServiceUnavailable"
// error.
type ReadyzServiceUnavailableResponseBody struct {
	// HTTP status code
	Code string `form:"code" json:"code" xml:"code"`
	// Error message
	Message string `form:"message" json:"message" xml:"message"`
}

// MeetingResponseBody is used to define fields on response body types.
type MeetingResponseBody struct {
	// The UID of the meeting
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The UID of the LF project
	ProjectUID *string `form:"project_uid,omitempty" json:"project_uid,omitempty" xml:"project_uid,omitempty"`
	// The start time of the meeting in RFC3339 format
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// The duration of the meeting in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The timezone of the meeting (e.g. 'America/New_York')
	Timezone *string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// The recurrence of the meeting
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// The title of the meeting
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// The description of the meeting
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// The committees associated with the meeting
	Committees []*CommitteeResponseBody `form:"committees,omitempty" json:"committees,omitempty" xml:"committees,omitempty"`
	// The platform name of where the meeting is hosted
	Platform *string `form:"platform,omitempty" json:"platform,omitempty" xml:"platform,omitempty"`
	// The number of minutes that users are allowed to join the meeting early
	// without being kicked out
	EarlyJoinTimeMinutes *int `form:"early_join_time_minutes,omitempty" json:"early_join_time_minutes,omitempty" xml:"early_join_time_minutes,omitempty"`
	// The type of meeting. This is usually dependent on the committee(s)
	// associated with the meeting
	MeetingType *string `form:"meeting_type,omitempty" json:"meeting_type,omitempty" xml:"meeting_type,omitempty"`
	// The visibility of the meeting's existence to other users
	Visibility *string `form:"visibility,omitempty" json:"visibility,omitempty" xml:"visibility,omitempty"`
	// The restrictedness of joining the meeting (i.e. is the meeting restricted to
	// only invited users or anyone?)
	Restricted *bool `form:"restricted,omitempty" json:"restricted,omitempty" xml:"restricted,omitempty"`
	// The visibility of artifacts to users (e.g. public, only for registrants,
	// only for hosts)
	ArtifactVisibility *string `form:"artifact_visibility,omitempty" json:"artifact_visibility,omitempty" xml:"artifact_visibility,omitempty"`
	// The public join URL for participants to join the meeting via the LFX
	// platform (e.g.
	// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
	PublicLink *string `form:"public_link,omitempty" json:"public_link,omitempty" xml:"public_link,omitempty"`
	// The number of registrants that have an email delivery error with their
	// invite. The delivery errors are counted as the last invite that was sent to
	// the registrant, so if a registrant previously had a delivery error but not
	// in their most recent invite received, then it does not count towards this
	// field value.
	EmailDeliveryErrorCount *int `form:"email_delivery_error_count,omitempty" json:"email_delivery_error_count,omitempty" xml:"email_delivery_error_count,omitempty"`
	// Whether recording is enabled for the meeting
	RecordingEnabled *bool `form:"recording_enabled,omitempty" json:"recording_enabled,omitempty" xml:"recording_enabled,omitempty"`
	// Whether transcription is enabled for the meeting
	TranscriptEnabled *bool `form:"transcript_enabled,omitempty" json:"transcript_enabled,omitempty" xml:"transcript_enabled,omitempty"`
	// Whether automatic youtube uploading is enabled for the meeting
	YoutubeUploadEnabled *bool `form:"youtube_upload_enabled,omitempty" json:"youtube_upload_enabled,omitempty" xml:"youtube_upload_enabled,omitempty"`
	// For zoom platform meetings: the configuration for the meeting
	ZoomConfig *ZoomConfigFullResponseBody `form:"zoom_config,omitempty" json:"zoom_config,omitempty" xml:"zoom_config,omitempty"`
	// The number of registrants for the meeting
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// The number of registrants that have declined the meeting invitation
	RegistrantResponseDeclinedCount *int `form:"registrant_response_declined_count,omitempty" json:"registrant_response_declined_count,omitempty" xml:"registrant_response_declined_count,omitempty"`
	// The number of registrants that have accepted the meeting invitation
	RegistrantResponseAcceptedCount *int `form:"registrant_response_accepted_count,omitempty" json:"registrant_response_accepted_count,omitempty" xml:"registrant_response_accepted_count,omitempty"`
	// Array of meeting occurrences (read-only from platform API)
	Occurrences []*OccurrenceResponseBody `form:"occurrences,omitempty" json:"occurrences,omitempty" xml:"occurrences,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// RecurrenceResponseBody is used to define fields on response body types.
type RecurrenceResponseBody struct {
	// The recurrence type
	Type int `form:"type" json:"type" xml:"type"`
	// Define the interval at which the meeting should recur.
	// For instance, if you would like to schedule a meeting that recurs every two
	// months,
	// you must set the value of this field as '2' and the value of the 'type'
	// parameter as '3'.
	// For a daily meeting, the maximum interval you can set is '90' days.
	// For a weekly meeting the maximum interval that you can set is of '12' weeks.
	// For a monthly meeting, there is a maximum of '3' months.
	RepeatInterval int `form:"repeat_interval" json:"repeat_interval" xml:"repeat_interval"`
	// This field is required if you're scheduling a recurring meeting of type '2'
	// to state which day(s)
	// of the week the meeting should repeat. The value for this field could be a
	// number between '1' to '7' in string format.
	// For instance, if the meeting should recur on Sunday, provide '1' as the
	// value of this field.
	// If you would like the meeting to occur on multiple days of a week, you
	// should provide comma separated values for this field.
	// For instance, if the meeting should recur on Sundays and Tuesdays provide
	// '1,3' as the value of this field.
	// 1 - Sunday
	// 2 - Monday
	// 3 - Tuesday
	// 4 - Wednesday
	// 5 - Thursday
	// 6 - Friday
	// 7 - Saturday
	WeeklyDays *string `form:"weekly_days,omitempty" json:"weekly_days,omitempty" xml:"weekly_days,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state which day in a month, the meeting should recur. The value range is
	// from 1 to 31. For instance, if you would like the meeting to recur on 23rd
	// of each month, provide '23' as the value of this field and '1' as the value
	// of the 'repeat_interval' field. Instead, if you would like the meeting to
	// recur every three months, on 23rd of the month, change the value of the
	// 'repeat_interval' field to '3'.
	MonthlyDay *int `form:"monthly_day,omitempty" json:"monthly_day,omitempty" xml:"monthly_day,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state the week of the month when the meeting should recur. If you use this
	// field, you must also use the 'monthly_week_day' field to state the day of
	// the week when the meeting should recur. '-1' - Last week of the month. 1 -
	// First week of the month. 2 - Second week of the month. 3 - Third week of the
	// month. 4 - Fourth week of the month.
	MonthlyWeek *int `form:"monthly_week,omitempty" json:"monthly_week,omitempty" xml:"monthly_week,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state a specific day in a week when the monthly meeting should recur. To use
	// this field, you must also use the 'monthly_week' field. 1 - Sunday 2 -
	// Monday 3 - Tuesday 4 - Wednesday 5 - Thursday 6 - Friday 7 - Saturday
	MonthlyWeekDay *int `form:"monthly_week_day,omitempty" json:"monthly_week_day,omitempty" xml:"monthly_week_day,omitempty"`
	// Select how many times the meeting should recur before it is canceled. Cannot
	// be used with 'end_date_time'.
	EndTimes *int `form:"end_times,omitempty" json:"end_times,omitempty" xml:"end_times,omitempty"`
	// Select the final date on which the meeting will recur before it is canceled.
	// Cannot be used with 'end_times'. should be in GMT. should be in
	// 'yyyy-MM-ddTHH:mm:ssZ' format.
	EndDateTime *string `form:"end_date_time,omitempty" json:"end_date_time,omitempty" xml:"end_date_time,omitempty"`
}

// CommitteeResponseBody is used to define fields on response body types.
type CommitteeResponseBody struct {
	// The UID of the committee
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The committee voting statuses required for committee members to be added to
	// the meeting
	AllowedVotingStatuses []string `form:"allowed_voting_statuses" json:"allowed_voting_statuses" xml:"allowed_voting_statuses"`
}

// ZoomConfigFullResponseBody is used to define fields on response body types.
type ZoomConfigFullResponseBody struct {
	// The ID of the created meeting in Zoom
	MeetingID *string `form:"meeting_id,omitempty" json:"meeting_id,omitempty" xml:"meeting_id,omitempty"`
	// For zoom platform meetings: whether Zoom AI companion is enabled
	AiCompanionEnabled *bool `form:"ai_companion_enabled,omitempty" json:"ai_companion_enabled,omitempty" xml:"ai_companion_enabled,omitempty"`
	// For zoom platform meetings: whether AI summary approval is required
	AiSummaryRequireApproval *bool `form:"ai_summary_require_approval,omitempty" json:"ai_summary_require_approval,omitempty" xml:"ai_summary_require_approval,omitempty"`
}

// OccurrenceResponseBody is used to define fields on response body types.
type OccurrenceResponseBody struct {
	// ID of the occurrence, also the start time in unix time
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// GMT start time of occurrence
	StartTime *string `form:"start_time,omitempty" json:"start_time,omitempty" xml:"start_time,omitempty"`
	// Meeting title for this occurrence
	Title *string `form:"title,omitempty" json:"title,omitempty" xml:"title,omitempty"`
	// Meeting description for this occurrence
	Description *string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Occurrence duration in minutes
	Duration *int `form:"duration,omitempty" json:"duration,omitempty" xml:"duration,omitempty"`
	// The recurrence pattern for this occurrence onwards if there is one
	Recurrence *RecurrenceResponseBody `form:"recurrence,omitempty" json:"recurrence,omitempty" xml:"recurrence,omitempty"`
	// Number of registrants for this meeting occurrence
	RegistrantCount *int `form:"registrant_count,omitempty" json:"registrant_count,omitempty" xml:"registrant_count,omitempty"`
	// Number of registrants who declined the invite for this occurrence
	ResponseCountNo *int `form:"response_count_no,omitempty" json:"response_count_no,omitempty" xml:"response_count_no,omitempty"`
	// Number of registrants who accepted the invite for this occurrence
	ResponseCountYes *int `form:"response_count_yes,omitempty" json:"response_count_yes,omitempty" xml:"response_count_yes,omitempty"`
	// Occurrence status from platform
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
}

// RegistrantResponseBody is used to define fields on response body types.
type RegistrantResponseBody struct {
	// The UID of the registrant
	UID string `form:"uid" json:"uid" xml:"uid"`
	// The UID of the meeting
	MeetingUID string `form:"meeting_uid" json:"meeting_uid" xml:"meeting_uid"`
	// User's email address
	Email string `form:"email" json:"email" xml:"email"`
	// User's first name
	FirstName string `form:"first_name" json:"first_name" xml:"first_name"`
	// User's last name
	LastName string `form:"last_name" json:"last_name" xml:"last_name"`
	// If user should have access as a meeting host
	Host *bool `form:"host,omitempty" json:"host,omitempty" xml:"host,omitempty"`
	// User's job title
	JobTitle *string `form:"job_title,omitempty" json:"job_title,omitempty" xml:"job_title,omitempty"`
	// The ID of the specific occurrence the user should be invited to. If blank,
	// user is invited to all occurrences
	OccurrenceID *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty" xml:"occurrence_id,omitempty"`
	// User's organization
	OrgName *string `form:"org_name,omitempty" json:"org_name,omitempty" xml:"org_name,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// LF. If unknown, don't pass this field; the API will find the value by default
	OrgIsMember *bool `form:"org_is_member,omitempty" json:"org_is_member,omitempty" xml:"org_is_member,omitempty"`
	// Whether the registrant is in an organization that has a membership with the
	// project (of the meeting). If unknown, don't pass this field; the API will
	// find the value by default
	OrgIsProjectMember *bool `form:"org_is_project_member,omitempty" json:"org_is_project_member,omitempty" xml:"org_is_project_member,omitempty"`
	// User's avatar URL
	AvatarURL *string `form:"avatar_url,omitempty" json:"avatar_url,omitempty" xml:"avatar_url,omitempty"`
	// User's LF ID
	UserID *string `form:"user_id,omitempty" json:"user_id,omitempty" xml:"user_id,omitempty"`
	// The date and time the resource was created
	CreatedAt *string `form:"created_at,omitempty" json:"created_at,omitempty" xml:"created_at,omitempty"`
	// The date and time the resource was last updated
	UpdatedAt *string `form:"updated_at,omitempty" json:"updated_at,omitempty" xml:"updated_at,omitempty"`
}

// RecurrenceRequestBody is used to define fields on request body types.
type RecurrenceRequestBody struct {
	// The recurrence type
	Type *int `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Define the interval at which the meeting should recur.
	// For instance, if you would like to schedule a meeting that recurs every two
	// months,
	// you must set the value of this field as '2' and the value of the 'type'
	// parameter as '3'.
	// For a daily meeting, the maximum interval you can set is '90' days.
	// For a weekly meeting the maximum interval that you can set is of '12' weeks.
	// For a monthly meeting, there is a maximum of '3' months.
	RepeatInterval *int `form:"repeat_interval,omitempty" json:"repeat_interval,omitempty" xml:"repeat_interval,omitempty"`
	// This field is required if you're scheduling a recurring meeting of type '2'
	// to state which day(s)
	// of the week the meeting should repeat. The value for this field could be a
	// number between '1' to '7' in string format.
	// For instance, if the meeting should recur on Sunday, provide '1' as the
	// value of this field.
	// If you would like the meeting to occur on multiple days of a week, you
	// should provide comma separated values for this field.
	// For instance, if the meeting should recur on Sundays and Tuesdays provide
	// '1,3' as the value of this field.
	// 1 - Sunday
	// 2 - Monday
	// 3 - Tuesday
	// 4 - Wednesday
	// 5 - Thursday
	// 6 - Friday
	// 7 - Saturday
	WeeklyDays *string `form:"weekly_days,omitempty" json:"weekly_days,omitempty" xml:"weekly_days,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state which day in a month, the meeting should recur. The value range is
	// from 1 to 31. For instance, if you would like the meeting to recur on 23rd
	// of each month, provide '23' as the value of this field and '1' as the value
	// of the 'repeat_interval' field. Instead, if you would like the meeting to
	// recur every three months, on 23rd of the month, change the value of the
	// 'repeat_interval' field to '3'.
	MonthlyDay *int `form:"monthly_day,omitempty" json:"monthly_day,omitempty" xml:"monthly_day,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state the week of the month when the meeting should recur. If you use this
	// field, you must also use the 'monthly_week_day' field to state the day of
	// the week when the meeting should recur. '-1' - Last week of the month. 1 -
	// First week of the month. 2 - Second week of the month. 3 - Third week of the
	// month. 4 - Fourth week of the month.
	MonthlyWeek *int `form:"monthly_week,omitempty" json:"monthly_week,omitempty" xml:"monthly_week,omitempty"`
	// Use this field only if you're scheduling a recurring meeting of type '3' to
	// state a specific day in a week when the monthly meeting should recur. To use
	// this field, you must also use the 'monthly_week' field. 1 - Sunday 2 -
	// Monday 3 - Tuesday 4 - Wednesday 5 - Thursday 6 - Friday 7 - Saturday
	MonthlyWeekDay *int `form:"monthly_week_day,omitempty" json:"monthly_week_day,omitempty" xml:"monthly_week_day,omitempty"`
	// Select how many times the meeting should recur before it is canceled. Cannot
	// be used with 'end_date_time'.
	EndTimes *int `form:"end_times,omitempty" json:"end_times,omitempty" xml:"end_times,omitempty"`
	// Select the final date on which the meeting will recur before it is canceled.
	// Cannot be used with 'end_times'. should be in GMT. should be in
	// 'yyyy-MM-ddTHH:mm:ssZ' format.
	EndDateTime *string `form:"end_date_time,omitempty" json:"end_date_time,omitempty" xml:"end_date_time,omitempty"`
}

// CommitteeRequestBody is used to define fields on request body types.
type CommitteeRequestBody struct {
	// The UID of the committee
	UID *string `form:"uid,omitempty" json:"uid,omitempty" xml:"uid,omitempty"`
	// The committee voting statuses required for committee members to be added to
	// the meeting
	AllowedVotingStatuses []string `form:"allowed_voting_statuses,omitempty" json:"allowed_voting_statuses,omitempty" xml:"allowed_voting_statuses,omitempty"`
}

// ZoomConfigPostRequestBody is used to define fields on request body types.
type ZoomConfigPostRequestBody struct {
	// For zoom platform meetings: whether Zoom AI companion is enabled
	AiCompanionEnabled *bool `form:"ai_companion_enabled,omitempty" json:"ai_companion_enabled,omitempty" xml:"ai_companion_enabled,omitempty"`
	// For zoom platform meetings: whether AI summary approval is required
	AiSummaryRequireApproval *bool `form:"ai_summary_require_approval,omitempty" json:"ai_summary_require_approval,omitempty" xml:"ai_summary_require_approval,omitempty"`
}

// NewGetMeetingsResponseBody builds the HTTP response body from the result of
// the "get-meetings" endpoint of the "Meeting Service" service.
func NewGetMeetingsResponseBody(res *meetingservice.GetMeetingsResult) *GetMeetingsResponseBody {
	body := &GetMeetingsResponseBody{}
	if res.Meetings != nil {
		body.Meetings = make([]*MeetingResponseBody, len(res.Meetings))
		for i, val := range res.Meetings {
			body.Meetings[i] = marshalMeetingserviceMeetingToMeetingResponseBody(val)
		}
	} else {
		body.Meetings = []*MeetingResponseBody{}
	}
	return body
}

// NewCreateMeetingResponseBody builds the HTTP response body from the result
// of the "create-meeting" endpoint of the "Meeting Service" service.
func NewCreateMeetingResponseBody(res *meetingservice.Meeting) *CreateMeetingResponseBody {
	body := &CreateMeetingResponseBody{
		UID:                             res.UID,
		ProjectUID:                      res.ProjectUID,
		StartTime:                       res.StartTime,
		Duration:                        res.Duration,
		Timezone:                        res.Timezone,
		Title:                           res.Title,
		Description:                     res.Description,
		Platform:                        res.Platform,
		EarlyJoinTimeMinutes:            res.EarlyJoinTimeMinutes,
		MeetingType:                     res.MeetingType,
		Visibility:                      res.Visibility,
		Restricted:                      res.Restricted,
		ArtifactVisibility:              res.ArtifactVisibility,
		PublicLink:                      res.PublicLink,
		EmailDeliveryErrorCount:         res.EmailDeliveryErrorCount,
		RecordingEnabled:                res.RecordingEnabled,
		TranscriptEnabled:               res.TranscriptEnabled,
		YoutubeUploadEnabled:            res.YoutubeUploadEnabled,
		RegistrantCount:                 res.RegistrantCount,
		RegistrantResponseDeclinedCount: res.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: res.RegistrantResponseAcceptedCount,
		CreatedAt:                       res.CreatedAt,
		UpdatedAt:                       res.UpdatedAt,
	}
	if res.Recurrence != nil {
		body.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(res.Recurrence)
	}
	if res.Committees != nil {
		body.Committees = make([]*CommitteeResponseBody, len(res.Committees))
		for i, val := range res.Committees {
			body.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if res.ZoomConfig != nil {
		body.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(res.ZoomConfig)
	}
	if res.Occurrences != nil {
		body.Occurrences = make([]*OccurrenceResponseBody, len(res.Occurrences))
		for i, val := range res.Occurrences {
			body.Occurrences[i] = marshalMeetingserviceOccurrenceToOccurrenceResponseBody(val)
		}
	}
	return body
}

// NewGetMeetingResponseBody builds the HTTP response body from the result of
// the "get-meeting" endpoint of the "Meeting Service" service.
func NewGetMeetingResponseBody(res *meetingservice.GetMeetingResult) *GetMeetingResponseBody {
	body := &GetMeetingResponseBody{
		UID:                             res.Meeting.UID,
		ProjectUID:                      res.Meeting.ProjectUID,
		StartTime:                       res.Meeting.StartTime,
		Duration:                        res.Meeting.Duration,
		Timezone:                        res.Meeting.Timezone,
		Title:                           res.Meeting.Title,
		Description:                     res.Meeting.Description,
		Platform:                        res.Meeting.Platform,
		EarlyJoinTimeMinutes:            res.Meeting.EarlyJoinTimeMinutes,
		MeetingType:                     res.Meeting.MeetingType,
		Visibility:                      res.Meeting.Visibility,
		Restricted:                      res.Meeting.Restricted,
		ArtifactVisibility:              res.Meeting.ArtifactVisibility,
		PublicLink:                      res.Meeting.PublicLink,
		EmailDeliveryErrorCount:         res.Meeting.EmailDeliveryErrorCount,
		RecordingEnabled:                res.Meeting.RecordingEnabled,
		TranscriptEnabled:               res.Meeting.TranscriptEnabled,
		YoutubeUploadEnabled:            res.Meeting.YoutubeUploadEnabled,
		RegistrantCount:                 res.Meeting.RegistrantCount,
		RegistrantResponseDeclinedCount: res.Meeting.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: res.Meeting.RegistrantResponseAcceptedCount,
		CreatedAt:                       res.Meeting.CreatedAt,
		UpdatedAt:                       res.Meeting.UpdatedAt,
	}
	if res.Meeting.Recurrence != nil {
		body.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(res.Meeting.Recurrence)
	}
	if res.Meeting.Committees != nil {
		body.Committees = make([]*CommitteeResponseBody, len(res.Meeting.Committees))
		for i, val := range res.Meeting.Committees {
			body.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if res.Meeting.ZoomConfig != nil {
		body.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(res.Meeting.ZoomConfig)
	}
	if res.Meeting.Occurrences != nil {
		body.Occurrences = make([]*OccurrenceResponseBody, len(res.Meeting.Occurrences))
		for i, val := range res.Meeting.Occurrences {
			body.Occurrences[i] = marshalMeetingserviceOccurrenceToOccurrenceResponseBody(val)
		}
	}
	return body
}

// NewUpdateMeetingResponseBody builds the HTTP response body from the result
// of the "update-meeting" endpoint of the "Meeting Service" service.
func NewUpdateMeetingResponseBody(res *meetingservice.Meeting) *UpdateMeetingResponseBody {
	body := &UpdateMeetingResponseBody{
		UID:                             res.UID,
		ProjectUID:                      res.ProjectUID,
		StartTime:                       res.StartTime,
		Duration:                        res.Duration,
		Timezone:                        res.Timezone,
		Title:                           res.Title,
		Description:                     res.Description,
		Platform:                        res.Platform,
		EarlyJoinTimeMinutes:            res.EarlyJoinTimeMinutes,
		MeetingType:                     res.MeetingType,
		Visibility:                      res.Visibility,
		Restricted:                      res.Restricted,
		ArtifactVisibility:              res.ArtifactVisibility,
		PublicLink:                      res.PublicLink,
		EmailDeliveryErrorCount:         res.EmailDeliveryErrorCount,
		RecordingEnabled:                res.RecordingEnabled,
		TranscriptEnabled:               res.TranscriptEnabled,
		YoutubeUploadEnabled:            res.YoutubeUploadEnabled,
		RegistrantCount:                 res.RegistrantCount,
		RegistrantResponseDeclinedCount: res.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: res.RegistrantResponseAcceptedCount,
		CreatedAt:                       res.CreatedAt,
		UpdatedAt:                       res.UpdatedAt,
	}
	if res.Recurrence != nil {
		body.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(res.Recurrence)
	}
	if res.Committees != nil {
		body.Committees = make([]*CommitteeResponseBody, len(res.Committees))
		for i, val := range res.Committees {
			body.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if res.ZoomConfig != nil {
		body.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(res.ZoomConfig)
	}
	if res.Occurrences != nil {
		body.Occurrences = make([]*OccurrenceResponseBody, len(res.Occurrences))
		for i, val := range res.Occurrences {
			body.Occurrences[i] = marshalMeetingserviceOccurrenceToOccurrenceResponseBody(val)
		}
	}
	return body
}

// NewGetMeetingRegistrantsResponseBody builds the HTTP response body from the
// result of the "get-meeting-registrants" endpoint of the "Meeting Service"
// service.
func NewGetMeetingRegistrantsResponseBody(res *meetingservice.GetMeetingRegistrantsResult) *GetMeetingRegistrantsResponseBody {
	body := &GetMeetingRegistrantsResponseBody{}
	if res.Registrants != nil {
		body.Registrants = make([]*RegistrantResponseBody, len(res.Registrants))
		for i, val := range res.Registrants {
			body.Registrants[i] = marshalMeetingserviceRegistrantToRegistrantResponseBody(val)
		}
	} else {
		body.Registrants = []*RegistrantResponseBody{}
	}
	return body
}

// NewCreateMeetingRegistrantResponseBody builds the HTTP response body from
// the result of the "create-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewCreateMeetingRegistrantResponseBody(res *meetingservice.Registrant) *CreateMeetingRegistrantResponseBody {
	body := &CreateMeetingRegistrantResponseBody{
		UID:                res.UID,
		MeetingUID:         res.MeetingUID,
		Email:              res.Email,
		FirstName:          res.FirstName,
		LastName:           res.LastName,
		Host:               res.Host,
		JobTitle:           res.JobTitle,
		OccurrenceID:       res.OccurrenceID,
		OrgName:            res.OrgName,
		OrgIsMember:        res.OrgIsMember,
		OrgIsProjectMember: res.OrgIsProjectMember,
		AvatarURL:          res.AvatarURL,
		UserID:             res.UserID,
		CreatedAt:          res.CreatedAt,
		UpdatedAt:          res.UpdatedAt,
	}
	return body
}

// NewGetMeetingRegistrantResponseBody builds the HTTP response body from the
// result of the "get-meeting-registrant" endpoint of the "Meeting Service"
// service.
func NewGetMeetingRegistrantResponseBody(res *meetingservice.GetMeetingRegistrantResult) *GetMeetingRegistrantResponseBody {
	body := &GetMeetingRegistrantResponseBody{
		UID:                res.Registrant.UID,
		MeetingUID:         res.Registrant.MeetingUID,
		Email:              res.Registrant.Email,
		FirstName:          res.Registrant.FirstName,
		LastName:           res.Registrant.LastName,
		Host:               res.Registrant.Host,
		JobTitle:           res.Registrant.JobTitle,
		OccurrenceID:       res.Registrant.OccurrenceID,
		OrgName:            res.Registrant.OrgName,
		OrgIsMember:        res.Registrant.OrgIsMember,
		OrgIsProjectMember: res.Registrant.OrgIsProjectMember,
		AvatarURL:          res.Registrant.AvatarURL,
		UserID:             res.Registrant.UserID,
		CreatedAt:          res.Registrant.CreatedAt,
		UpdatedAt:          res.Registrant.UpdatedAt,
	}
	return body
}

// NewUpdateMeetingRegistrantResponseBody builds the HTTP response body from
// the result of the "update-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingRegistrantResponseBody(res *meetingservice.Registrant) *UpdateMeetingRegistrantResponseBody {
	body := &UpdateMeetingRegistrantResponseBody{
		UID:                res.UID,
		MeetingUID:         res.MeetingUID,
		Email:              res.Email,
		FirstName:          res.FirstName,
		LastName:           res.LastName,
		Host:               res.Host,
		JobTitle:           res.JobTitle,
		OccurrenceID:       res.OccurrenceID,
		OrgName:            res.OrgName,
		OrgIsMember:        res.OrgIsMember,
		OrgIsProjectMember: res.OrgIsProjectMember,
		AvatarURL:          res.AvatarURL,
		UserID:             res.UserID,
		CreatedAt:          res.CreatedAt,
		UpdatedAt:          res.UpdatedAt,
	}
	return body
}

// NewGetMeetingsBadRequestResponseBody builds the HTTP response body from the
// result of the "get-meetings" endpoint of the "Meeting Service" service.
func NewGetMeetingsBadRequestResponseBody(res *meetingservice.BadRequestError) *GetMeetingsBadRequestResponseBody {
	body := &GetMeetingsBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingsInternalServerErrorResponseBody builds the HTTP response body
// from the result of the "get-meetings" endpoint of the "Meeting Service"
// service.
func NewGetMeetingsInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingsInternalServerErrorResponseBody {
	body := &GetMeetingsInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingsServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "get-meetings" endpoint of the "Meeting Service"
// service.
func NewGetMeetingsServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingsServiceUnavailableResponseBody {
	body := &GetMeetingsServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingBadRequestResponseBody builds the HTTP response body from
// the result of the "create-meeting" endpoint of the "Meeting Service" service.
func NewCreateMeetingBadRequestResponseBody(res *meetingservice.BadRequestError) *CreateMeetingBadRequestResponseBody {
	body := &CreateMeetingBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingConflictResponseBody builds the HTTP response body from the
// result of the "create-meeting" endpoint of the "Meeting Service" service.
func NewCreateMeetingConflictResponseBody(res *meetingservice.ConflictError) *CreateMeetingConflictResponseBody {
	body := &CreateMeetingConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "create-meeting" endpoint of the "Meeting
// Service" service.
func NewCreateMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *CreateMeetingInternalServerErrorResponseBody {
	body := &CreateMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "create-meeting" endpoint of the "Meeting Service"
// service.
func NewCreateMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *CreateMeetingServiceUnavailableResponseBody {
	body := &CreateMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingInternalServerErrorResponseBody builds the HTTP response body
// from the result of the "get-meeting" endpoint of the "Meeting Service"
// service.
func NewGetMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingInternalServerErrorResponseBody {
	body := &GetMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingNotFoundResponseBody builds the HTTP response body from the
// result of the "get-meeting" endpoint of the "Meeting Service" service.
func NewGetMeetingNotFoundResponseBody(res *meetingservice.NotFoundError) *GetMeetingNotFoundResponseBody {
	body := &GetMeetingNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "get-meeting" endpoint of the "Meeting Service"
// service.
func NewGetMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingServiceUnavailableResponseBody {
	body := &GetMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingBadRequestResponseBody builds the HTTP response body from
// the result of the "update-meeting" endpoint of the "Meeting Service" service.
func NewUpdateMeetingBadRequestResponseBody(res *meetingservice.BadRequestError) *UpdateMeetingBadRequestResponseBody {
	body := &UpdateMeetingBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingConflictResponseBody builds the HTTP response body from the
// result of the "update-meeting" endpoint of the "Meeting Service" service.
func NewUpdateMeetingConflictResponseBody(res *meetingservice.ConflictError) *UpdateMeetingConflictResponseBody {
	body := &UpdateMeetingConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "update-meeting" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *UpdateMeetingInternalServerErrorResponseBody {
	body := &UpdateMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingNotFoundResponseBody builds the HTTP response body from the
// result of the "update-meeting" endpoint of the "Meeting Service" service.
func NewUpdateMeetingNotFoundResponseBody(res *meetingservice.NotFoundError) *UpdateMeetingNotFoundResponseBody {
	body := &UpdateMeetingNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "update-meeting" endpoint of the "Meeting Service"
// service.
func NewUpdateMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *UpdateMeetingServiceUnavailableResponseBody {
	body := &UpdateMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingBadRequestResponseBody builds the HTTP response body from
// the result of the "delete-meeting" endpoint of the "Meeting Service" service.
func NewDeleteMeetingBadRequestResponseBody(res *meetingservice.BadRequestError) *DeleteMeetingBadRequestResponseBody {
	body := &DeleteMeetingBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingInternalServerErrorResponseBody builds the HTTP response
// body from the result of the "delete-meeting" endpoint of the "Meeting
// Service" service.
func NewDeleteMeetingInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *DeleteMeetingInternalServerErrorResponseBody {
	body := &DeleteMeetingInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingNotFoundResponseBody builds the HTTP response body from the
// result of the "delete-meeting" endpoint of the "Meeting Service" service.
func NewDeleteMeetingNotFoundResponseBody(res *meetingservice.NotFoundError) *DeleteMeetingNotFoundResponseBody {
	body := &DeleteMeetingNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingServiceUnavailableResponseBody builds the HTTP response body
// from the result of the "delete-meeting" endpoint of the "Meeting Service"
// service.
func NewDeleteMeetingServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *DeleteMeetingServiceUnavailableResponseBody {
	body := &DeleteMeetingServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantsInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "get-meeting-registrants" endpoint of
// the "Meeting Service" service.
func NewGetMeetingRegistrantsInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingRegistrantsInternalServerErrorResponseBody {
	body := &GetMeetingRegistrantsInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantsNotFoundResponseBody builds the HTTP response body
// from the result of the "get-meeting-registrants" endpoint of the "Meeting
// Service" service.
func NewGetMeetingRegistrantsNotFoundResponseBody(res *meetingservice.NotFoundError) *GetMeetingRegistrantsNotFoundResponseBody {
	body := &GetMeetingRegistrantsNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantsServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "get-meeting-registrants" endpoint of
// the "Meeting Service" service.
func NewGetMeetingRegistrantsServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingRegistrantsServiceUnavailableResponseBody {
	body := &GetMeetingRegistrantsServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantBadRequestResponseBody builds the HTTP response
// body from the result of the "create-meeting-registrant" endpoint of the
// "Meeting Service" service.
func NewCreateMeetingRegistrantBadRequestResponseBody(res *meetingservice.BadRequestError) *CreateMeetingRegistrantBadRequestResponseBody {
	body := &CreateMeetingRegistrantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantConflictResponseBody builds the HTTP response body
// from the result of the "create-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewCreateMeetingRegistrantConflictResponseBody(res *meetingservice.ConflictError) *CreateMeetingRegistrantConflictResponseBody {
	body := &CreateMeetingRegistrantConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "create-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewCreateMeetingRegistrantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *CreateMeetingRegistrantInternalServerErrorResponseBody {
	body := &CreateMeetingRegistrantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantNotFoundResponseBody builds the HTTP response body
// from the result of the "create-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewCreateMeetingRegistrantNotFoundResponseBody(res *meetingservice.NotFoundError) *CreateMeetingRegistrantNotFoundResponseBody {
	body := &CreateMeetingRegistrantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewCreateMeetingRegistrantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "create-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewCreateMeetingRegistrantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *CreateMeetingRegistrantServiceUnavailableResponseBody {
	body := &CreateMeetingRegistrantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "get-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewGetMeetingRegistrantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *GetMeetingRegistrantInternalServerErrorResponseBody {
	body := &GetMeetingRegistrantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantNotFoundResponseBody builds the HTTP response body
// from the result of the "get-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewGetMeetingRegistrantNotFoundResponseBody(res *meetingservice.NotFoundError) *GetMeetingRegistrantNotFoundResponseBody {
	body := &GetMeetingRegistrantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingRegistrantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "get-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewGetMeetingRegistrantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *GetMeetingRegistrantServiceUnavailableResponseBody {
	body := &GetMeetingRegistrantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantBadRequestResponseBody builds the HTTP response
// body from the result of the "update-meeting-registrant" endpoint of the
// "Meeting Service" service.
func NewUpdateMeetingRegistrantBadRequestResponseBody(res *meetingservice.BadRequestError) *UpdateMeetingRegistrantBadRequestResponseBody {
	body := &UpdateMeetingRegistrantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantConflictResponseBody builds the HTTP response body
// from the result of the "update-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingRegistrantConflictResponseBody(res *meetingservice.ConflictError) *UpdateMeetingRegistrantConflictResponseBody {
	body := &UpdateMeetingRegistrantConflictResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "update-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewUpdateMeetingRegistrantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *UpdateMeetingRegistrantInternalServerErrorResponseBody {
	body := &UpdateMeetingRegistrantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantNotFoundResponseBody builds the HTTP response body
// from the result of the "update-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewUpdateMeetingRegistrantNotFoundResponseBody(res *meetingservice.NotFoundError) *UpdateMeetingRegistrantNotFoundResponseBody {
	body := &UpdateMeetingRegistrantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewUpdateMeetingRegistrantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "update-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewUpdateMeetingRegistrantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *UpdateMeetingRegistrantServiceUnavailableResponseBody {
	body := &UpdateMeetingRegistrantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingRegistrantBadRequestResponseBody builds the HTTP response
// body from the result of the "delete-meeting-registrant" endpoint of the
// "Meeting Service" service.
func NewDeleteMeetingRegistrantBadRequestResponseBody(res *meetingservice.BadRequestError) *DeleteMeetingRegistrantBadRequestResponseBody {
	body := &DeleteMeetingRegistrantBadRequestResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingRegistrantInternalServerErrorResponseBody builds the HTTP
// response body from the result of the "delete-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewDeleteMeetingRegistrantInternalServerErrorResponseBody(res *meetingservice.InternalServerError) *DeleteMeetingRegistrantInternalServerErrorResponseBody {
	body := &DeleteMeetingRegistrantInternalServerErrorResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingRegistrantNotFoundResponseBody builds the HTTP response body
// from the result of the "delete-meeting-registrant" endpoint of the "Meeting
// Service" service.
func NewDeleteMeetingRegistrantNotFoundResponseBody(res *meetingservice.NotFoundError) *DeleteMeetingRegistrantNotFoundResponseBody {
	body := &DeleteMeetingRegistrantNotFoundResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewDeleteMeetingRegistrantServiceUnavailableResponseBody builds the HTTP
// response body from the result of the "delete-meeting-registrant" endpoint of
// the "Meeting Service" service.
func NewDeleteMeetingRegistrantServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *DeleteMeetingRegistrantServiceUnavailableResponseBody {
	body := &DeleteMeetingRegistrantServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewReadyzServiceUnavailableResponseBody builds the HTTP response body from
// the result of the "readyz" endpoint of the "Meeting Service" service.
func NewReadyzServiceUnavailableResponseBody(res *meetingservice.ServiceUnavailableError) *ReadyzServiceUnavailableResponseBody {
	body := &ReadyzServiceUnavailableResponseBody{
		Code:    res.Code,
		Message: res.Message,
	}
	return body
}

// NewGetMeetingsPayload builds a Meeting Service service get-meetings endpoint
// payload.
func NewGetMeetingsPayload(version *string, bearerToken *string) *meetingservice.GetMeetingsPayload {
	v := &meetingservice.GetMeetingsPayload{}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewCreateMeetingPayload builds a Meeting Service service create-meeting
// endpoint payload.
func NewCreateMeetingPayload(body *CreateMeetingRequestBody, version *string, bearerToken *string) *meetingservice.CreateMeetingPayload {
	v := &meetingservice.CreateMeetingPayload{
		ProjectUID:           *body.ProjectUID,
		StartTime:            *body.StartTime,
		Duration:             *body.Duration,
		Timezone:             *body.Timezone,
		Title:                *body.Title,
		Description:          *body.Description,
		Platform:             body.Platform,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		MeetingType:          body.MeetingType,
		Visibility:           body.Visibility,
		Restricted:           body.Restricted,
		ArtifactVisibility:   body.ArtifactVisibility,
		PublicLink:           body.PublicLink,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
	}
	if body.Recurrence != nil {
		v.Recurrence = unmarshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			v.Committees[i] = unmarshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.ZoomConfig != nil {
		v.ZoomConfig = unmarshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(body.ZoomConfig)
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetMeetingPayload builds a Meeting Service service get-meeting endpoint
// payload.
func NewGetMeetingPayload(uid string, version *string, bearerToken *string) *meetingservice.GetMeetingPayload {
	v := &meetingservice.GetMeetingPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewUpdateMeetingPayload builds a Meeting Service service update-meeting
// endpoint payload.
func NewUpdateMeetingPayload(body *UpdateMeetingRequestBody, uid string, version *string, bearerToken *string, etag *string) *meetingservice.UpdateMeetingPayload {
	v := &meetingservice.UpdateMeetingPayload{
		ProjectUID:           *body.ProjectUID,
		StartTime:            *body.StartTime,
		Duration:             *body.Duration,
		Timezone:             *body.Timezone,
		Title:                *body.Title,
		Description:          *body.Description,
		Platform:             body.Platform,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		MeetingType:          body.MeetingType,
		Visibility:           body.Visibility,
		Restricted:           body.Restricted,
		ArtifactVisibility:   body.ArtifactVisibility,
		PublicLink:           body.PublicLink,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
	}
	if body.Recurrence != nil {
		v.Recurrence = unmarshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			v.Committees[i] = unmarshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.ZoomConfig != nil {
		v.ZoomConfig = unmarshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(body.ZoomConfig)
	}
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken
	v.Etag = etag

	return v
}

// NewDeleteMeetingPayload builds a Meeting Service service delete-meeting
// endpoint payload.
func NewDeleteMeetingPayload(uid string, version *string, bearerToken *string, etag *string) *meetingservice.DeleteMeetingPayload {
	v := &meetingservice.DeleteMeetingPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.Etag = etag

	return v
}

// NewGetMeetingRegistrantsPayload builds a Meeting Service service
// get-meeting-registrants endpoint payload.
func NewGetMeetingRegistrantsPayload(uid string, version *string, bearerToken *string) *meetingservice.GetMeetingRegistrantsPayload {
	v := &meetingservice.GetMeetingRegistrantsPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewCreateMeetingRegistrantPayload builds a Meeting Service service
// create-meeting-registrant endpoint payload.
func NewCreateMeetingRegistrantPayload(body *CreateMeetingRegistrantRequestBody, uid string, version *string, bearerToken *string) *meetingservice.CreateMeetingRegistrantPayload {
	v := &meetingservice.CreateMeetingRegistrantPayload{
		MeetingUID:         *body.MeetingUID,
		Email:              *body.Email,
		FirstName:          *body.FirstName,
		LastName:           *body.LastName,
		Host:               body.Host,
		JobTitle:           body.JobTitle,
		OccurrenceID:       body.OccurrenceID,
		OrgIsProjectMember: body.OrgIsProjectMember,
		AvatarURL:          body.AvatarURL,
		UserID:             body.UserID,
	}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewGetMeetingRegistrantPayload builds a Meeting Service service
// get-meeting-registrant endpoint payload.
func NewGetMeetingRegistrantPayload(meetingUID string, uid string, version *string, bearerToken *string) *meetingservice.GetMeetingRegistrantPayload {
	v := &meetingservice.GetMeetingRegistrantPayload{}
	v.MeetingUID = &meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v
}

// NewUpdateMeetingRegistrantPayload builds a Meeting Service service
// update-meeting-registrant endpoint payload.
func NewUpdateMeetingRegistrantPayload(body *UpdateMeetingRegistrantRequestBody, meetingUID string, uid string, version *string, bearerToken *string, etag *string) *meetingservice.UpdateMeetingRegistrantPayload {
	v := &meetingservice.UpdateMeetingRegistrantPayload{
		Email:              *body.Email,
		FirstName:          *body.FirstName,
		LastName:           *body.LastName,
		Host:               body.Host,
		JobTitle:           body.JobTitle,
		OccurrenceID:       body.OccurrenceID,
		OrgIsProjectMember: body.OrgIsProjectMember,
		AvatarURL:          body.AvatarURL,
		UserID:             body.UserID,
	}
	v.MeetingUID = meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.Etag = etag

	return v
}

// NewDeleteMeetingRegistrantPayload builds a Meeting Service service
// delete-meeting-registrant endpoint payload.
func NewDeleteMeetingRegistrantPayload(meetingUID string, uid string, version *string, bearerToken *string, etag *string) *meetingservice.DeleteMeetingRegistrantPayload {
	v := &meetingservice.DeleteMeetingRegistrantPayload{}
	v.MeetingUID = &meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.Etag = etag

	return v
}

// ValidateCreateMeetingRequestBody runs the validations defined on
// Create-MeetingRequestBody
func ValidateCreateMeetingRequestBody(body *CreateMeetingRequestBody) (err error) {
	if body.ProjectUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("project_uid", "body"))
	}
	if body.StartTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("start_time", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	if body.Timezone == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timezone", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.ProjectUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
	}
	if body.StartTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
	}
	if body.Duration != nil {
		if *body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 0, true))
		}
	}
	if body.Duration != nil {
		if *body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 600, false))
		}
	}
	if body.Recurrence != nil {
		if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Committees {
		if e != nil {
			if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.Platform != nil {
		if !(*body.Platform == "Zoom") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes < 10 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes > 60 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
		}
	}
	if body.MeetingType != nil {
		if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
		}
	}
	if body.Visibility != nil {
		if !(*body.Visibility == "public" || *body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
		}
	}
	if body.ArtifactVisibility != nil {
		if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
		}
	}
	return
}

// ValidateUpdateMeetingRequestBody runs the validations defined on
// Update-MeetingRequestBody
func ValidateUpdateMeetingRequestBody(body *UpdateMeetingRequestBody) (err error) {
	if body.ProjectUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("project_uid", "body"))
	}
	if body.StartTime == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("start_time", "body"))
	}
	if body.Duration == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("duration", "body"))
	}
	if body.Timezone == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timezone", "body"))
	}
	if body.Title == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("title", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.ProjectUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
	}
	if body.StartTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
	}
	if body.Duration != nil {
		if *body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 0, true))
		}
	}
	if body.Duration != nil {
		if *body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 600, false))
		}
	}
	if body.Recurrence != nil {
		if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	for _, e := range body.Committees {
		if e != nil {
			if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	if body.Platform != nil {
		if !(*body.Platform == "Zoom") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes < 10 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
		}
	}
	if body.EarlyJoinTimeMinutes != nil {
		if *body.EarlyJoinTimeMinutes > 60 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
		}
	}
	if body.MeetingType != nil {
		if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
		}
	}
	if body.Visibility != nil {
		if !(*body.Visibility == "public" || *body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
		}
	}
	if body.ArtifactVisibility != nil {
		if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
		}
	}
	return
}

// ValidateCreateMeetingRegistrantRequestBody runs the validations defined on
// Create-Meeting-RegistrantRequestBody
func ValidateCreateMeetingRegistrantRequestBody(body *CreateMeetingRegistrantRequestBody) (err error) {
	if body.MeetingUID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("meeting_uid", "body"))
	}
	if body.Email == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("email", "body"))
	}
	if body.FirstName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("first_name", "body"))
	}
	if body.LastName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("last_name", "body"))
	}
	if body.MeetingUID != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.meeting_uid", *body.MeetingUID, goa.FormatUUID))
	}
	if body.Email != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
		}
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
		}
	}
	if body.OccurrenceID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.occurrence_id", *body.OccurrenceID, "^[0-9]*$"))
	}
	if body.AvatarURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
	}
	return
}

// ValidateUpdateMeetingRegistrantRequestBody runs the validations defined on
// Update-Meeting-RegistrantRequestBody
func ValidateUpdateMeetingRegistrantRequestBody(body *UpdateMeetingRegistrantRequestBody) (err error) {
	if body.Email == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("email", "body"))
	}
	if body.FirstName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("first_name", "body"))
	}
	if body.LastName == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("last_name", "body"))
	}
	if body.Email != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
		}
	}
	if body.FirstName != nil {
		if utf8.RuneCountInString(*body.FirstName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
		}
	}
	if body.LastName != nil {
		if utf8.RuneCountInString(*body.LastName) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
		}
	}
	if body.OccurrenceID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.occurrence_id", *body.OccurrenceID, "^[0-9]*$"))
	}
	if body.AvatarURL != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
	}
	return
}

// ValidateRecurrenceRequestBody runs the validations defined on
// RecurrenceRequestBody
func ValidateRecurrenceRequestBody(body *RecurrenceRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.RepeatInterval == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("repeat_interval", "body"))
	}
	if body.Type != nil {
		if !(*body.Type == 1 || *body.Type == 2 || *body.Type == 3) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{1, 2, 3}))
		}
	}
	if body.WeeklyDays != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.weekly_days", *body.WeeklyDays, "^[1-7](,[1-7])*$"))
	}
	if body.MonthlyDay != nil {
		if *body.MonthlyDay < 1 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.monthly_day", *body.MonthlyDay, 1, true))
		}
	}
	if body.MonthlyDay != nil {
		if *body.MonthlyDay > 31 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.monthly_day", *body.MonthlyDay, 31, false))
		}
	}
	if body.MonthlyWeek != nil {
		if !(*body.MonthlyWeek == -1 || *body.MonthlyWeek == 1 || *body.MonthlyWeek == 2 || *body.MonthlyWeek == 3 || *body.MonthlyWeek == 4) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.monthly_week", *body.MonthlyWeek, []any{-1, 1, 2, 3, 4}))
		}
	}
	if body.MonthlyWeekDay != nil {
		if !(*body.MonthlyWeekDay == 1 || *body.MonthlyWeekDay == 2 || *body.MonthlyWeekDay == 3 || *body.MonthlyWeekDay == 4 || *body.MonthlyWeekDay == 5 || *body.MonthlyWeekDay == 6 || *body.MonthlyWeekDay == 7) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.monthly_week_day", *body.MonthlyWeekDay, []any{1, 2, 3, 4, 5, 6, 7}))
		}
	}
	if body.EndDateTime != nil {
		err = goa.MergeErrors(err, goa.ValidateFormat("body.end_date_time", *body.EndDateTime, goa.FormatDateTime))
	}
	return
}

// ValidateCommitteeRequestBody runs the validations defined on
// CommitteeRequestBody
func ValidateCommitteeRequestBody(body *CommitteeRequestBody) (err error) {
	if body.UID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("uid", "body"))
	}
	if body.AllowedVotingStatuses == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("allowed_voting_statuses", "body"))
	}
	return
}
