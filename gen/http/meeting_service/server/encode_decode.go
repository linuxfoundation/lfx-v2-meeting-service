// Code generated by goa v3.21.1, DO NOT EDIT.
//
// Meeting Service HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strings"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeGetMeetingsResponse returns an encoder for responses returned by the
// Meeting Service get-meetings endpoint.
func EncodeGetMeetingsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.GetMeetingsResult)
		enc := encoder(ctx, w)
		body := NewGetMeetingsResponseBody(res)
		if res.CacheControl != nil {
			w.Header().Set("Cache-Control", *res.CacheControl)
		}
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetMeetingsRequest returns a decoder for requests sent to the Meeting
// Service get-meetings endpoint.
func DecodeGetMeetingsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			version     *string
			bearerToken *string
			err         error
		)
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetMeetingsPayload(version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetMeetingsError returns an encoder for errors returned by the
// get-meetings Meeting Service endpoint.
func EncodeGetMeetingsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingsInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingsServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateMeetingResponse returns an encoder for responses returned by the
// Meeting Service create-meeting endpoint.
func EncodeCreateMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.Meeting)
		enc := encoder(ctx, w)
		body := NewCreateMeetingResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateMeetingRequest returns a decoder for requests sent to the
// Meeting Service create-meeting endpoint.
func DecodeCreateMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body struct {
				// The UID of the LF project
				ProjectUID *string `form:"project_uid" json:"project_uid" xml:"project_uid"`
				// The start time of the meeting in RFC3339 format
				StartTime *string `form:"start_time" json:"start_time" xml:"start_time"`
				// The duration of the meeting in minutes
				Duration *int `form:"duration" json:"duration" xml:"duration"`
				// The timezone of the meeting (e.g. 'America/New_York')
				Timezone *string `form:"timezone" json:"timezone" xml:"timezone"`
				// The recurrence of the meeting
				Recurrence *RecurrenceRequestBodyRequestBody `form:"recurrence" json:"recurrence" xml:"recurrence"`
				// The title of the meeting
				Title *string `form:"title" json:"title" xml:"title"`
				// The description of the meeting
				Description *string `form:"description" json:"description" xml:"description"`
				// The committees associated with the meeting
				Committees []*CommitteeRequestBodyRequestBody `form:"committees" json:"committees" xml:"committees"`
				// The platform name of where the meeting is hosted
				Platform *string `form:"platform" json:"platform" xml:"platform"`
				// The number of minutes that users are allowed to join the meeting early
				// without being kicked out
				EarlyJoinTimeMinutes *int `form:"early_join_time_minutes" json:"early_join_time_minutes" xml:"early_join_time_minutes"`
				// The type of meeting. This is usually dependent on the committee(s)
				// associated with the meeting
				MeetingType *string `form:"meeting_type" json:"meeting_type" xml:"meeting_type"`
				// The visibility of the meeting's existence to other users
				Visibility *string `form:"visibility" json:"visibility" xml:"visibility"`
				// The restrictedness of joining the meeting (i.e. is the meeting restricted to
				// only invited users or anyone?)
				Restricted *bool `form:"restricted" json:"restricted" xml:"restricted"`
				// The visibility of artifacts to users (e.g. public, only for registrants,
				// only for hosts)
				ArtifactVisibility *string `form:"artifact_visibility" json:"artifact_visibility" xml:"artifact_visibility"`
				// The public join URL for participants to join the meeting via the LFX
				// platform (e.g.
				// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
				PublicLink *string `form:"public_link" json:"public_link" xml:"public_link"`
				// Whether recording is enabled for the meeting
				RecordingEnabled *bool `form:"recording_enabled" json:"recording_enabled" xml:"recording_enabled"`
				// Whether transcription is enabled for the meeting
				TranscriptEnabled *bool `form:"transcript_enabled" json:"transcript_enabled" xml:"transcript_enabled"`
				// Whether automatic youtube uploading is enabled for the meeting
				YoutubeUploadEnabled *bool `form:"youtube_upload_enabled" json:"youtube_upload_enabled" xml:"youtube_upload_enabled"`
				// For zoom platform meetings: the configuration for the meeting
				ZoomConfig *ZoomConfigPostRequestBodyRequestBody `form:"zoom_config" json:"zoom_config" xml:"zoom_config"`
			}
			err error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		if body.ProjectUID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
		}
		if body.StartTime != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
		}
		if body.Duration != nil {
			if *body.Duration < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 0, true))
			}
		}
		if body.Duration != nil {
			if *body.Duration > 600 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 600, false))
			}
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBodyRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBodyRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.Platform != nil {
			if !(*body.Platform == "Zoom") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.Visibility != nil {
			if !(*body.Visibility == "public" || *body.Visibility == "private") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if err != nil {
			return nil, err
		}

		var (
			version     *string
			bearerToken *string
		)
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateMeetingPayload(body, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateMeetingError returns an encoder for errors returned by the
// create-meeting Meeting Service endpoint.
func EncodeCreateMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Conflict":
			var res *meetingservice.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetMeetingResponse returns an encoder for responses returned by the
// Meeting Service get-meeting endpoint.
func EncodeGetMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.GetMeetingResult)
		enc := encoder(ctx, w)
		body := NewGetMeetingResponseBody(res)
		if res.Etag != nil {
			w.Header().Set("Etag", *res.Etag)
		}
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetMeetingRequest returns a decoder for requests sent to the Meeting
// Service get-meeting endpoint.
func DecodeGetMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			uid         string
			version     *string
			bearerToken *string
			err         error

			params = mux.Vars(r)
		)
		uid = params["uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetMeetingPayload(uid, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetMeetingError returns an encoder for errors returned by the
// get-meeting Meeting Service endpoint.
func EncodeGetMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateMeetingResponse returns an encoder for responses returned by the
// Meeting Service update-meeting endpoint.
func EncodeUpdateMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.Meeting)
		enc := encoder(ctx, w)
		body := NewUpdateMeetingResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateMeetingRequest returns a decoder for requests sent to the
// Meeting Service update-meeting endpoint.
func DecodeUpdateMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			body struct {
				// The UID of the LF project
				ProjectUID *string `form:"project_uid" json:"project_uid" xml:"project_uid"`
				// The start time of the meeting in RFC3339 format
				StartTime *string `form:"start_time" json:"start_time" xml:"start_time"`
				// The duration of the meeting in minutes
				Duration *int `form:"duration" json:"duration" xml:"duration"`
				// The timezone of the meeting (e.g. 'America/New_York')
				Timezone *string `form:"timezone" json:"timezone" xml:"timezone"`
				// The recurrence of the meeting
				Recurrence *RecurrenceRequestBodyRequestBody `form:"recurrence" json:"recurrence" xml:"recurrence"`
				// The title of the meeting
				Title *string `form:"title" json:"title" xml:"title"`
				// The description of the meeting
				Description *string `form:"description" json:"description" xml:"description"`
				// The committees associated with the meeting
				Committees []*CommitteeRequestBodyRequestBody `form:"committees" json:"committees" xml:"committees"`
				// The platform name of where the meeting is hosted
				Platform *string `form:"platform" json:"platform" xml:"platform"`
				// The number of minutes that users are allowed to join the meeting early
				// without being kicked out
				EarlyJoinTimeMinutes *int `form:"early_join_time_minutes" json:"early_join_time_minutes" xml:"early_join_time_minutes"`
				// The type of meeting. This is usually dependent on the committee(s)
				// associated with the meeting
				MeetingType *string `form:"meeting_type" json:"meeting_type" xml:"meeting_type"`
				// The visibility of the meeting's existence to other users
				Visibility *string `form:"visibility" json:"visibility" xml:"visibility"`
				// The restrictedness of joining the meeting (i.e. is the meeting restricted to
				// only invited users or anyone?)
				Restricted *bool `form:"restricted" json:"restricted" xml:"restricted"`
				// The visibility of artifacts to users (e.g. public, only for registrants,
				// only for hosts)
				ArtifactVisibility *string `form:"artifact_visibility" json:"artifact_visibility" xml:"artifact_visibility"`
				// The public join URL for participants to join the meeting via the LFX
				// platform (e.g.
				// 'https://zoom-lfx.platform.linuxfoundation.org/meeting/12343245463')
				PublicLink *string `form:"public_link" json:"public_link" xml:"public_link"`
				// Whether recording is enabled for the meeting
				RecordingEnabled *bool `form:"recording_enabled" json:"recording_enabled" xml:"recording_enabled"`
				// Whether transcription is enabled for the meeting
				TranscriptEnabled *bool `form:"transcript_enabled" json:"transcript_enabled" xml:"transcript_enabled"`
				// Whether automatic youtube uploading is enabled for the meeting
				YoutubeUploadEnabled *bool `form:"youtube_upload_enabled" json:"youtube_upload_enabled" xml:"youtube_upload_enabled"`
				// For zoom platform meetings: the configuration for the meeting
				ZoomConfig *ZoomConfigPostRequestBodyRequestBody `form:"zoom_config" json:"zoom_config" xml:"zoom_config"`
			}
			err error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if err == io.EOF {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		if body.ProjectUID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", *body.ProjectUID, goa.FormatUUID))
		}
		if body.StartTime != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
		}
		if body.Duration != nil {
			if *body.Duration < 0 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 0, true))
			}
		}
		if body.Duration != nil {
			if *body.Duration > 600 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 600, false))
			}
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBodyRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBodyRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.Platform != nil {
			if !(*body.Platform == "Zoom") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.Visibility != nil {
			if !(*body.Visibility == "public" || *body.Visibility == "private") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if err != nil {
			return nil, err
		}

		var (
			uid         string
			version     *string
			bearerToken *string
			etag        *string

			params = mux.Vars(r)
		)
		uid = params["uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		etagRaw := r.Header.Get("ETag")
		if etagRaw != "" {
			etag = &etagRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateMeetingPayload(body, uid, version, bearerToken, etag)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateMeetingError returns an encoder for errors returned by the
// update-meeting Meeting Service endpoint.
func EncodeUpdateMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Conflict":
			var res *meetingservice.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteMeetingResponse returns an encoder for responses returned by the
// Meeting Service delete-meeting endpoint.
func EncodeDeleteMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteMeetingRequest returns a decoder for requests sent to the
// Meeting Service delete-meeting endpoint.
func DecodeDeleteMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			uid         string
			version     *string
			bearerToken *string
			etag        *string
			err         error

			params = mux.Vars(r)
		)
		uid = params["uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		etagRaw := r.Header.Get("ETag")
		if etagRaw != "" {
			etag = &etagRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteMeetingPayload(uid, version, bearerToken, etag)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteMeetingError returns an encoder for errors returned by the
// delete-meeting Meeting Service endpoint.
func EncodeDeleteMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetMeetingRegistrantsResponse returns an encoder for responses
// returned by the Meeting Service get-meeting-registrants endpoint.
func EncodeGetMeetingRegistrantsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.GetMeetingRegistrantsResult)
		enc := encoder(ctx, w)
		body := NewGetMeetingRegistrantsResponseBody(res)
		if res.CacheControl != nil {
			w.Header().Set("Cache-Control", *res.CacheControl)
		}
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetMeetingRegistrantsRequest returns a decoder for requests sent to
// the Meeting Service get-meeting-registrants endpoint.
func DecodeGetMeetingRegistrantsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			uid         string
			version     *string
			bearerToken *string
			err         error

			params = mux.Vars(r)
		)
		uid = params["uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetMeetingRegistrantsPayload(uid, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetMeetingRegistrantsError returns an encoder for errors returned by
// the get-meeting-registrants Meeting Service endpoint.
func EncodeGetMeetingRegistrantsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingRegistrantsInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingRegistrantsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingRegistrantsServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateMeetingRegistrantResponse returns an encoder for responses
// returned by the Meeting Service create-meeting-registrant endpoint.
func EncodeCreateMeetingRegistrantResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.Registrant)
		enc := encoder(ctx, w)
		body := NewCreateMeetingRegistrantResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateMeetingRegistrantRequest returns a decoder for requests sent to
// the Meeting Service create-meeting-registrant endpoint.
func DecodeCreateMeetingRegistrantRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			uid         string
			version     *string
			bearerToken *string
			err         error

			params = mux.Vars(r)
		)
		uid = params["uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateMeetingRegistrantPayload(uid, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateMeetingRegistrantError returns an encoder for errors returned by
// the create-meeting-registrant Meeting Service endpoint.
func EncodeCreateMeetingRegistrantError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingRegistrantBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Conflict":
			var res *meetingservice.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingRegistrantConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingRegistrantInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingRegistrantNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateMeetingRegistrantServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetMeetingRegistrantResponse returns an encoder for responses returned
// by the Meeting Service get-meeting-registrant endpoint.
func EncodeGetMeetingRegistrantResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.GetMeetingRegistrantResult)
		enc := encoder(ctx, w)
		body := NewGetMeetingRegistrantResponseBody(res)
		if res.Etag != nil {
			w.Header().Set("Etag", *res.Etag)
		}
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetMeetingRegistrantRequest returns a decoder for requests sent to the
// Meeting Service get-meeting-registrant endpoint.
func DecodeGetMeetingRegistrantRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			meetingUID  string
			uid         string
			version     *string
			bearerToken *string
			err         error

			params = mux.Vars(r)
		)
		meetingUID = params["meeting_uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		uid = params["uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetMeetingRegistrantPayload(meetingUID, uid, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetMeetingRegistrantError returns an encoder for errors returned by
// the get-meeting-registrant Meeting Service endpoint.
func EncodeGetMeetingRegistrantError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingRegistrantInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingRegistrantNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetMeetingRegistrantServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateMeetingRegistrantResponse returns an encoder for responses
// returned by the Meeting Service update-meeting-registrant endpoint.
func EncodeUpdateMeetingRegistrantResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.Registrant)
		enc := encoder(ctx, w)
		body := NewUpdateMeetingRegistrantResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateMeetingRegistrantRequest returns a decoder for requests sent to
// the Meeting Service update-meeting-registrant endpoint.
func DecodeUpdateMeetingRegistrantRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			meetingUID  string
			uid         string
			version     *string
			bearerToken *string
			etag        *string
			err         error

			params = mux.Vars(r)
		)
		meetingUID = params["meeting_uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		uid = params["uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		etagRaw := r.Header.Get("ETag")
		if etagRaw != "" {
			etag = &etagRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateMeetingRegistrantPayload(meetingUID, uid, version, bearerToken, etag)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateMeetingRegistrantError returns an encoder for errors returned by
// the update-meeting-registrant Meeting Service endpoint.
func EncodeUpdateMeetingRegistrantError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingRegistrantBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Conflict":
			var res *meetingservice.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingRegistrantConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingRegistrantInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingRegistrantNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateMeetingRegistrantServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteMeetingRegistrantResponse returns an encoder for responses
// returned by the Meeting Service delete-meeting-registrant endpoint.
func EncodeDeleteMeetingRegistrantResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteMeetingRegistrantRequest returns a decoder for requests sent to
// the Meeting Service delete-meeting-registrant endpoint.
func DecodeDeleteMeetingRegistrantRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (any, error) {
	return func(r *http.Request) (any, error) {
		var (
			meetingUID  string
			uid         string
			version     *string
			bearerToken *string
			etag        *string
			err         error

			params = mux.Vars(r)
		)
		meetingUID = params["meeting_uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		uid = params["uid"]
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		etagRaw := r.Header.Get("ETag")
		if etagRaw != "" {
			etag = &etagRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteMeetingRegistrantPayload(meetingUID, uid, version, bearerToken, etag)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteMeetingRegistrantError returns an encoder for errors returned by
// the delete-meeting-registrant Meeting Service endpoint.
func EncodeDeleteMeetingRegistrantError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteMeetingRegistrantBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteMeetingRegistrantInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteMeetingRegistrantNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteMeetingRegistrantServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeReadyzResponse returns an encoder for responses returned by the
// Meeting Service readyz endpoint.
func EncodeReadyzResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]byte)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/plain")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeReadyzError returns an encoder for errors returned by the readyz
// Meeting Service endpoint.
func EncodeReadyzError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewReadyzServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeLivezResponse returns an encoder for responses returned by the Meeting
// Service livez endpoint.
func EncodeLivezResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]byte)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/plain")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// marshalMeetingserviceMeetingToMeetingResponseBody builds a value of type
// *MeetingResponseBody from a value of type *meetingservice.Meeting.
func marshalMeetingserviceMeetingToMeetingResponseBody(v *meetingservice.Meeting) *MeetingResponseBody {
	res := &MeetingResponseBody{
		UID:                             v.UID,
		ProjectUID:                      v.ProjectUID,
		StartTime:                       v.StartTime,
		Duration:                        v.Duration,
		Timezone:                        v.Timezone,
		Title:                           v.Title,
		Description:                     v.Description,
		Platform:                        v.Platform,
		EarlyJoinTimeMinutes:            v.EarlyJoinTimeMinutes,
		MeetingType:                     v.MeetingType,
		Visibility:                      v.Visibility,
		Restricted:                      v.Restricted,
		ArtifactVisibility:              v.ArtifactVisibility,
		PublicLink:                      v.PublicLink,
		EmailDeliveryErrorCount:         v.EmailDeliveryErrorCount,
		RecordingEnabled:                v.RecordingEnabled,
		TranscriptEnabled:               v.TranscriptEnabled,
		YoutubeUploadEnabled:            v.YoutubeUploadEnabled,
		RegistrantCount:                 v.RegistrantCount,
		RegistrantResponseDeclinedCount: v.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: v.RegistrantResponseAcceptedCount,
		CreatedAt:                       v.CreatedAt,
		UpdatedAt:                       v.UpdatedAt,
	}
	if v.Recurrence != nil {
		res.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(v.Recurrence)
	}
	if v.Committees != nil {
		res.Committees = make([]*CommitteeResponseBody, len(v.Committees))
		for i, val := range v.Committees {
			res.Committees[i] = marshalMeetingserviceCommitteeToCommitteeResponseBody(val)
		}
	}
	if v.ZoomConfig != nil {
		res.ZoomConfig = marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(v.ZoomConfig)
	}
	if v.Occurrences != nil {
		res.Occurrences = make([]*OccurrenceResponseBody, len(v.Occurrences))
		for i, val := range v.Occurrences {
			res.Occurrences[i] = marshalMeetingserviceOccurrenceToOccurrenceResponseBody(val)
		}
	}

	return res
}

// marshalMeetingserviceRecurrenceToRecurrenceResponseBody builds a value of
// type *RecurrenceResponseBody from a value of type *meetingservice.Recurrence.
func marshalMeetingserviceRecurrenceToRecurrenceResponseBody(v *meetingservice.Recurrence) *RecurrenceResponseBody {
	if v == nil {
		return nil
	}
	res := &RecurrenceResponseBody{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalMeetingserviceCommitteeToCommitteeResponseBody builds a value of type
// *CommitteeResponseBody from a value of type *meetingservice.Committee.
func marshalMeetingserviceCommitteeToCommitteeResponseBody(v *meetingservice.Committee) *CommitteeResponseBody {
	if v == nil {
		return nil
	}
	res := &CommitteeResponseBody{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	} else {
		res.AllowedVotingStatuses = []string{}
	}

	return res
}

// marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody builds a
// value of type *ZoomConfigFullResponseBody from a value of type
// *meetingservice.ZoomConfigFull.
func marshalMeetingserviceZoomConfigFullToZoomConfigFullResponseBody(v *meetingservice.ZoomConfigFull) *ZoomConfigFullResponseBody {
	if v == nil {
		return nil
	}
	res := &ZoomConfigFullResponseBody{
		MeetingID:                v.MeetingID,
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalMeetingserviceOccurrenceToOccurrenceResponseBody builds a value of
// type *OccurrenceResponseBody from a value of type *meetingservice.Occurrence.
func marshalMeetingserviceOccurrenceToOccurrenceResponseBody(v *meetingservice.Occurrence) *OccurrenceResponseBody {
	if v == nil {
		return nil
	}
	res := &OccurrenceResponseBody{
		OccurrenceID:     v.OccurrenceID,
		StartTime:        v.StartTime,
		Title:            v.Title,
		Description:      v.Description,
		Duration:         v.Duration,
		RegistrantCount:  v.RegistrantCount,
		ResponseCountNo:  v.ResponseCountNo,
		ResponseCountYes: v.ResponseCountYes,
		Status:           v.Status,
	}
	if v.Recurrence != nil {
		res.Recurrence = marshalMeetingserviceRecurrenceToRecurrenceResponseBody(v.Recurrence)
	}

	return res
}

// unmarshalRecurrenceRequestBodyRequestBodyToMeetingserviceRecurrence builds a
// value of type *meetingservice.Recurrence from a value of type
// *RecurrenceRequestBodyRequestBody.
func unmarshalRecurrenceRequestBodyRequestBodyToMeetingserviceRecurrence(v *RecurrenceRequestBodyRequestBody) *meetingservice.Recurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Recurrence{
		Type:           *v.Type,
		RepeatInterval: *v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// unmarshalCommitteeRequestBodyRequestBodyToMeetingserviceCommittee builds a
// value of type *meetingservice.Committee from a value of type
// *CommitteeRequestBodyRequestBody.
func unmarshalCommitteeRequestBodyRequestBodyToMeetingserviceCommittee(v *CommitteeRequestBodyRequestBody) *meetingservice.Committee {
	if v == nil {
		return nil
	}
	res := &meetingservice.Committee{
		UID: *v.UID,
	}
	res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
	for i, val := range v.AllowedVotingStatuses {
		res.AllowedVotingStatuses[i] = val
	}

	return res
}

// unmarshalZoomConfigPostRequestBodyRequestBodyToMeetingserviceZoomConfigPost
// builds a value of type *meetingservice.ZoomConfigPost from a value of type
// *ZoomConfigPostRequestBodyRequestBody.
func unmarshalZoomConfigPostRequestBodyRequestBodyToMeetingserviceZoomConfigPost(v *ZoomConfigPostRequestBodyRequestBody) *meetingservice.ZoomConfigPost {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigPost{
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalMeetingserviceRegistrantToRegistrantResponseBody builds a value of
// type *RegistrantResponseBody from a value of type *meetingservice.Registrant.
func marshalMeetingserviceRegistrantToRegistrantResponseBody(v *meetingservice.Registrant) *RegistrantResponseBody {
	res := &RegistrantResponseBody{
		UID:                v.UID,
		MeetingUID:         v.MeetingUID,
		Email:              v.Email,
		FirstName:          v.FirstName,
		LastName:           v.LastName,
		Host:               v.Host,
		JobTitle:           v.JobTitle,
		OccurrenceID:       v.OccurrenceID,
		OrgName:            v.OrgName,
		OrgIsMember:        v.OrgIsMember,
		OrgIsProjectMember: v.OrgIsProjectMember,
		AvatarURL:          v.AvatarURL,
		UserID:             v.UserID,
		CreatedAt:          v.CreatedAt,
		UpdatedAt:          v.UpdatedAt,
	}

	return res
}
