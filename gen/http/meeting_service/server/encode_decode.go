// Code generated by goa v3.23.1, DO NOT EDIT.
//
// Meeting Service HTTP server encoders and decoders
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package server

import (
	"context"
	"errors"
	"io"
	"net/http"
	"strconv"
	"strings"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// EncodeReadyzResponse returns an encoder for responses returned by the
// Meeting Service readyz endpoint.
func EncodeReadyzResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]byte)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/plain")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeReadyzError returns an encoder for errors returned by the readyz
// Meeting Service endpoint.
func EncodeReadyzError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewReadyzServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeLivezResponse returns an encoder for responses returned by the Meeting
// Service livez endpoint.
func EncodeLivezResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]byte)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/plain")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// EncodeCreateItxMeetingResponse returns an encoder for responses returned by
// the Meeting Service create-itx-meeting endpoint.
func EncodeCreateItxMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXZoomMeetingResponse)
		enc := encoder(ctx, w)
		body := NewCreateItxMeetingResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateItxMeetingRequest returns a decoder for requests sent to the
// Meeting Service create-itx-meeting endpoint.
func DecodeCreateItxMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.CreateItxMeetingPayload, error) {
	return func(r *http.Request) (*meetingservice.CreateItxMeetingPayload, error) {
		var (
			body CreateItxMeetingRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateItxMeetingRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			version     *string
			bearerToken *string
			xSync       *bool
		)
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		{
			xSyncRaw := r.Header.Get("X-Sync")
			if xSyncRaw != "" {
				v, err2 := strconv.ParseBool(xSyncRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("x_sync", xSyncRaw, "boolean"))
				}
				xSync = &v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateItxMeetingPayload(&body, version, bearerToken, xSync)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateItxMeetingError returns an encoder for errors returned by the
// create-itx-meeting Meeting Service endpoint.
func EncodeCreateItxMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Conflict":
			var res *meetingservice.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxMeetingConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxMeetingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxMeetingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetItxMeetingResponse returns an encoder for responses returned by the
// Meeting Service get-itx-meeting endpoint.
func EncodeGetItxMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXZoomMeetingResponse)
		enc := encoder(ctx, w)
		body := NewGetItxMeetingResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetItxMeetingRequest returns a decoder for requests sent to the
// Meeting Service get-itx-meeting endpoint.
func DecodeGetItxMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.GetItxMeetingPayload, error) {
	return func(r *http.Request) (*meetingservice.GetItxMeetingPayload, error) {
		var (
			meetingID   string
			version     *string
			bearerToken *string
			err         error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetItxMeetingPayload(meetingID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetItxMeetingError returns an encoder for errors returned by the
// get-itx-meeting Meeting Service endpoint.
func EncodeGetItxMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteItxMeetingResponse returns an encoder for responses returned by
// the Meeting Service delete-itx-meeting endpoint.
func EncodeDeleteItxMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteItxMeetingRequest returns a decoder for requests sent to the
// Meeting Service delete-itx-meeting endpoint.
func DecodeDeleteItxMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.DeleteItxMeetingPayload, error) {
	return func(r *http.Request) (*meetingservice.DeleteItxMeetingPayload, error) {
		var (
			meetingID   string
			version     *string
			bearerToken *string
			err         error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteItxMeetingPayload(meetingID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteItxMeetingError returns an encoder for errors returned by the
// delete-itx-meeting Meeting Service endpoint.
func EncodeDeleteItxMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxMeetingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxMeetingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateItxMeetingResponse returns an encoder for responses returned by
// the Meeting Service update-itx-meeting endpoint.
func EncodeUpdateItxMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeUpdateItxMeetingRequest returns a decoder for requests sent to the
// Meeting Service update-itx-meeting endpoint.
func DecodeUpdateItxMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.UpdateItxMeetingPayload, error) {
	return func(r *http.Request) (*meetingservice.UpdateItxMeetingPayload, error) {
		var (
			body UpdateItxMeetingRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateItxMeetingRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			meetingID   string
			version     *string
			bearerToken *string
			xSync       *bool

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		{
			xSyncRaw := r.Header.Get("X-Sync")
			if xSyncRaw != "" {
				v, err2 := strconv.ParseBool(xSyncRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("x_sync", xSyncRaw, "boolean"))
				}
				xSync = &v
			}
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateItxMeetingPayload(&body, meetingID, version, bearerToken, xSync)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateItxMeetingError returns an encoder for errors returned by the
// update-itx-meeting Meeting Service endpoint.
func EncodeUpdateItxMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Conflict":
			var res *meetingservice.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxMeetingConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxMeetingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxMeetingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetItxMeetingCountResponse returns an encoder for responses returned
// by the Meeting Service get-itx-meeting-count endpoint.
func EncodeGetItxMeetingCountResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXMeetingCountResponse)
		enc := encoder(ctx, w)
		body := NewGetItxMeetingCountResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetItxMeetingCountRequest returns a decoder for requests sent to the
// Meeting Service get-itx-meeting-count endpoint.
func DecodeGetItxMeetingCountRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.GetItxMeetingCountPayload, error) {
	return func(r *http.Request) (*meetingservice.GetItxMeetingCountPayload, error) {
		var (
			version     *string
			projectUID  string
			bearerToken *string
			err         error
		)
		qp := r.URL.Query()
		versionRaw := qp.Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		projectUID = qp.Get("project_uid")
		if projectUID == "" {
			err = goa.MergeErrors(err, goa.MissingFieldError("project_uid", "query string"))
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetItxMeetingCountPayload(version, projectUID, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetItxMeetingCountError returns an encoder for errors returned by the
// get-itx-meeting-count Meeting Service endpoint.
func EncodeGetItxMeetingCountError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingCountBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingCountForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingCountInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingCountNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingCountServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxMeetingCountUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateItxRegistrantResponse returns an encoder for responses returned
// by the Meeting Service create-itx-registrant endpoint.
func EncodeCreateItxRegistrantResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXZoomMeetingRegistrant)
		enc := encoder(ctx, w)
		body := NewCreateItxRegistrantResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateItxRegistrantRequest returns a decoder for requests sent to the
// Meeting Service create-itx-registrant endpoint.
func DecodeCreateItxRegistrantRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.CreateItxRegistrantPayload, error) {
	return func(r *http.Request) (*meetingservice.CreateItxRegistrantPayload, error) {
		var (
			body CreateItxRegistrantRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateItxRegistrantRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			meetingID   string
			version     *string
			bearerToken *string

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateItxRegistrantPayload(&body, meetingID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateItxRegistrantError returns an encoder for errors returned by the
// create-itx-registrant Meeting Service endpoint.
func EncodeCreateItxRegistrantError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxRegistrantBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Conflict":
			var res *meetingservice.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxRegistrantConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxRegistrantForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxRegistrantInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxRegistrantNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxRegistrantServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxRegistrantUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetItxRegistrantResponse returns an encoder for responses returned by
// the Meeting Service get-itx-registrant endpoint.
func EncodeGetItxRegistrantResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXZoomMeetingRegistrant)
		enc := encoder(ctx, w)
		body := NewGetItxRegistrantResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetItxRegistrantRequest returns a decoder for requests sent to the
// Meeting Service get-itx-registrant endpoint.
func DecodeGetItxRegistrantRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.GetItxRegistrantPayload, error) {
	return func(r *http.Request) (*meetingservice.GetItxRegistrantPayload, error) {
		var (
			meetingID    string
			registrantID string
			version      *string
			bearerToken  *string
			err          error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		registrantID = params["registrant_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetItxRegistrantPayload(meetingID, registrantID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetItxRegistrantError returns an encoder for errors returned by the
// get-itx-registrant Meeting Service endpoint.
func EncodeGetItxRegistrantError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateItxRegistrantResponse returns an encoder for responses returned
// by the Meeting Service update-itx-registrant endpoint.
func EncodeUpdateItxRegistrantResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeUpdateItxRegistrantRequest returns a decoder for requests sent to the
// Meeting Service update-itx-registrant endpoint.
func DecodeUpdateItxRegistrantRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.UpdateItxRegistrantPayload, error) {
	return func(r *http.Request) (*meetingservice.UpdateItxRegistrantPayload, error) {
		var (
			body UpdateItxRegistrantRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateItxRegistrantRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			meetingID    string
			registrantID string
			version      *string
			bearerToken  *string

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		registrantID = params["registrant_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateItxRegistrantPayload(&body, meetingID, registrantID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateItxRegistrantError returns an encoder for errors returned by the
// update-itx-registrant Meeting Service endpoint.
func EncodeUpdateItxRegistrantError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxRegistrantBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxRegistrantForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxRegistrantInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxRegistrantNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxRegistrantServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxRegistrantUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteItxRegistrantResponse returns an encoder for responses returned
// by the Meeting Service delete-itx-registrant endpoint.
func EncodeDeleteItxRegistrantResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteItxRegistrantRequest returns a decoder for requests sent to the
// Meeting Service delete-itx-registrant endpoint.
func DecodeDeleteItxRegistrantRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.DeleteItxRegistrantPayload, error) {
	return func(r *http.Request) (*meetingservice.DeleteItxRegistrantPayload, error) {
		var (
			meetingID    string
			registrantID string
			version      *string
			bearerToken  *string
			err          error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		registrantID = params["registrant_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteItxRegistrantPayload(meetingID, registrantID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteItxRegistrantError returns an encoder for errors returned by the
// delete-itx-registrant Meeting Service endpoint.
func EncodeDeleteItxRegistrantError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxRegistrantBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxRegistrantForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxRegistrantInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxRegistrantNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxRegistrantServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxRegistrantUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetItxJoinLinkResponse returns an encoder for responses returned by
// the Meeting Service get-itx-join-link endpoint.
func EncodeGetItxJoinLinkResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXZoomMeetingJoinLink)
		enc := encoder(ctx, w)
		body := NewGetItxJoinLinkResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetItxJoinLinkRequest returns a decoder for requests sent to the
// Meeting Service get-itx-join-link endpoint.
func DecodeGetItxJoinLinkRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.GetItxJoinLinkPayload, error) {
	return func(r *http.Request) (*meetingservice.GetItxJoinLinkPayload, error) {
		var (
			meetingID   string
			version     *string
			useEmail    *bool
			userID      *string
			name        *string
			email       *string
			register    *bool
			bearerToken *string
			err         error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		qp := r.URL.Query()
		versionRaw := qp.Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		{
			useEmailRaw := qp.Get("use_email")
			if useEmailRaw != "" {
				v, err2 := strconv.ParseBool(useEmailRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("use_email", useEmailRaw, "boolean"))
				}
				useEmail = &v
			}
		}
		userIDRaw := qp.Get("user_id")
		if userIDRaw != "" {
			userID = &userIDRaw
		}
		nameRaw := qp.Get("name")
		if nameRaw != "" {
			name = &nameRaw
		}
		emailRaw := qp.Get("email")
		if emailRaw != "" {
			email = &emailRaw
		}
		if email != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("email", *email, goa.FormatEmail))
		}
		{
			registerRaw := qp.Get("register")
			if registerRaw != "" {
				v, err2 := strconv.ParseBool(registerRaw)
				if err2 != nil {
					err = goa.MergeErrors(err, goa.InvalidFieldTypeError("register", registerRaw, "boolean"))
				}
				register = &v
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetItxJoinLinkPayload(meetingID, version, useEmail, userID, name, email, register, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetItxJoinLinkError returns an encoder for errors returned by the
// get-itx-join-link Meeting Service endpoint.
func EncodeGetItxJoinLinkError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxJoinLinkBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxJoinLinkForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxJoinLinkInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxJoinLinkNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxJoinLinkServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxJoinLinkUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetItxRegistrantIcsResponse returns an encoder for responses returned
// by the Meeting Service get-itx-registrant-ics endpoint.
func EncodeGetItxRegistrantIcsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.([]byte)
		ctx = context.WithValue(ctx, goahttp.ContentTypeKey, "text/calendar")
		enc := encoder(ctx, w)
		body := res
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetItxRegistrantIcsRequest returns a decoder for requests sent to the
// Meeting Service get-itx-registrant-ics endpoint.
func DecodeGetItxRegistrantIcsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.GetItxRegistrantIcsPayload, error) {
	return func(r *http.Request) (*meetingservice.GetItxRegistrantIcsPayload, error) {
		var (
			meetingID    string
			registrantID string
			version      *string
			bearerToken  *string
			err          error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		registrantID = params["registrant_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetItxRegistrantIcsPayload(meetingID, registrantID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetItxRegistrantIcsError returns an encoder for errors returned by the
// get-itx-registrant-ics Meeting Service endpoint.
func EncodeGetItxRegistrantIcsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantIcsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantIcsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantIcsInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantIcsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantIcsServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxRegistrantIcsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeResendItxRegistrantInvitationResponse returns an encoder for responses
// returned by the Meeting Service resend-itx-registrant-invitation endpoint.
func EncodeResendItxRegistrantInvitationResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeResendItxRegistrantInvitationRequest returns a decoder for requests
// sent to the Meeting Service resend-itx-registrant-invitation endpoint.
func DecodeResendItxRegistrantInvitationRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.ResendItxRegistrantInvitationPayload, error) {
	return func(r *http.Request) (*meetingservice.ResendItxRegistrantInvitationPayload, error) {
		var (
			meetingID    string
			registrantID string
			version      *string
			bearerToken  *string
			err          error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		registrantID = params["registrant_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewResendItxRegistrantInvitationPayload(meetingID, registrantID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeResendItxRegistrantInvitationError returns an encoder for errors
// returned by the resend-itx-registrant-invitation Meeting Service endpoint.
func EncodeResendItxRegistrantInvitationError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxRegistrantInvitationBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxRegistrantInvitationForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxRegistrantInvitationInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxRegistrantInvitationNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxRegistrantInvitationServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxRegistrantInvitationUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeResendItxMeetingInvitationsResponse returns an encoder for responses
// returned by the Meeting Service resend-itx-meeting-invitations endpoint.
func EncodeResendItxMeetingInvitationsResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeResendItxMeetingInvitationsRequest returns a decoder for requests sent
// to the Meeting Service resend-itx-meeting-invitations endpoint.
func DecodeResendItxMeetingInvitationsRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.ResendItxMeetingInvitationsPayload, error) {
	return func(r *http.Request) (*meetingservice.ResendItxMeetingInvitationsPayload, error) {
		var (
			body ResendItxMeetingInvitationsRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}

		var (
			meetingID   string
			version     *string
			bearerToken *string

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewResendItxMeetingInvitationsPayload(&body, meetingID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeResendItxMeetingInvitationsError returns an encoder for errors
// returned by the resend-itx-meeting-invitations Meeting Service endpoint.
func EncodeResendItxMeetingInvitationsError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxMeetingInvitationsBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxMeetingInvitationsForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxMeetingInvitationsInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxMeetingInvitationsNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxMeetingInvitationsServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewResendItxMeetingInvitationsUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeRegisterItxCommitteeMembersResponse returns an encoder for responses
// returned by the Meeting Service register-itx-committee-members endpoint.
func EncodeRegisterItxCommitteeMembersResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeRegisterItxCommitteeMembersRequest returns a decoder for requests sent
// to the Meeting Service register-itx-committee-members endpoint.
func DecodeRegisterItxCommitteeMembersRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.RegisterItxCommitteeMembersPayload, error) {
	return func(r *http.Request) (*meetingservice.RegisterItxCommitteeMembersPayload, error) {
		var (
			meetingID   string
			version     *string
			bearerToken *string
			err         error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewRegisterItxCommitteeMembersPayload(meetingID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeRegisterItxCommitteeMembersError returns an encoder for errors
// returned by the register-itx-committee-members Meeting Service endpoint.
func EncodeRegisterItxCommitteeMembersError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegisterItxCommitteeMembersBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegisterItxCommitteeMembersForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegisterItxCommitteeMembersInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegisterItxCommitteeMembersNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegisterItxCommitteeMembersServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewRegisterItxCommitteeMembersUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateItxOccurrenceResponse returns an encoder for responses returned
// by the Meeting Service update-itx-occurrence endpoint.
func EncodeUpdateItxOccurrenceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeUpdateItxOccurrenceRequest returns a decoder for requests sent to the
// Meeting Service update-itx-occurrence endpoint.
func DecodeUpdateItxOccurrenceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.UpdateItxOccurrencePayload, error) {
	return func(r *http.Request) (*meetingservice.UpdateItxOccurrencePayload, error) {
		var (
			body UpdateItxOccurrenceRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateItxOccurrenceRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			meetingID    string
			occurrenceID string
			version      *string
			bearerToken  *string

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		occurrenceID = params["occurrence_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateItxOccurrencePayload(&body, meetingID, occurrenceID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateItxOccurrenceError returns an encoder for errors returned by the
// update-itx-occurrence Meeting Service endpoint.
func EncodeUpdateItxOccurrenceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxOccurrenceBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxOccurrenceForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxOccurrenceInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxOccurrenceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxOccurrenceServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxOccurrenceUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteItxOccurrenceResponse returns an encoder for responses returned
// by the Meeting Service delete-itx-occurrence endpoint.
func EncodeDeleteItxOccurrenceResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteItxOccurrenceRequest returns a decoder for requests sent to the
// Meeting Service delete-itx-occurrence endpoint.
func DecodeDeleteItxOccurrenceRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.DeleteItxOccurrencePayload, error) {
	return func(r *http.Request) (*meetingservice.DeleteItxOccurrencePayload, error) {
		var (
			meetingID    string
			occurrenceID string
			version      *string
			bearerToken  *string
			err          error

			params = mux.Vars(r)
		)
		meetingID = params["meeting_id"]
		occurrenceID = params["occurrence_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteItxOccurrencePayload(meetingID, occurrenceID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteItxOccurrenceError returns an encoder for errors returned by the
// delete-itx-occurrence Meeting Service endpoint.
func EncodeDeleteItxOccurrenceError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxOccurrenceBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxOccurrenceForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxOccurrenceInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxOccurrenceNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxOccurrenceServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxOccurrenceUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeCreateItxPastMeetingResponse returns an encoder for responses returned
// by the Meeting Service create-itx-past-meeting endpoint.
func EncodeCreateItxPastMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXPastZoomMeeting)
		enc := encoder(ctx, w)
		body := NewCreateItxPastMeetingResponseBody(res)
		w.WriteHeader(http.StatusCreated)
		return enc.Encode(body)
	}
}

// DecodeCreateItxPastMeetingRequest returns a decoder for requests sent to the
// Meeting Service create-itx-past-meeting endpoint.
func DecodeCreateItxPastMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.CreateItxPastMeetingPayload, error) {
	return func(r *http.Request) (*meetingservice.CreateItxPastMeetingPayload, error) {
		var (
			body CreateItxPastMeetingRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateCreateItxPastMeetingRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			version     *string
			bearerToken *string
		)
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewCreateItxPastMeetingPayload(&body, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeCreateItxPastMeetingError returns an encoder for errors returned by
// the create-itx-past-meeting Meeting Service endpoint.
func EncodeCreateItxPastMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxPastMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Conflict":
			var res *meetingservice.ConflictError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxPastMeetingConflictResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusConflict)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxPastMeetingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxPastMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxPastMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxPastMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewCreateItxPastMeetingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetItxPastMeetingResponse returns an encoder for responses returned by
// the Meeting Service get-itx-past-meeting endpoint.
func EncodeGetItxPastMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXPastZoomMeeting)
		enc := encoder(ctx, w)
		body := NewGetItxPastMeetingResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetItxPastMeetingRequest returns a decoder for requests sent to the
// Meeting Service get-itx-past-meeting endpoint.
func DecodeGetItxPastMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.GetItxPastMeetingPayload, error) {
	return func(r *http.Request) (*meetingservice.GetItxPastMeetingPayload, error) {
		var (
			pastMeetingID string
			version       *string
			bearerToken   *string
			err           error

			params = mux.Vars(r)
		)
		pastMeetingID = params["past_meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetItxPastMeetingPayload(pastMeetingID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetItxPastMeetingError returns an encoder for errors returned by the
// get-itx-past-meeting Meeting Service endpoint.
func EncodeGetItxPastMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeDeleteItxPastMeetingResponse returns an encoder for responses returned
// by the Meeting Service delete-itx-past-meeting endpoint.
func EncodeDeleteItxPastMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		w.WriteHeader(http.StatusNoContent)
		return nil
	}
}

// DecodeDeleteItxPastMeetingRequest returns a decoder for requests sent to the
// Meeting Service delete-itx-past-meeting endpoint.
func DecodeDeleteItxPastMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.DeleteItxPastMeetingPayload, error) {
	return func(r *http.Request) (*meetingservice.DeleteItxPastMeetingPayload, error) {
		var (
			pastMeetingID string
			version       *string
			bearerToken   *string
			err           error

			params = mux.Vars(r)
		)
		pastMeetingID = params["past_meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewDeleteItxPastMeetingPayload(pastMeetingID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeDeleteItxPastMeetingError returns an encoder for errors returned by
// the delete-itx-past-meeting Meeting Service endpoint.
func EncodeDeleteItxPastMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxPastMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxPastMeetingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxPastMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxPastMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxPastMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewDeleteItxPastMeetingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateItxPastMeetingResponse returns an encoder for responses returned
// by the Meeting Service update-itx-past-meeting endpoint.
func EncodeUpdateItxPastMeetingResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXPastZoomMeeting)
		enc := encoder(ctx, w)
		body := NewUpdateItxPastMeetingResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateItxPastMeetingRequest returns a decoder for requests sent to the
// Meeting Service update-itx-past-meeting endpoint.
func DecodeUpdateItxPastMeetingRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.UpdateItxPastMeetingPayload, error) {
	return func(r *http.Request) (*meetingservice.UpdateItxPastMeetingPayload, error) {
		var (
			body UpdateItxPastMeetingRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}
		err = ValidateUpdateItxPastMeetingRequestBody(&body)
		if err != nil {
			return nil, err
		}

		var (
			pastMeetingID string
			version       *string
			bearerToken   *string

			params = mux.Vars(r)
		)
		pastMeetingID = params["past_meeting_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateItxPastMeetingPayload(&body, pastMeetingID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateItxPastMeetingError returns an encoder for errors returned by
// the update-itx-past-meeting Meeting Service endpoint.
func EncodeUpdateItxPastMeetingError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeGetItxPastMeetingSummaryResponse returns an encoder for responses
// returned by the Meeting Service get-itx-past-meeting-summary endpoint.
func EncodeGetItxPastMeetingSummaryResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXPastMeetingSummary)
		enc := encoder(ctx, w)
		body := NewGetItxPastMeetingSummaryResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeGetItxPastMeetingSummaryRequest returns a decoder for requests sent to
// the Meeting Service get-itx-past-meeting-summary endpoint.
func DecodeGetItxPastMeetingSummaryRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.GetItxPastMeetingSummaryPayload, error) {
	return func(r *http.Request) (*meetingservice.GetItxPastMeetingSummaryPayload, error) {
		var (
			pastMeetingID string
			summaryID     string
			version       *string
			bearerToken   *string
			err           error

			params = mux.Vars(r)
		)
		pastMeetingID = params["past_meeting_id"]
		summaryID = params["summary_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewGetItxPastMeetingSummaryPayload(pastMeetingID, summaryID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeGetItxPastMeetingSummaryError returns an encoder for errors returned
// by the get-itx-past-meeting-summary Meeting Service endpoint.
func EncodeGetItxPastMeetingSummaryError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingSummaryBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingSummaryForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingSummaryInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingSummaryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingSummaryServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewGetItxPastMeetingSummaryUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// EncodeUpdateItxPastMeetingSummaryResponse returns an encoder for responses
// returned by the Meeting Service update-itx-past-meeting-summary endpoint.
func EncodeUpdateItxPastMeetingSummaryResponse(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder) func(context.Context, http.ResponseWriter, any) error {
	return func(ctx context.Context, w http.ResponseWriter, v any) error {
		res, _ := v.(*meetingservice.ITXPastMeetingSummary)
		enc := encoder(ctx, w)
		body := NewUpdateItxPastMeetingSummaryResponseBody(res)
		w.WriteHeader(http.StatusOK)
		return enc.Encode(body)
	}
}

// DecodeUpdateItxPastMeetingSummaryRequest returns a decoder for requests sent
// to the Meeting Service update-itx-past-meeting-summary endpoint.
func DecodeUpdateItxPastMeetingSummaryRequest(mux goahttp.Muxer, decoder func(*http.Request) goahttp.Decoder) func(*http.Request) (*meetingservice.UpdateItxPastMeetingSummaryPayload, error) {
	return func(r *http.Request) (*meetingservice.UpdateItxPastMeetingSummaryPayload, error) {
		var (
			body UpdateItxPastMeetingSummaryRequestBody
			err  error
		)
		err = decoder(r).Decode(&body)
		if err != nil {
			if errors.Is(err, io.EOF) {
				return nil, goa.MissingPayloadError()
			}
			var gerr *goa.ServiceError
			if errors.As(err, &gerr) {
				return nil, gerr
			}
			return nil, goa.DecodePayloadError(err.Error())
		}

		var (
			pastMeetingID string
			summaryID     string
			version       *string
			bearerToken   *string

			params = mux.Vars(r)
		)
		pastMeetingID = params["past_meeting_id"]
		summaryID = params["summary_id"]
		versionRaw := r.URL.Query().Get("v")
		if versionRaw != "" {
			version = &versionRaw
		}
		if version != nil {
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
		}
		bearerTokenRaw := r.Header.Get("Authorization")
		if bearerTokenRaw != "" {
			bearerToken = &bearerTokenRaw
		}
		if err != nil {
			return nil, err
		}
		payload := NewUpdateItxPastMeetingSummaryPayload(&body, pastMeetingID, summaryID, version, bearerToken)
		if payload.BearerToken != nil {
			if strings.Contains(*payload.BearerToken, " ") {
				// Remove authorization scheme prefix (e.g. "Bearer")
				cred := strings.SplitN(*payload.BearerToken, " ", 2)[1]
				payload.BearerToken = &cred
			}
		}

		return payload, nil
	}
}

// EncodeUpdateItxPastMeetingSummaryError returns an encoder for errors
// returned by the update-itx-past-meeting-summary Meeting Service endpoint.
func EncodeUpdateItxPastMeetingSummaryError(encoder func(context.Context, http.ResponseWriter) goahttp.Encoder, formatter func(ctx context.Context, err error) goahttp.Statuser) func(context.Context, http.ResponseWriter, error) error {
	encodeError := goahttp.ErrorEncoder(encoder, formatter)
	return func(ctx context.Context, w http.ResponseWriter, v error) error {
		var en goa.GoaErrorNamer
		if !errors.As(v, &en) {
			return encodeError(ctx, w, v)
		}
		switch en.GoaErrorName() {
		case "BadRequest":
			var res *meetingservice.BadRequestError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingSummaryBadRequestResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusBadRequest)
			return enc.Encode(body)
		case "Forbidden":
			var res *meetingservice.ForbiddenError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingSummaryForbiddenResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusForbidden)
			return enc.Encode(body)
		case "InternalServerError":
			var res *meetingservice.InternalServerError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingSummaryInternalServerErrorResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusInternalServerError)
			return enc.Encode(body)
		case "NotFound":
			var res *meetingservice.NotFoundError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingSummaryNotFoundResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusNotFound)
			return enc.Encode(body)
		case "ServiceUnavailable":
			var res *meetingservice.ServiceUnavailableError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingSummaryServiceUnavailableResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusServiceUnavailable)
			return enc.Encode(body)
		case "Unauthorized":
			var res *meetingservice.UnauthorizedError
			errors.As(v, &res)
			enc := encoder(ctx, w)
			var body any
			if formatter != nil {
				body = formatter(ctx, res)
			} else {
				body = NewUpdateItxPastMeetingSummaryUnauthorizedResponseBody(res)
			}
			w.Header().Set("goa-error", res.GoaErrorName())
			w.WriteHeader(http.StatusUnauthorized)
			return enc.Encode(body)
		default:
			return encodeError(ctx, w, v)
		}
	}
}

// unmarshalCommitteeRequestBodyToMeetingserviceCommittee builds a value of
// type *meetingservice.Committee from a value of type *CommitteeRequestBody.
func unmarshalCommitteeRequestBodyToMeetingserviceCommittee(v *CommitteeRequestBody) *meetingservice.Committee {
	if v == nil {
		return nil
	}
	res := &meetingservice.Committee{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	}

	return res
}

// unmarshalRecurrenceRequestBodyToMeetingserviceRecurrence builds a value of
// type *meetingservice.Recurrence from a value of type *RecurrenceRequestBody.
func unmarshalRecurrenceRequestBodyToMeetingserviceRecurrence(v *RecurrenceRequestBody) *meetingservice.Recurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Recurrence{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalMeetingserviceCommitteeToCommitteeResponseBody builds a value of type
// *CommitteeResponseBody from a value of type *meetingservice.Committee.
func marshalMeetingserviceCommitteeToCommitteeResponseBody(v *meetingservice.Committee) *CommitteeResponseBody {
	if v == nil {
		return nil
	}
	res := &CommitteeResponseBody{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	}

	return res
}

// marshalMeetingserviceRecurrenceToRecurrenceResponseBody builds a value of
// type *RecurrenceResponseBody from a value of type *meetingservice.Recurrence.
func marshalMeetingserviceRecurrenceToRecurrenceResponseBody(v *meetingservice.Recurrence) *RecurrenceResponseBody {
	if v == nil {
		return nil
	}
	res := &RecurrenceResponseBody{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalMeetingserviceITXOccurrenceToITXOccurrenceResponseBody builds a value
// of type *ITXOccurrenceResponseBody from a value of type
// *meetingservice.ITXOccurrence.
func marshalMeetingserviceITXOccurrenceToITXOccurrenceResponseBody(v *meetingservice.ITXOccurrence) *ITXOccurrenceResponseBody {
	if v == nil {
		return nil
	}
	res := &ITXOccurrenceResponseBody{
		OccurrenceID:    v.OccurrenceID,
		StartTime:       v.StartTime,
		Duration:        v.Duration,
		Status:          v.Status,
		RegistrantCount: v.RegistrantCount,
	}

	return res
}

// unmarshalITXUserRequestBodyToMeetingserviceITXUser builds a value of type
// *meetingservice.ITXUser from a value of type *ITXUserRequestBody.
func unmarshalITXUserRequestBodyToMeetingserviceITXUser(v *ITXUserRequestBody) *meetingservice.ITXUser {
	if v == nil {
		return nil
	}
	res := &meetingservice.ITXUser{
		Username:       v.Username,
		Name:           v.Name,
		Email:          v.Email,
		ProfilePicture: v.ProfilePicture,
	}

	return res
}

// marshalMeetingserviceITXUserToITXUserResponseBody builds a value of type
// *ITXUserResponseBody from a value of type *meetingservice.ITXUser.
func marshalMeetingserviceITXUserToITXUserResponseBody(v *meetingservice.ITXUser) *ITXUserResponseBody {
	if v == nil {
		return nil
	}
	res := &ITXUserResponseBody{
		Username:       v.Username,
		Name:           v.Name,
		Email:          v.Email,
		ProfilePicture: v.ProfilePicture,
	}

	return res
}

// marshalMeetingserviceZoomMeetingSummaryDetailsToZoomMeetingSummaryDetailsResponseBody
// builds a value of type *ZoomMeetingSummaryDetailsResponseBody from a value
// of type *meetingservice.ZoomMeetingSummaryDetails.
func marshalMeetingserviceZoomMeetingSummaryDetailsToZoomMeetingSummaryDetailsResponseBody(v *meetingservice.ZoomMeetingSummaryDetails) *ZoomMeetingSummaryDetailsResponseBody {
	if v == nil {
		return nil
	}
	res := &ZoomMeetingSummaryDetailsResponseBody{
		Label:   v.Label,
		Summary: v.Summary,
	}

	return res
}

// unmarshalZoomMeetingSummaryDetailsRequestBodyToMeetingserviceZoomMeetingSummaryDetails
// builds a value of type *meetingservice.ZoomMeetingSummaryDetails from a
// value of type *ZoomMeetingSummaryDetailsRequestBody.
func unmarshalZoomMeetingSummaryDetailsRequestBodyToMeetingserviceZoomMeetingSummaryDetails(v *ZoomMeetingSummaryDetailsRequestBody) *meetingservice.ZoomMeetingSummaryDetails {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomMeetingSummaryDetails{
		Label:   v.Label,
		Summary: v.Summary,
	}

	return res
}
