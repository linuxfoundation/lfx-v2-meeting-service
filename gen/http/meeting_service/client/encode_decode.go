// Code generated by goa v3.23.1, DO NOT EDIT.
//
// Meeting Service HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package client

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/url"
	"strconv"
	"strings"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goahttp "goa.design/goa/v3/http"
)

// BuildGetMeetingsRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "get-meetings" endpoint
func (c *Client) BuildGetMeetingsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingsMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meetings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingsRequest returns an encoder for requests sent to the Meeting
// Service get-meetings server.
func EncodeGetMeetingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meetings", "*meetingservice.GetMeetingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		values.Add("include_cancelled_occurrences", fmt.Sprintf("%v", p.IncludeCancelledOccurrences))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingsResponse returns a decoder for responses returned by the
// Meeting Service get-meetings endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetMeetingsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetMeetingsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetMeetingsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetMeetingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meetings", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateMeetingRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "create-meeting" endpoint
func (c *Client) BuildCreateMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateMeetingMeetingServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateMeetingRequest returns an encoder for requests sent to the
// Meeting Service create-meeting server.
func EncodeCreateMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreateMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-meeting", "*meetingservice.CreateMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreateMeetingRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-meeting", err)
		}
		return nil
	}
}

// DecodeCreateMeetingResponse returns a decoder for responses returned by the
// Meeting Service create-meeting endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCreateMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreateMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateMeetingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			res := NewCreateMeetingMeetingFullCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreateMeetingConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreateMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreateMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingBaseRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-meeting-base"
// endpoint
func (c *Client) BuildGetMeetingBaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingBasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-base", "*meetingservice.GetMeetingBasePayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingBaseMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-base", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingBaseRequest returns an encoder for requests sent to the
// Meeting Service get-meeting-base server.
func EncodeGetMeetingBaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingBasePayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-base", "*meetingservice.GetMeetingBasePayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		values.Add("include_cancelled_occurrences", fmt.Sprintf("%v", p.IncludeCancelledOccurrences))
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingBaseResponse returns a decoder for responses returned by the
// Meeting Service get-meeting-base endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetMeetingBaseResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingBaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingBaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingBaseResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingBaseInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingBaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingBaseServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-base", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingSettingsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-settings" endpoint
func (c *Client) BuildGetMeetingSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-settings", "*meetingservice.GetMeetingSettingsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingSettingsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-settings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingSettingsRequest returns an encoder for requests sent to the
// Meeting Service get-meeting-settings server.
func EncodeGetMeetingSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-settings", "*meetingservice.GetMeetingSettingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingSettingsResponse returns a decoder for responses returned by
// the Meeting Service get-meeting-settings endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetMeetingSettingsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingSettingsResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingSettingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingSettingsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingSettingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-settings", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingJoinURLRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-meeting-join-url"
// endpoint
func (c *Client) BuildGetMeetingJoinURLRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingJoinURLPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-join-url", "*meetingservice.GetMeetingJoinURLPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingJoinURLMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-join-url", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingJoinURLRequest returns an encoder for requests sent to the
// Meeting Service get-meeting-join-url server.
func EncodeGetMeetingJoinURLRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingJoinURLPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-join-url", "*meetingservice.GetMeetingJoinURLPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingJoinURLResponse returns a decoder for responses returned by
// the Meeting Service get-meeting-join-url endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetMeetingJoinURLResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - "Unauthorized" (type *meetingservice.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeGetMeetingJoinURLResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingJoinURLResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-join-url", err)
			}
			err = ValidateGetMeetingJoinURLResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-join-url", err)
			}
			res := NewGetMeetingJoinURLResultOK(&body)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingJoinURLInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-join-url", err)
			}
			err = ValidateGetMeetingJoinURLInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-join-url", err)
			}
			return nil, NewGetMeetingJoinURLInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingJoinURLNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-join-url", err)
			}
			err = ValidateGetMeetingJoinURLNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-join-url", err)
			}
			return nil, NewGetMeetingJoinURLNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingJoinURLServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-join-url", err)
			}
			err = ValidateGetMeetingJoinURLServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-join-url", err)
			}
			return nil, NewGetMeetingJoinURLServiceUnavailable(&body)
		case http.StatusUnauthorized:
			var (
				body GetMeetingJoinURLUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-join-url", err)
			}
			err = ValidateGetMeetingJoinURLUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-join-url", err)
			}
			return nil, NewGetMeetingJoinURLUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-join-url", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingBaseRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "update-meeting-base"
// endpoint
func (c *Client) BuildUpdateMeetingBaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingBasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-base", "*meetingservice.UpdateMeetingBasePayload", v)
		}
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingBaseMeetingServicePath(uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-base", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingBaseRequest returns an encoder for requests sent to the
// Meeting Service update-meeting-base server.
func EncodeUpdateMeetingBaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingBasePayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-base", "*meetingservice.UpdateMeetingBasePayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingBaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-base", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingBaseResponse returns a decoder for responses returned by
// the Meeting Service update-meeting-base endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeUpdateMeetingBaseResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingBaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingBaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			res := NewUpdateMeetingBaseMeetingBaseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingBaseBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdateMeetingBaseConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseConflict(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingBaseInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingBaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingBaseServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-base", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingSettingsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "update-meeting-settings" endpoint
func (c *Client) BuildUpdateMeetingSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-settings", "*meetingservice.UpdateMeetingSettingsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingSettingsMeetingServicePath(uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-settings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingSettingsRequest returns an encoder for requests sent to
// the Meeting Service update-meeting-settings server.
func EncodeUpdateMeetingSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-settings", "*meetingservice.UpdateMeetingSettingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingSettingsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-settings", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingSettingsResponse returns a decoder for responses returned
// by the Meeting Service update-meeting-settings endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeUpdateMeetingSettingsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			res := NewUpdateMeetingSettingsMeetingSettingsOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingSettingsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingSettingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingSettingsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingSettingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-settings", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMeetingRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "delete-meeting" endpoint
func (c *Client) BuildDeleteMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.DeleteMeetingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-meeting", "*meetingservice.DeleteMeetingPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMeetingMeetingServicePath(uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMeetingRequest returns an encoder for requests sent to the
// Meeting Service delete-meeting server.
func EncodeDeleteMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeleteMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-meeting", "*meetingservice.DeleteMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeleteMeetingResponse returns a decoder for responses returned by the
// Meeting Service delete-meeting endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDeleteMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeleteMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeleteMeetingNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeleteMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMeetingOccurrenceRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "delete-meeting-occurrence" endpoint
func (c *Client) BuildDeleteMeetingOccurrenceRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid          string
		occurrenceID string
	)
	{
		p, ok := v.(*meetingservice.DeleteMeetingOccurrencePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-meeting-occurrence", "*meetingservice.DeleteMeetingOccurrencePayload", v)
		}
		uid = p.UID
		occurrenceID = p.OccurrenceID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMeetingOccurrenceMeetingServicePath(uid, occurrenceID)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-meeting-occurrence", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMeetingOccurrenceRequest returns an encoder for requests sent to
// the Meeting Service delete-meeting-occurrence server.
func EncodeDeleteMeetingOccurrenceRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeleteMeetingOccurrencePayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-meeting-occurrence", "*meetingservice.DeleteMeetingOccurrencePayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeleteMeetingOccurrenceResponse returns a decoder for responses
// returned by the Meeting Service delete-meeting-occurrence endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeDeleteMeetingOccurrenceResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeleteMeetingOccurrenceResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteMeetingOccurrenceBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-occurrence", err)
			}
			err = ValidateDeleteMeetingOccurrenceBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-occurrence", err)
			}
			return nil, NewDeleteMeetingOccurrenceBadRequest(&body)
		case http.StatusConflict:
			var (
				body DeleteMeetingOccurrenceConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-occurrence", err)
			}
			err = ValidateDeleteMeetingOccurrenceConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-occurrence", err)
			}
			return nil, NewDeleteMeetingOccurrenceConflict(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteMeetingOccurrenceInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-occurrence", err)
			}
			err = ValidateDeleteMeetingOccurrenceInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-occurrence", err)
			}
			return nil, NewDeleteMeetingOccurrenceInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeleteMeetingOccurrenceNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-occurrence", err)
			}
			err = ValidateDeleteMeetingOccurrenceNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-occurrence", err)
			}
			return nil, NewDeleteMeetingOccurrenceNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeleteMeetingOccurrenceServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-occurrence", err)
			}
			err = ValidateDeleteMeetingOccurrenceServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-occurrence", err)
			}
			return nil, NewDeleteMeetingOccurrenceServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-meeting-occurrence", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingRegistrantsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-registrants" endpoint
func (c *Client) BuildGetMeetingRegistrantsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingRegistrantsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrants", "*meetingservice.GetMeetingRegistrantsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingRegistrantsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-registrants", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingRegistrantsRequest returns an encoder for requests sent to
// the Meeting Service get-meeting-registrants server.
func EncodeGetMeetingRegistrantsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingRegistrantsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrants", "*meetingservice.GetMeetingRegistrantsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingRegistrantsResponse returns a decoder for responses returned
// by the Meeting Service get-meeting-registrants endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeGetMeetingRegistrantsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingRegistrantsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingRegistrantsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetMeetingRegistrantsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingRegistrantsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingRegistrantsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingRegistrantsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-registrants", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "create-meeting-registrant" endpoint
func (c *Client) BuildCreateMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
	)
	{
		p, ok := v.(*meetingservice.CreateMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "create-meeting-registrant", "*meetingservice.CreateMeetingRegistrantPayload", v)
		}
		meetingUID = p.MeetingUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateMeetingRegistrantMeetingServicePath(meetingUID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service create-meeting-registrant server.
func EncodeCreateMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreateMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-meeting-registrant", "*meetingservice.CreateMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreateMeetingRegistrantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-meeting-registrant", err)
		}
		return nil
	}
}

// DecodeCreateMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service create-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeCreateMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreateMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			res := NewCreateMeetingRegistrantRegistrantCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreateMeetingRegistrantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreateMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body CreateMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreateMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-registrant" endpoint
func (c *Client) BuildGetMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrant", "*meetingservice.GetMeetingRegistrantPayload", v)
		}
		if p.MeetingUID != nil {
			meetingUID = *p.MeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service get-meeting-registrant server.
func EncodeGetMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrant", "*meetingservice.GetMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingRegistrantResponse returns a decoder for responses returned
// by the Meeting Service get-meeting-registrant endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetMeetingRegistrantResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingRegistrantResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "update-meeting-registrant" endpoint
func (c *Client) BuildUpdateMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-registrant", "*meetingservice.UpdateMeetingRegistrantPayload", v)
		}
		meetingUID = p.MeetingUID
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service update-meeting-registrant server.
func EncodeUpdateMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-registrant", "*meetingservice.UpdateMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingRegistrantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-registrant", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service update-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeUpdateMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			res := NewUpdateMeetingRegistrantRegistrantOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdateMeetingRegistrantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "delete-meeting-registrant" endpoint
func (c *Client) BuildDeleteMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.DeleteMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-meeting-registrant", "*meetingservice.DeleteMeetingRegistrantPayload", v)
		}
		if p.MeetingUID != nil {
			meetingUID = *p.MeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service delete-meeting-registrant server.
func EncodeDeleteMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeleteMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-meeting-registrant", "*meetingservice.DeleteMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeleteMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service delete-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeDeleteMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeleteMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantBadRequest(&body)
		case http.StatusConflict:
			var (
				body DeleteMeetingRegistrantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeleteMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeleteMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildResendMeetingRegistrantInvitationRequest instantiates a HTTP request
// object with method and path set to call the "Meeting Service" service
// "resend-meeting-registrant-invitation" endpoint
func (c *Client) BuildResendMeetingRegistrantInvitationRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.ResendMeetingRegistrantInvitationPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "resend-meeting-registrant-invitation", "*meetingservice.ResendMeetingRegistrantInvitationPayload", v)
		}
		if p.MeetingUID != nil {
			meetingUID = *p.MeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ResendMeetingRegistrantInvitationMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "resend-meeting-registrant-invitation", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeResendMeetingRegistrantInvitationRequest returns an encoder for
// requests sent to the Meeting Service resend-meeting-registrant-invitation
// server.
func EncodeResendMeetingRegistrantInvitationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.ResendMeetingRegistrantInvitationPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "resend-meeting-registrant-invitation", "*meetingservice.ResendMeetingRegistrantInvitationPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeResendMeetingRegistrantInvitationResponse returns a decoder for
// responses returned by the Meeting Service
// resend-meeting-registrant-invitation endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeResendMeetingRegistrantInvitationResponse may return the following
// errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeResendMeetingRegistrantInvitationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body ResendMeetingRegistrantInvitationBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "resend-meeting-registrant-invitation", err)
			}
			err = ValidateResendMeetingRegistrantInvitationBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "resend-meeting-registrant-invitation", err)
			}
			return nil, NewResendMeetingRegistrantInvitationBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body ResendMeetingRegistrantInvitationInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "resend-meeting-registrant-invitation", err)
			}
			err = ValidateResendMeetingRegistrantInvitationInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "resend-meeting-registrant-invitation", err)
			}
			return nil, NewResendMeetingRegistrantInvitationInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body ResendMeetingRegistrantInvitationNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "resend-meeting-registrant-invitation", err)
			}
			err = ValidateResendMeetingRegistrantInvitationNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "resend-meeting-registrant-invitation", err)
			}
			return nil, NewResendMeetingRegistrantInvitationNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body ResendMeetingRegistrantInvitationServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "resend-meeting-registrant-invitation", err)
			}
			err = ValidateResendMeetingRegistrantInvitationServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "resend-meeting-registrant-invitation", err)
			}
			return nil, NewResendMeetingRegistrantInvitationServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "resend-meeting-registrant-invitation", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateMeetingRsvpRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "create-meeting-rsvp"
// endpoint
func (c *Client) BuildCreateMeetingRsvpRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
	)
	{
		p, ok := v.(*meetingservice.CreateMeetingRsvpPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "create-meeting-rsvp", "*meetingservice.CreateMeetingRsvpPayload", v)
		}
		meetingUID = p.MeetingUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateMeetingRsvpMeetingServicePath(meetingUID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-meeting-rsvp", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateMeetingRsvpRequest returns an encoder for requests sent to the
// Meeting Service create-meeting-rsvp server.
func EncodeCreateMeetingRsvpRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreateMeetingRsvpPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-meeting-rsvp", "*meetingservice.CreateMeetingRsvpPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreateMeetingRsvpRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-meeting-rsvp", err)
		}
		return nil
	}
}

// DecodeCreateMeetingRsvpResponse returns a decoder for responses returned by
// the Meeting Service create-meeting-rsvp endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeCreateMeetingRsvpResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreateMeetingRsvpResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateMeetingRsvpResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-rsvp", err)
			}
			err = ValidateCreateMeetingRsvpResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-rsvp", err)
			}
			res := NewCreateMeetingRsvpRSVPResponseCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateMeetingRsvpBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-rsvp", err)
			}
			err = ValidateCreateMeetingRsvpBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-rsvp", err)
			}
			return nil, NewCreateMeetingRsvpBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body CreateMeetingRsvpInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-rsvp", err)
			}
			err = ValidateCreateMeetingRsvpInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-rsvp", err)
			}
			return nil, NewCreateMeetingRsvpInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body CreateMeetingRsvpNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-rsvp", err)
			}
			err = ValidateCreateMeetingRsvpNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-rsvp", err)
			}
			return nil, NewCreateMeetingRsvpNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreateMeetingRsvpServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-rsvp", err)
			}
			err = ValidateCreateMeetingRsvpServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-rsvp", err)
			}
			return nil, NewCreateMeetingRsvpServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-meeting-rsvp", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingRsvpsRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-meeting-rsvps"
// endpoint
func (c *Client) BuildGetMeetingRsvpsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingRsvpsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-rsvps", "*meetingservice.GetMeetingRsvpsPayload", v)
		}
		meetingUID = p.MeetingUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingRsvpsMeetingServicePath(meetingUID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-rsvps", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingRsvpsRequest returns an encoder for requests sent to the
// Meeting Service get-meeting-rsvps server.
func EncodeGetMeetingRsvpsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingRsvpsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-rsvps", "*meetingservice.GetMeetingRsvpsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingRsvpsResponse returns a decoder for responses returned by
// the Meeting Service get-meeting-rsvps endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeGetMeetingRsvpsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingRsvpsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingRsvpsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-rsvps", err)
			}
			err = ValidateGetMeetingRsvpsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-rsvps", err)
			}
			res := NewGetMeetingRsvpsRSVPListResultOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetMeetingRsvpsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-rsvps", err)
			}
			err = ValidateGetMeetingRsvpsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-rsvps", err)
			}
			return nil, NewGetMeetingRsvpsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetMeetingRsvpsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-rsvps", err)
			}
			err = ValidateGetMeetingRsvpsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-rsvps", err)
			}
			return nil, NewGetMeetingRsvpsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingRsvpsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-rsvps", err)
			}
			err = ValidateGetMeetingRsvpsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-rsvps", err)
			}
			return nil, NewGetMeetingRsvpsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingRsvpsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-rsvps", err)
			}
			err = ValidateGetMeetingRsvpsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-rsvps", err)
			}
			return nil, NewGetMeetingRsvpsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-rsvps", resp.StatusCode, string(body))
		}
	}
}

// BuildZoomWebhookRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "zoom-webhook" endpoint
func (c *Client) BuildZoomWebhookRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ZoomWebhookMeetingServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "zoom-webhook", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeZoomWebhookRequest returns an encoder for requests sent to the Meeting
// Service zoom-webhook server.
func EncodeZoomWebhookRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.ZoomWebhookPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "zoom-webhook", "*meetingservice.ZoomWebhookPayload", v)
		}
		{
			head := p.ZoomSignature
			req.Header.Set("x-zm-signature", head)
		}
		{
			head := p.ZoomTimestamp
			req.Header.Set("x-zm-request-timestamp", head)
		}
		body := NewZoomWebhookRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "zoom-webhook", err)
		}
		return nil
	}
}

// DecodeZoomWebhookResponse returns a decoder for responses returned by the
// Meeting Service zoom-webhook endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeZoomWebhookResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "Unauthorized" (type *meetingservice.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeZoomWebhookResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ZoomWebhookResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "zoom-webhook", err)
			}
			res := NewZoomWebhookResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ZoomWebhookBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "zoom-webhook", err)
			}
			err = ValidateZoomWebhookBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "zoom-webhook", err)
			}
			return nil, NewZoomWebhookBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body ZoomWebhookInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "zoom-webhook", err)
			}
			err = ValidateZoomWebhookInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "zoom-webhook", err)
			}
			return nil, NewZoomWebhookInternalServerError(&body)
		case http.StatusUnauthorized:
			var (
				body ZoomWebhookUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "zoom-webhook", err)
			}
			err = ValidateZoomWebhookUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "zoom-webhook", err)
			}
			return nil, NewZoomWebhookUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "zoom-webhook", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingsRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-past-meetings"
// endpoint
func (c *Client) BuildGetPastMeetingsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingsMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meetings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingsRequest returns an encoder for requests sent to the
// Meeting Service get-past-meetings server.
func EncodeGetPastMeetingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meetings", "*meetingservice.GetPastMeetingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingsResponse returns a decoder for responses returned by
// the Meeting Service get-past-meetings endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeGetPastMeetingsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meetings", err)
			}
			err = ValidateGetPastMeetingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meetings", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetPastMeetingsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetPastMeetingsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meetings", err)
			}
			err = ValidateGetPastMeetingsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meetings", err)
			}
			return nil, NewGetPastMeetingsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meetings", err)
			}
			err = ValidateGetPastMeetingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meetings", err)
			}
			return nil, NewGetPastMeetingsInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meetings", err)
			}
			err = ValidateGetPastMeetingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meetings", err)
			}
			return nil, NewGetPastMeetingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meetings", resp.StatusCode, string(body))
		}
	}
}

// BuildCreatePastMeetingRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "create-past-meeting"
// endpoint
func (c *Client) BuildCreatePastMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreatePastMeetingMeetingServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-past-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreatePastMeetingRequest returns an encoder for requests sent to the
// Meeting Service create-past-meeting server.
func EncodeCreatePastMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreatePastMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-past-meeting", "*meetingservice.CreatePastMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreatePastMeetingRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-past-meeting", err)
		}
		return nil
	}
}

// DecodeCreatePastMeetingResponse returns a decoder for responses returned by
// the Meeting Service create-past-meeting endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeCreatePastMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreatePastMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreatePastMeetingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			res := NewCreatePastMeetingPastMeetingCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreatePastMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			return nil, NewCreatePastMeetingBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreatePastMeetingConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			return nil, NewCreatePastMeetingConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreatePastMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			return nil, NewCreatePastMeetingInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreatePastMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			return nil, NewCreatePastMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-past-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-past-meeting"
// endpoint
func (c *Client) BuildGetPastMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting", "*meetingservice.GetPastMeetingPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingRequest returns an encoder for requests sent to the
// Meeting Service get-past-meeting server.
func EncodeGetPastMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting", "*meetingservice.GetPastMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingResponse returns a decoder for responses returned by the
// Meeting Service get-past-meeting endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetPastMeetingResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting", err)
			}
			err = ValidateGetPastMeetingResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetPastMeetingResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting", err)
			}
			err = ValidateGetPastMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting", err)
			}
			return nil, NewGetPastMeetingInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting", err)
			}
			err = ValidateGetPastMeetingNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting", err)
			}
			return nil, NewGetPastMeetingNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting", err)
			}
			err = ValidateGetPastMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting", err)
			}
			return nil, NewGetPastMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildDeletePastMeetingRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "delete-past-meeting"
// endpoint
func (c *Client) BuildDeletePastMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.DeletePastMeetingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting", "*meetingservice.DeletePastMeetingPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeletePastMeetingMeetingServicePath(uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-past-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeletePastMeetingRequest returns an encoder for requests sent to the
// Meeting Service delete-past-meeting server.
func EncodeDeletePastMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeletePastMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting", "*meetingservice.DeletePastMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeletePastMeetingResponse returns a decoder for responses returned by
// the Meeting Service delete-past-meeting endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeDeletePastMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeletePastMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeletePastMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting", err)
			}
			err = ValidateDeletePastMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting", err)
			}
			return nil, NewDeletePastMeetingBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeletePastMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting", err)
			}
			err = ValidateDeletePastMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting", err)
			}
			return nil, NewDeletePastMeetingInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeletePastMeetingNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting", err)
			}
			err = ValidateDeletePastMeetingNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting", err)
			}
			return nil, NewDeletePastMeetingNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeletePastMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting", err)
			}
			err = ValidateDeletePastMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting", err)
			}
			return nil, NewDeletePastMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-past-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingParticipantsRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "get-past-meeting-participants" endpoint
func (c *Client) BuildGetPastMeetingParticipantsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingParticipantsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-participants", "*meetingservice.GetPastMeetingParticipantsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingParticipantsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-participants", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingParticipantsRequest returns an encoder for requests sent
// to the Meeting Service get-past-meeting-participants server.
func EncodeGetPastMeetingParticipantsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingParticipantsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-participants", "*meetingservice.GetPastMeetingParticipantsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingParticipantsResponse returns a decoder for responses
// returned by the Meeting Service get-past-meeting-participants endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeGetPastMeetingParticipantsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingParticipantsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingParticipantsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participants", err)
			}
			err = ValidateGetPastMeetingParticipantsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participants", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetPastMeetingParticipantsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingParticipantsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participants", err)
			}
			err = ValidateGetPastMeetingParticipantsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participants", err)
			}
			return nil, NewGetPastMeetingParticipantsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingParticipantsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participants", err)
			}
			err = ValidateGetPastMeetingParticipantsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participants", err)
			}
			return nil, NewGetPastMeetingParticipantsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingParticipantsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participants", err)
			}
			err = ValidateGetPastMeetingParticipantsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participants", err)
			}
			return nil, NewGetPastMeetingParticipantsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-participants", resp.StatusCode, string(body))
		}
	}
}

// BuildCreatePastMeetingParticipantRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "create-past-meeting-participant" endpoint
func (c *Client) BuildCreatePastMeetingParticipantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.CreatePastMeetingParticipantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "create-past-meeting-participant", "*meetingservice.CreatePastMeetingParticipantPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreatePastMeetingParticipantMeetingServicePath(uid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-past-meeting-participant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreatePastMeetingParticipantRequest returns an encoder for requests
// sent to the Meeting Service create-past-meeting-participant server.
func EncodeCreatePastMeetingParticipantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreatePastMeetingParticipantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-past-meeting-participant", "*meetingservice.CreatePastMeetingParticipantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreatePastMeetingParticipantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-past-meeting-participant", err)
		}
		return nil
	}
}

// DecodeCreatePastMeetingParticipantResponse returns a decoder for responses
// returned by the Meeting Service create-past-meeting-participant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeCreatePastMeetingParticipantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreatePastMeetingParticipantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreatePastMeetingParticipantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			res := NewCreatePastMeetingParticipantPastMeetingParticipantCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreatePastMeetingParticipantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreatePastMeetingParticipantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreatePastMeetingParticipantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body CreatePastMeetingParticipantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreatePastMeetingParticipantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-past-meeting-participant", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingParticipantRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "get-past-meeting-participant" endpoint
func (c *Client) BuildGetPastMeetingParticipantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingParticipantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-participant", "*meetingservice.GetPastMeetingParticipantPayload", v)
		}
		if p.PastMeetingUID != nil {
			pastMeetingUID = *p.PastMeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingParticipantMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-participant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingParticipantRequest returns an encoder for requests sent
// to the Meeting Service get-past-meeting-participant server.
func EncodeGetPastMeetingParticipantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingParticipantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-participant", "*meetingservice.GetPastMeetingParticipantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingParticipantResponse returns a decoder for responses
// returned by the Meeting Service get-past-meeting-participant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeGetPastMeetingParticipantResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingParticipantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingParticipantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participant", err)
			}
			err = ValidateGetPastMeetingParticipantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participant", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetPastMeetingParticipantResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingParticipantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participant", err)
			}
			err = ValidateGetPastMeetingParticipantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participant", err)
			}
			return nil, NewGetPastMeetingParticipantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingParticipantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participant", err)
			}
			err = ValidateGetPastMeetingParticipantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participant", err)
			}
			return nil, NewGetPastMeetingParticipantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingParticipantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participant", err)
			}
			err = ValidateGetPastMeetingParticipantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participant", err)
			}
			return nil, NewGetPastMeetingParticipantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-participant", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdatePastMeetingParticipantRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "update-past-meeting-participant" endpoint
func (c *Client) BuildUpdatePastMeetingParticipantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.UpdatePastMeetingParticipantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-past-meeting-participant", "*meetingservice.UpdatePastMeetingParticipantPayload", v)
		}
		pastMeetingUID = p.PastMeetingUID
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdatePastMeetingParticipantMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-past-meeting-participant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdatePastMeetingParticipantRequest returns an encoder for requests
// sent to the Meeting Service update-past-meeting-participant server.
func EncodeUpdatePastMeetingParticipantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdatePastMeetingParticipantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-past-meeting-participant", "*meetingservice.UpdatePastMeetingParticipantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdatePastMeetingParticipantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-past-meeting-participant", err)
		}
		return nil
	}
}

// DecodeUpdatePastMeetingParticipantResponse returns a decoder for responses
// returned by the Meeting Service update-past-meeting-participant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeUpdatePastMeetingParticipantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdatePastMeetingParticipantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdatePastMeetingParticipantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			res := NewUpdatePastMeetingParticipantPastMeetingParticipantOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdatePastMeetingParticipantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdatePastMeetingParticipantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body UpdatePastMeetingParticipantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdatePastMeetingParticipantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdatePastMeetingParticipantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-past-meeting-participant", resp.StatusCode, string(body))
		}
	}
}

// BuildDeletePastMeetingParticipantRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "delete-past-meeting-participant" endpoint
func (c *Client) BuildDeletePastMeetingParticipantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.DeletePastMeetingParticipantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting-participant", "*meetingservice.DeletePastMeetingParticipantPayload", v)
		}
		if p.PastMeetingUID != nil {
			pastMeetingUID = *p.PastMeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeletePastMeetingParticipantMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-past-meeting-participant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeletePastMeetingParticipantRequest returns an encoder for requests
// sent to the Meeting Service delete-past-meeting-participant server.
func EncodeDeletePastMeetingParticipantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeletePastMeetingParticipantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting-participant", "*meetingservice.DeletePastMeetingParticipantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeletePastMeetingParticipantResponse returns a decoder for responses
// returned by the Meeting Service delete-past-meeting-participant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeDeletePastMeetingParticipantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeletePastMeetingParticipantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeletePastMeetingParticipantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-participant", err)
			}
			err = ValidateDeletePastMeetingParticipantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-participant", err)
			}
			return nil, NewDeletePastMeetingParticipantBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeletePastMeetingParticipantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-participant", err)
			}
			err = ValidateDeletePastMeetingParticipantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-participant", err)
			}
			return nil, NewDeletePastMeetingParticipantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeletePastMeetingParticipantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-participant", err)
			}
			err = ValidateDeletePastMeetingParticipantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-participant", err)
			}
			return nil, NewDeletePastMeetingParticipantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeletePastMeetingParticipantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-participant", err)
			}
			err = ValidateDeletePastMeetingParticipantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-participant", err)
			}
			return nil, NewDeletePastMeetingParticipantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-past-meeting-participant", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingSummariesRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-past-meeting-summaries" endpoint
func (c *Client) BuildGetPastMeetingSummariesRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingSummariesPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-summaries", "*meetingservice.GetPastMeetingSummariesPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingSummariesMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-summaries", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingSummariesRequest returns an encoder for requests sent to
// the Meeting Service get-past-meeting-summaries server.
func EncodeGetPastMeetingSummariesRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingSummariesPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-summaries", "*meetingservice.GetPastMeetingSummariesPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingSummariesResponse returns a decoder for responses
// returned by the Meeting Service get-past-meeting-summaries endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeGetPastMeetingSummariesResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingSummariesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingSummariesResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-summaries", err)
			}
			err = ValidateGetPastMeetingSummariesResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-summaries", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetPastMeetingSummariesResultOK(&body, cacheControl)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingSummariesInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-summaries", err)
			}
			err = ValidateGetPastMeetingSummariesInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-summaries", err)
			}
			return nil, NewGetPastMeetingSummariesInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingSummariesNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-summaries", err)
			}
			err = ValidateGetPastMeetingSummariesNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-summaries", err)
			}
			return nil, NewGetPastMeetingSummariesNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingSummariesServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-summaries", err)
			}
			err = ValidateGetPastMeetingSummariesServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-summaries", err)
			}
			return nil, NewGetPastMeetingSummariesServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-summaries", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingSummaryRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-past-meeting-summary" endpoint
func (c *Client) BuildGetPastMeetingSummaryRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		summaryUID     string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingSummaryPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-summary", "*meetingservice.GetPastMeetingSummaryPayload", v)
		}
		pastMeetingUID = p.PastMeetingUID
		summaryUID = p.SummaryUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingSummaryMeetingServicePath(pastMeetingUID, summaryUID)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-summary", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingSummaryRequest returns an encoder for requests sent to
// the Meeting Service get-past-meeting-summary server.
func EncodeGetPastMeetingSummaryRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingSummaryPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-summary", "*meetingservice.GetPastMeetingSummaryPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingSummaryResponse returns a decoder for responses returned
// by the Meeting Service get-past-meeting-summary endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeGetPastMeetingSummaryResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingSummaryResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingSummaryResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-summary", err)
			}
			err = ValidateGetPastMeetingSummaryResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-summary", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetPastMeetingSummaryResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingSummaryInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-summary", err)
			}
			err = ValidateGetPastMeetingSummaryInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-summary", err)
			}
			return nil, NewGetPastMeetingSummaryInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingSummaryNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-summary", err)
			}
			err = ValidateGetPastMeetingSummaryNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-summary", err)
			}
			return nil, NewGetPastMeetingSummaryNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingSummaryServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-summary", err)
			}
			err = ValidateGetPastMeetingSummaryServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-summary", err)
			}
			return nil, NewGetPastMeetingSummaryServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-summary", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdatePastMeetingSummaryRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "update-past-meeting-summary" endpoint
func (c *Client) BuildUpdatePastMeetingSummaryRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		summaryUID     string
	)
	{
		p, ok := v.(*meetingservice.UpdatePastMeetingSummaryPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-past-meeting-summary", "*meetingservice.UpdatePastMeetingSummaryPayload", v)
		}
		pastMeetingUID = p.PastMeetingUID
		summaryUID = p.SummaryUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdatePastMeetingSummaryMeetingServicePath(pastMeetingUID, summaryUID)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-past-meeting-summary", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdatePastMeetingSummaryRequest returns an encoder for requests sent
// to the Meeting Service update-past-meeting-summary server.
func EncodeUpdatePastMeetingSummaryRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdatePastMeetingSummaryPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-past-meeting-summary", "*meetingservice.UpdatePastMeetingSummaryPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdatePastMeetingSummaryRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-past-meeting-summary", err)
		}
		return nil
	}
}

// DecodeUpdatePastMeetingSummaryResponse returns a decoder for responses
// returned by the Meeting Service update-past-meeting-summary endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeUpdatePastMeetingSummaryResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdatePastMeetingSummaryResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdatePastMeetingSummaryResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-summary", err)
			}
			err = ValidateUpdatePastMeetingSummaryResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-summary", err)
			}
			res := NewUpdatePastMeetingSummaryPastMeetingSummaryOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdatePastMeetingSummaryBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-summary", err)
			}
			err = ValidateUpdatePastMeetingSummaryBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-summary", err)
			}
			return nil, NewUpdatePastMeetingSummaryBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body UpdatePastMeetingSummaryInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-summary", err)
			}
			err = ValidateUpdatePastMeetingSummaryInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-summary", err)
			}
			return nil, NewUpdatePastMeetingSummaryInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdatePastMeetingSummaryNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-summary", err)
			}
			err = ValidateUpdatePastMeetingSummaryNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-summary", err)
			}
			return nil, NewUpdatePastMeetingSummaryNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdatePastMeetingSummaryServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-summary", err)
			}
			err = ValidateUpdatePastMeetingSummaryServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-summary", err)
			}
			return nil, NewUpdatePastMeetingSummaryServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-past-meeting-summary", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateMeetingAttachmentRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "create-meeting-attachment" endpoint
func (c *Client) BuildCreateMeetingAttachmentRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
	)
	{
		p, ok := v.(*meetingservice.CreateMeetingAttachmentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "create-meeting-attachment", "*meetingservice.CreateMeetingAttachmentPayload", v)
		}
		meetingUID = p.MeetingUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateMeetingAttachmentMeetingServicePath(meetingUID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-meeting-attachment", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateMeetingAttachmentRequest returns an encoder for requests sent to
// the Meeting Service create-meeting-attachment server.
func EncodeCreateMeetingAttachmentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreateMeetingAttachmentPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-meeting-attachment", "*meetingservice.CreateMeetingAttachmentPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		if err := encoder(req).Encode(p); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-meeting-attachment", err)
		}
		return nil
	}
}

// NewMeetingServiceCreateMeetingAttachmentEncoder returns an encoder to encode
// the multipart request for the "Meeting Service" service
// "create-meeting-attachment" endpoint.
func NewMeetingServiceCreateMeetingAttachmentEncoder(encoderFn MeetingServiceCreateMeetingAttachmentEncoderFunc) func(r *http.Request) goahttp.Encoder {
	return func(r *http.Request) goahttp.Encoder {
		body := &bytes.Buffer{}
		mw := multipart.NewWriter(body)
		return goahttp.EncodingFunc(func(v any) error {
			p := v.(*meetingservice.CreateMeetingAttachmentPayload)
			if err := encoderFn(mw, p); err != nil {
				return err
			}
			r.Body = io.NopCloser(body)
			r.Header.Set("Content-Type", mw.FormDataContentType())
			return mw.Close()
		})
	}
}

// DecodeCreateMeetingAttachmentResponse returns a decoder for responses
// returned by the Meeting Service create-meeting-attachment endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeCreateMeetingAttachmentResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreateMeetingAttachmentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateMeetingAttachmentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-attachment", err)
			}
			err = ValidateCreateMeetingAttachmentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-attachment", err)
			}
			res := NewCreateMeetingAttachmentMeetingAttachmentCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateMeetingAttachmentBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-attachment", err)
			}
			err = ValidateCreateMeetingAttachmentBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-attachment", err)
			}
			return nil, NewCreateMeetingAttachmentBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body CreateMeetingAttachmentInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-attachment", err)
			}
			err = ValidateCreateMeetingAttachmentInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-attachment", err)
			}
			return nil, NewCreateMeetingAttachmentInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body CreateMeetingAttachmentNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-attachment", err)
			}
			err = ValidateCreateMeetingAttachmentNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-attachment", err)
			}
			return nil, NewCreateMeetingAttachmentNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreateMeetingAttachmentServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-attachment", err)
			}
			err = ValidateCreateMeetingAttachmentServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-attachment", err)
			}
			return nil, NewCreateMeetingAttachmentServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-meeting-attachment", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingAttachmentRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-attachment" endpoint
func (c *Client) BuildGetMeetingAttachmentRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingAttachmentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-attachment", "*meetingservice.GetMeetingAttachmentPayload", v)
		}
		meetingUID = p.MeetingUID
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingAttachmentMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-attachment", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingAttachmentRequest returns an encoder for requests sent to
// the Meeting Service get-meeting-attachment server.
func EncodeGetMeetingAttachmentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingAttachmentPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-attachment", "*meetingservice.GetMeetingAttachmentPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingAttachmentResponse returns a decoder for responses returned
// by the Meeting Service get-meeting-attachment endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetMeetingAttachmentResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingAttachmentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []byte
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment", err)
			}
			return body, nil
		case http.StatusBadRequest:
			var (
				body GetMeetingAttachmentBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment", err)
			}
			err = ValidateGetMeetingAttachmentBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment", err)
			}
			return nil, NewGetMeetingAttachmentBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetMeetingAttachmentInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment", err)
			}
			err = ValidateGetMeetingAttachmentInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment", err)
			}
			return nil, NewGetMeetingAttachmentInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingAttachmentNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment", err)
			}
			err = ValidateGetMeetingAttachmentNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment", err)
			}
			return nil, NewGetMeetingAttachmentNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingAttachmentServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment", err)
			}
			err = ValidateGetMeetingAttachmentServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment", err)
			}
			return nil, NewGetMeetingAttachmentServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-attachment", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingAttachmentMetadataRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "get-meeting-attachment-metadata" endpoint
func (c *Client) BuildGetMeetingAttachmentMetadataRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingAttachmentMetadataPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-attachment-metadata", "*meetingservice.GetMeetingAttachmentMetadataPayload", v)
		}
		meetingUID = p.MeetingUID
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingAttachmentMetadataMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-attachment-metadata", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingAttachmentMetadataRequest returns an encoder for requests
// sent to the Meeting Service get-meeting-attachment-metadata server.
func EncodeGetMeetingAttachmentMetadataRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingAttachmentMetadataPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-attachment-metadata", "*meetingservice.GetMeetingAttachmentMetadataPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingAttachmentMetadataResponse returns a decoder for responses
// returned by the Meeting Service get-meeting-attachment-metadata endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeGetMeetingAttachmentMetadataResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingAttachmentMetadataResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingAttachmentMetadataResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			err = ValidateGetMeetingAttachmentMetadataResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			res := NewGetMeetingAttachmentMetadataMeetingAttachmentOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetMeetingAttachmentMetadataBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			err = ValidateGetMeetingAttachmentMetadataBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			return nil, NewGetMeetingAttachmentMetadataBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetMeetingAttachmentMetadataInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			err = ValidateGetMeetingAttachmentMetadataInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			return nil, NewGetMeetingAttachmentMetadataInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingAttachmentMetadataNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			err = ValidateGetMeetingAttachmentMetadataNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			return nil, NewGetMeetingAttachmentMetadataNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingAttachmentMetadataServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			err = ValidateGetMeetingAttachmentMetadataServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-attachment-metadata", err)
			}
			return nil, NewGetMeetingAttachmentMetadataServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-attachment-metadata", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMeetingAttachmentRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "delete-meeting-attachment" endpoint
func (c *Client) BuildDeleteMeetingAttachmentRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.DeleteMeetingAttachmentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-meeting-attachment", "*meetingservice.DeleteMeetingAttachmentPayload", v)
		}
		meetingUID = p.MeetingUID
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMeetingAttachmentMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-meeting-attachment", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMeetingAttachmentRequest returns an encoder for requests sent to
// the Meeting Service delete-meeting-attachment server.
func EncodeDeleteMeetingAttachmentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeleteMeetingAttachmentPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-meeting-attachment", "*meetingservice.DeleteMeetingAttachmentPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeleteMeetingAttachmentResponse returns a decoder for responses
// returned by the Meeting Service delete-meeting-attachment endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeDeleteMeetingAttachmentResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeleteMeetingAttachmentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteMeetingAttachmentBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-attachment", err)
			}
			err = ValidateDeleteMeetingAttachmentBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-attachment", err)
			}
			return nil, NewDeleteMeetingAttachmentBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteMeetingAttachmentInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-attachment", err)
			}
			err = ValidateDeleteMeetingAttachmentInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-attachment", err)
			}
			return nil, NewDeleteMeetingAttachmentInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeleteMeetingAttachmentNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-attachment", err)
			}
			err = ValidateDeleteMeetingAttachmentNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-attachment", err)
			}
			return nil, NewDeleteMeetingAttachmentNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeleteMeetingAttachmentServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-attachment", err)
			}
			err = ValidateDeleteMeetingAttachmentServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-attachment", err)
			}
			return nil, NewDeleteMeetingAttachmentServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-meeting-attachment", resp.StatusCode, string(body))
		}
	}
}

// BuildCreatePastMeetingAttachmentRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "create-past-meeting-attachment" endpoint
func (c *Client) BuildCreatePastMeetingAttachmentRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
	)
	{
		p, ok := v.(*meetingservice.CreatePastMeetingAttachmentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "create-past-meeting-attachment", "*meetingservice.CreatePastMeetingAttachmentPayload", v)
		}
		pastMeetingUID = p.PastMeetingUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreatePastMeetingAttachmentMeetingServicePath(pastMeetingUID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-past-meeting-attachment", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreatePastMeetingAttachmentRequest returns an encoder for requests
// sent to the Meeting Service create-past-meeting-attachment server.
func EncodeCreatePastMeetingAttachmentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreatePastMeetingAttachmentPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-past-meeting-attachment", "*meetingservice.CreatePastMeetingAttachmentPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		if err := encoder(req).Encode(p); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-past-meeting-attachment", err)
		}
		return nil
	}
}

// NewMeetingServiceCreatePastMeetingAttachmentEncoder returns an encoder to
// encode the multipart request for the "Meeting Service" service
// "create-past-meeting-attachment" endpoint.
func NewMeetingServiceCreatePastMeetingAttachmentEncoder(encoderFn MeetingServiceCreatePastMeetingAttachmentEncoderFunc) func(r *http.Request) goahttp.Encoder {
	return func(r *http.Request) goahttp.Encoder {
		body := &bytes.Buffer{}
		mw := multipart.NewWriter(body)
		return goahttp.EncodingFunc(func(v any) error {
			p := v.(*meetingservice.CreatePastMeetingAttachmentPayload)
			if err := encoderFn(mw, p); err != nil {
				return err
			}
			r.Body = io.NopCloser(body)
			r.Header.Set("Content-Type", mw.FormDataContentType())
			return mw.Close()
		})
	}
}

// DecodeCreatePastMeetingAttachmentResponse returns a decoder for responses
// returned by the Meeting Service create-past-meeting-attachment endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeCreatePastMeetingAttachmentResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreatePastMeetingAttachmentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreatePastMeetingAttachmentResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-attachment", err)
			}
			err = ValidateCreatePastMeetingAttachmentResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-attachment", err)
			}
			res := NewCreatePastMeetingAttachmentPastMeetingAttachmentCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreatePastMeetingAttachmentBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-attachment", err)
			}
			err = ValidateCreatePastMeetingAttachmentBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-attachment", err)
			}
			return nil, NewCreatePastMeetingAttachmentBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body CreatePastMeetingAttachmentInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-attachment", err)
			}
			err = ValidateCreatePastMeetingAttachmentInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-attachment", err)
			}
			return nil, NewCreatePastMeetingAttachmentInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body CreatePastMeetingAttachmentNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-attachment", err)
			}
			err = ValidateCreatePastMeetingAttachmentNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-attachment", err)
			}
			return nil, NewCreatePastMeetingAttachmentNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreatePastMeetingAttachmentServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-attachment", err)
			}
			err = ValidateCreatePastMeetingAttachmentServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-attachment", err)
			}
			return nil, NewCreatePastMeetingAttachmentServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-past-meeting-attachment", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingAttachmentsRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "get-past-meeting-attachments" endpoint
func (c *Client) BuildGetPastMeetingAttachmentsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingAttachmentsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-attachments", "*meetingservice.GetPastMeetingAttachmentsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingAttachmentsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-attachments", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingAttachmentsRequest returns an encoder for requests sent
// to the Meeting Service get-past-meeting-attachments server.
func EncodeGetPastMeetingAttachmentsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingAttachmentsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-attachments", "*meetingservice.GetPastMeetingAttachmentsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingAttachmentsResponse returns a decoder for responses
// returned by the Meeting Service get-past-meeting-attachments endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeGetPastMeetingAttachmentsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingAttachmentsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingAttachmentsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachments", err)
			}
			err = ValidateGetPastMeetingAttachmentsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachments", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetPastMeetingAttachmentsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingAttachmentsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachments", err)
			}
			err = ValidateGetPastMeetingAttachmentsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachments", err)
			}
			return nil, NewGetPastMeetingAttachmentsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingAttachmentsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachments", err)
			}
			err = ValidateGetPastMeetingAttachmentsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachments", err)
			}
			return nil, NewGetPastMeetingAttachmentsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingAttachmentsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachments", err)
			}
			err = ValidateGetPastMeetingAttachmentsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachments", err)
			}
			return nil, NewGetPastMeetingAttachmentsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-attachments", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingAttachmentRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-past-meeting-attachment" endpoint
func (c *Client) BuildGetPastMeetingAttachmentRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingAttachmentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-attachment", "*meetingservice.GetPastMeetingAttachmentPayload", v)
		}
		pastMeetingUID = p.PastMeetingUID
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingAttachmentMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-attachment", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingAttachmentRequest returns an encoder for requests sent
// to the Meeting Service get-past-meeting-attachment server.
func EncodeGetPastMeetingAttachmentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingAttachmentPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-attachment", "*meetingservice.GetPastMeetingAttachmentPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingAttachmentResponse returns a decoder for responses
// returned by the Meeting Service get-past-meeting-attachment endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeGetPastMeetingAttachmentResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingAttachmentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []byte
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment", err)
			}
			return body, nil
		case http.StatusBadRequest:
			var (
				body GetPastMeetingAttachmentBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment", err)
			}
			err = ValidateGetPastMeetingAttachmentBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment", err)
			}
			return nil, NewGetPastMeetingAttachmentBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingAttachmentInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment", err)
			}
			err = ValidateGetPastMeetingAttachmentInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment", err)
			}
			return nil, NewGetPastMeetingAttachmentInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingAttachmentNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment", err)
			}
			err = ValidateGetPastMeetingAttachmentNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment", err)
			}
			return nil, NewGetPastMeetingAttachmentNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingAttachmentServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment", err)
			}
			err = ValidateGetPastMeetingAttachmentServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment", err)
			}
			return nil, NewGetPastMeetingAttachmentServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-attachment", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingAttachmentMetadataRequest instantiates a HTTP request
// object with method and path set to call the "Meeting Service" service
// "get-past-meeting-attachment-metadata" endpoint
func (c *Client) BuildGetPastMeetingAttachmentMetadataRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingAttachmentMetadataPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-attachment-metadata", "*meetingservice.GetPastMeetingAttachmentMetadataPayload", v)
		}
		pastMeetingUID = p.PastMeetingUID
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingAttachmentMetadataMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-attachment-metadata", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingAttachmentMetadataRequest returns an encoder for
// requests sent to the Meeting Service get-past-meeting-attachment-metadata
// server.
func EncodeGetPastMeetingAttachmentMetadataRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingAttachmentMetadataPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-attachment-metadata", "*meetingservice.GetPastMeetingAttachmentMetadataPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingAttachmentMetadataResponse returns a decoder for
// responses returned by the Meeting Service
// get-past-meeting-attachment-metadata endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeGetPastMeetingAttachmentMetadataResponse may return the following
// errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingAttachmentMetadataResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingAttachmentMetadataResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			err = ValidateGetPastMeetingAttachmentMetadataResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			res := NewGetPastMeetingAttachmentMetadataPastMeetingAttachmentOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetPastMeetingAttachmentMetadataBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			err = ValidateGetPastMeetingAttachmentMetadataBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			return nil, NewGetPastMeetingAttachmentMetadataBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingAttachmentMetadataInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			err = ValidateGetPastMeetingAttachmentMetadataInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			return nil, NewGetPastMeetingAttachmentMetadataInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingAttachmentMetadataNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			err = ValidateGetPastMeetingAttachmentMetadataNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			return nil, NewGetPastMeetingAttachmentMetadataNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingAttachmentMetadataServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			err = ValidateGetPastMeetingAttachmentMetadataServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-attachment-metadata", err)
			}
			return nil, NewGetPastMeetingAttachmentMetadataServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-attachment-metadata", resp.StatusCode, string(body))
		}
	}
}

// BuildDeletePastMeetingAttachmentRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "delete-past-meeting-attachment" endpoint
func (c *Client) BuildDeletePastMeetingAttachmentRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.DeletePastMeetingAttachmentPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting-attachment", "*meetingservice.DeletePastMeetingAttachmentPayload", v)
		}
		pastMeetingUID = p.PastMeetingUID
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeletePastMeetingAttachmentMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-past-meeting-attachment", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeletePastMeetingAttachmentRequest returns an encoder for requests
// sent to the Meeting Service delete-past-meeting-attachment server.
func EncodeDeletePastMeetingAttachmentRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeletePastMeetingAttachmentPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting-attachment", "*meetingservice.DeletePastMeetingAttachmentPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.XSync != nil {
			head := *p.XSync
			headStr := strconv.FormatBool(head)
			req.Header.Set("X-Sync", headStr)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeletePastMeetingAttachmentResponse returns a decoder for responses
// returned by the Meeting Service delete-past-meeting-attachment endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeDeletePastMeetingAttachmentResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeletePastMeetingAttachmentResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeletePastMeetingAttachmentBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-attachment", err)
			}
			err = ValidateDeletePastMeetingAttachmentBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-attachment", err)
			}
			return nil, NewDeletePastMeetingAttachmentBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeletePastMeetingAttachmentInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-attachment", err)
			}
			err = ValidateDeletePastMeetingAttachmentInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-attachment", err)
			}
			return nil, NewDeletePastMeetingAttachmentInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeletePastMeetingAttachmentNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-attachment", err)
			}
			err = ValidateDeletePastMeetingAttachmentNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-attachment", err)
			}
			return nil, NewDeletePastMeetingAttachmentNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeletePastMeetingAttachmentServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-attachment", err)
			}
			err = ValidateDeletePastMeetingAttachmentServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-attachment", err)
			}
			return nil, NewDeletePastMeetingAttachmentServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-past-meeting-attachment", resp.StatusCode, string(body))
		}
	}
}

// BuildReadyzRequest instantiates a HTTP request object with method and path
// set to call the "Meeting Service" service "readyz" endpoint
func (c *Client) BuildReadyzRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReadyzMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "readyz", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeReadyzResponse returns a decoder for responses returned by the Meeting
// Service readyz endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeReadyzResponse may return the following errors:
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeReadyzResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []byte
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "readyz", err)
			}
			return body, nil
		case http.StatusServiceUnavailable:
			var (
				body ReadyzServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "readyz", err)
			}
			err = ValidateReadyzServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "readyz", err)
			}
			return nil, NewReadyzServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "readyz", resp.StatusCode, string(body))
		}
	}
}

// BuildLivezRequest instantiates a HTTP request object with method and path
// set to call the "Meeting Service" service "livez" endpoint
func (c *Client) BuildLivezRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LivezMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "livez", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeLivezResponse returns a decoder for responses returned by the Meeting
// Service livez endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeLivezResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []byte
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "livez", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "livez", resp.StatusCode, string(body))
		}
	}
}

// unmarshalMeetingFullResponseBodyToMeetingserviceMeetingFull builds a value
// of type *meetingservice.MeetingFull from a value of type
// *MeetingFullResponseBody.
func unmarshalMeetingFullResponseBodyToMeetingserviceMeetingFull(v *MeetingFullResponseBody) *meetingservice.MeetingFull {
	res := &meetingservice.MeetingFull{
		UID:                     v.UID,
		ProjectUID:              v.ProjectUID,
		StartTime:               v.StartTime,
		Duration:                v.Duration,
		Timezone:                v.Timezone,
		SeriesEndDate:           v.SeriesEndDate,
		Title:                   v.Title,
		Description:             v.Description,
		Platform:                v.Platform,
		EarlyJoinTimeMinutes:    v.EarlyJoinTimeMinutes,
		MeetingType:             v.MeetingType,
		Visibility:              v.Visibility,
		Restricted:              v.Restricted,
		ArtifactVisibility:      v.ArtifactVisibility,
		PublicLink:              v.PublicLink,
		Password:                v.Password,
		EmailDeliveryErrorCount: v.EmailDeliveryErrorCount,
		RecordingEnabled:        v.RecordingEnabled,
		TranscriptEnabled:       v.TranscriptEnabled,
		YoutubeUploadEnabled:    v.YoutubeUploadEnabled,
		RegistrantCount:         v.RegistrantCount,
		CreatedAt:               v.CreatedAt,
		UpdatedAt:               v.UpdatedAt,
	}
	if v.Recurrence != nil {
		res.Recurrence = unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v.Recurrence)
	}
	if v.Committees != nil {
		res.Committees = make([]*meetingservice.Committee, len(v.Committees))
		for i, val := range v.Committees {
			if val == nil {
				res.Committees[i] = nil
				continue
			}
			res.Committees[i] = unmarshalCommitteeResponseBodyToMeetingserviceCommittee(val)
		}
	}
	if v.ZoomConfig != nil {
		res.ZoomConfig = unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull(v.ZoomConfig)
	}
	if v.Occurrences != nil {
		res.Occurrences = make([]*meetingservice.Occurrence, len(v.Occurrences))
		for i, val := range v.Occurrences {
			if val == nil {
				res.Occurrences[i] = nil
				continue
			}
			res.Occurrences[i] = unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence(val)
		}
	}
	if v.Organizers != nil {
		res.Organizers = make([]string, len(v.Organizers))
		for i, val := range v.Organizers {
			res.Organizers[i] = val
		}
	}

	return res
}

// unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence builds a value of
// type *meetingservice.Recurrence from a value of type *RecurrenceResponseBody.
func unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v *RecurrenceResponseBody) *meetingservice.Recurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Recurrence{
		Type:           *v.Type,
		RepeatInterval: *v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// unmarshalCommitteeResponseBodyToMeetingserviceCommittee builds a value of
// type *meetingservice.Committee from a value of type *CommitteeResponseBody.
func unmarshalCommitteeResponseBodyToMeetingserviceCommittee(v *CommitteeResponseBody) *meetingservice.Committee {
	if v == nil {
		return nil
	}
	res := &meetingservice.Committee{
		UID: *v.UID,
	}
	res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
	for i, val := range v.AllowedVotingStatuses {
		res.AllowedVotingStatuses[i] = val
	}

	return res
}

// unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull builds a
// value of type *meetingservice.ZoomConfigFull from a value of type
// *ZoomConfigFullResponseBody.
func unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull(v *ZoomConfigFullResponseBody) *meetingservice.ZoomConfigFull {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigFull{
		MeetingID:                v.MeetingID,
		Passcode:                 v.Passcode,
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence builds a value of
// type *meetingservice.Occurrence from a value of type *OccurrenceResponseBody.
func unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence(v *OccurrenceResponseBody) *meetingservice.Occurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Occurrence{
		OccurrenceID:       v.OccurrenceID,
		StartTime:          v.StartTime,
		Title:              v.Title,
		Description:        v.Description,
		Duration:           v.Duration,
		RegistrantCount:    v.RegistrantCount,
		ResponseCountNo:    v.ResponseCountNo,
		ResponseCountYes:   v.ResponseCountYes,
		ResponseCountMaybe: v.ResponseCountMaybe,
		IsCancelled:        v.IsCancelled,
	}
	if v.Recurrence != nil {
		res.Recurrence = unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v.Recurrence)
	}

	return res
}

// marshalMeetingserviceRecurrenceToRecurrenceRequestBody builds a value of
// type *RecurrenceRequestBody from a value of type *meetingservice.Recurrence.
func marshalMeetingserviceRecurrenceToRecurrenceRequestBody(v *meetingservice.Recurrence) *RecurrenceRequestBody {
	if v == nil {
		return nil
	}
	res := &RecurrenceRequestBody{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalMeetingserviceCommitteeToCommitteeRequestBody builds a value of type
// *CommitteeRequestBody from a value of type *meetingservice.Committee.
func marshalMeetingserviceCommitteeToCommitteeRequestBody(v *meetingservice.Committee) *CommitteeRequestBody {
	if v == nil {
		return nil
	}
	res := &CommitteeRequestBody{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	} else {
		res.AllowedVotingStatuses = []string{}
	}

	return res
}

// marshalMeetingserviceZoomConfigPostToZoomConfigPostRequestBody builds a
// value of type *ZoomConfigPostRequestBody from a value of type
// *meetingservice.ZoomConfigPost.
func marshalMeetingserviceZoomConfigPostToZoomConfigPostRequestBody(v *meetingservice.ZoomConfigPost) *ZoomConfigPostRequestBody {
	if v == nil {
		return nil
	}
	res := &ZoomConfigPostRequestBody{
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalRecurrenceRequestBodyToMeetingserviceRecurrence builds a value of
// type *meetingservice.Recurrence from a value of type *RecurrenceRequestBody.
func marshalRecurrenceRequestBodyToMeetingserviceRecurrence(v *RecurrenceRequestBody) *meetingservice.Recurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Recurrence{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalCommitteeRequestBodyToMeetingserviceCommittee builds a value of type
// *meetingservice.Committee from a value of type *CommitteeRequestBody.
func marshalCommitteeRequestBodyToMeetingserviceCommittee(v *CommitteeRequestBody) *meetingservice.Committee {
	if v == nil {
		return nil
	}
	res := &meetingservice.Committee{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	} else {
		res.AllowedVotingStatuses = []string{}
	}

	return res
}

// marshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost builds a
// value of type *meetingservice.ZoomConfigPost from a value of type
// *ZoomConfigPostRequestBody.
func marshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(v *ZoomConfigPostRequestBody) *meetingservice.ZoomConfigPost {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigPost{
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// unmarshalRegistrantResponseBodyToMeetingserviceRegistrant builds a value of
// type *meetingservice.Registrant from a value of type *RegistrantResponseBody.
func unmarshalRegistrantResponseBodyToMeetingserviceRegistrant(v *RegistrantResponseBody) *meetingservice.Registrant {
	res := &meetingservice.Registrant{
		UID:                *v.UID,
		MeetingUID:         *v.MeetingUID,
		Email:              *v.Email,
		FirstName:          v.FirstName,
		LastName:           v.LastName,
		Host:               v.Host,
		Type:               *v.Type,
		CommitteeUID:       v.CommitteeUID,
		JobTitle:           v.JobTitle,
		OccurrenceID:       v.OccurrenceID,
		OrgName:            v.OrgName,
		OrgIsMember:        v.OrgIsMember,
		OrgIsProjectMember: v.OrgIsProjectMember,
		AvatarURL:          v.AvatarURL,
		Username:           v.Username,
		CreatedAt:          v.CreatedAt,
		UpdatedAt:          v.UpdatedAt,
	}

	return res
}

// unmarshalRSVPResponseResponseBodyToMeetingserviceRSVPResponse builds a value
// of type *meetingservice.RSVPResponse from a value of type
// *RSVPResponseResponseBody.
func unmarshalRSVPResponseResponseBodyToMeetingserviceRSVPResponse(v *RSVPResponseResponseBody) *meetingservice.RSVPResponse {
	res := &meetingservice.RSVPResponse{
		ID:           *v.ID,
		MeetingUID:   *v.MeetingUID,
		RegistrantID: *v.RegistrantID,
		Username:     *v.Username,
		Email:        *v.Email,
		Response:     *v.Response,
		Scope:        *v.Scope,
		OccurrenceID: v.OccurrenceID,
		CreatedAt:    v.CreatedAt,
		UpdatedAt:    v.UpdatedAt,
	}

	return res
}

// unmarshalPastMeetingResponseBodyToMeetingservicePastMeeting builds a value
// of type *meetingservice.PastMeeting from a value of type
// *PastMeetingResponseBody.
func unmarshalPastMeetingResponseBodyToMeetingservicePastMeeting(v *PastMeetingResponseBody) *meetingservice.PastMeeting {
	res := &meetingservice.PastMeeting{
		UID:                  v.UID,
		MeetingUID:           v.MeetingUID,
		OccurrenceID:         v.OccurrenceID,
		ProjectUID:           v.ProjectUID,
		ScheduledStartTime:   v.ScheduledStartTime,
		ScheduledEndTime:     v.ScheduledEndTime,
		Duration:             v.Duration,
		Timezone:             v.Timezone,
		Title:                v.Title,
		Description:          v.Description,
		Platform:             v.Platform,
		PlatformMeetingID:    v.PlatformMeetingID,
		EarlyJoinTimeMinutes: v.EarlyJoinTimeMinutes,
		MeetingType:          v.MeetingType,
		Visibility:           v.Visibility,
		Restricted:           v.Restricted,
		ArtifactVisibility:   v.ArtifactVisibility,
		PublicLink:           v.PublicLink,
		RecordingEnabled:     v.RecordingEnabled,
		TranscriptEnabled:    v.TranscriptEnabled,
		YoutubeUploadEnabled: v.YoutubeUploadEnabled,
		CreatedAt:            v.CreatedAt,
		UpdatedAt:            v.UpdatedAt,
	}
	if v.Recurrence != nil {
		res.Recurrence = unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v.Recurrence)
	}
	if v.Committees != nil {
		res.Committees = make([]*meetingservice.Committee, len(v.Committees))
		for i, val := range v.Committees {
			if val == nil {
				res.Committees[i] = nil
				continue
			}
			res.Committees[i] = unmarshalCommitteeResponseBodyToMeetingserviceCommittee(val)
		}
	}
	if v.ZoomConfig != nil {
		res.ZoomConfig = unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull(v.ZoomConfig)
	}
	if v.Sessions != nil {
		res.Sessions = make([]*meetingservice.Session, len(v.Sessions))
		for i, val := range v.Sessions {
			if val == nil {
				res.Sessions[i] = nil
				continue
			}
			res.Sessions[i] = unmarshalSessionResponseBodyToMeetingserviceSession(val)
		}
	}

	return res
}

// unmarshalSessionResponseBodyToMeetingserviceSession builds a value of type
// *meetingservice.Session from a value of type *SessionResponseBody.
func unmarshalSessionResponseBodyToMeetingserviceSession(v *SessionResponseBody) *meetingservice.Session {
	if v == nil {
		return nil
	}
	res := &meetingservice.Session{
		UID:       *v.UID,
		StartTime: *v.StartTime,
		EndTime:   v.EndTime,
	}

	return res
}

// marshalMeetingserviceZoomConfigFullToZoomConfigFullRequestBody builds a
// value of type *ZoomConfigFullRequestBody from a value of type
// *meetingservice.ZoomConfigFull.
func marshalMeetingserviceZoomConfigFullToZoomConfigFullRequestBody(v *meetingservice.ZoomConfigFull) *ZoomConfigFullRequestBody {
	if v == nil {
		return nil
	}
	res := &ZoomConfigFullRequestBody{
		MeetingID:                v.MeetingID,
		Passcode:                 v.Passcode,
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalMeetingserviceSessionToSessionRequestBody builds a value of type
// *SessionRequestBody from a value of type *meetingservice.Session.
func marshalMeetingserviceSessionToSessionRequestBody(v *meetingservice.Session) *SessionRequestBody {
	if v == nil {
		return nil
	}
	res := &SessionRequestBody{
		UID:       v.UID,
		StartTime: v.StartTime,
		EndTime:   v.EndTime,
	}

	return res
}

// marshalZoomConfigFullRequestBodyToMeetingserviceZoomConfigFull builds a
// value of type *meetingservice.ZoomConfigFull from a value of type
// *ZoomConfigFullRequestBody.
func marshalZoomConfigFullRequestBodyToMeetingserviceZoomConfigFull(v *ZoomConfigFullRequestBody) *meetingservice.ZoomConfigFull {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigFull{
		MeetingID:                v.MeetingID,
		Passcode:                 v.Passcode,
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalSessionRequestBodyToMeetingserviceSession builds a value of type
// *meetingservice.Session from a value of type *SessionRequestBody.
func marshalSessionRequestBodyToMeetingserviceSession(v *SessionRequestBody) *meetingservice.Session {
	if v == nil {
		return nil
	}
	res := &meetingservice.Session{
		UID:       v.UID,
		StartTime: v.StartTime,
		EndTime:   v.EndTime,
	}

	return res
}

// unmarshalPastMeetingParticipantResponseBodyToMeetingservicePastMeetingParticipant
// builds a value of type *meetingservice.PastMeetingParticipant from a value
// of type *PastMeetingParticipantResponseBody.
func unmarshalPastMeetingParticipantResponseBodyToMeetingservicePastMeetingParticipant(v *PastMeetingParticipantResponseBody) *meetingservice.PastMeetingParticipant {
	res := &meetingservice.PastMeetingParticipant{
		UID:                *v.UID,
		PastMeetingUID:     *v.PastMeetingUID,
		MeetingUID:         *v.MeetingUID,
		Email:              *v.Email,
		FirstName:          v.FirstName,
		LastName:           v.LastName,
		Host:               v.Host,
		JobTitle:           v.JobTitle,
		OrgName:            v.OrgName,
		OrgIsMember:        v.OrgIsMember,
		OrgIsProjectMember: v.OrgIsProjectMember,
		AvatarURL:          v.AvatarURL,
		Username:           v.Username,
		IsInvited:          v.IsInvited,
		IsAttended:         v.IsAttended,
		CreatedAt:          v.CreatedAt,
		UpdatedAt:          v.UpdatedAt,
	}
	if v.Sessions != nil {
		res.Sessions = make([]*meetingservice.ParticipantSession, len(v.Sessions))
		for i, val := range v.Sessions {
			if val == nil {
				res.Sessions[i] = nil
				continue
			}
			res.Sessions[i] = unmarshalParticipantSessionResponseBodyToMeetingserviceParticipantSession(val)
		}
	}

	return res
}

// unmarshalParticipantSessionResponseBodyToMeetingserviceParticipantSession
// builds a value of type *meetingservice.ParticipantSession from a value of
// type *ParticipantSessionResponseBody.
func unmarshalParticipantSessionResponseBodyToMeetingserviceParticipantSession(v *ParticipantSessionResponseBody) *meetingservice.ParticipantSession {
	if v == nil {
		return nil
	}
	res := &meetingservice.ParticipantSession{
		UID:         *v.UID,
		JoinTime:    *v.JoinTime,
		LeaveTime:   v.LeaveTime,
		LeaveReason: v.LeaveReason,
	}

	return res
}

// unmarshalPastMeetingSummaryResponseBodyToMeetingservicePastMeetingSummary
// builds a value of type *meetingservice.PastMeetingSummary from a value of
// type *PastMeetingSummaryResponseBody.
func unmarshalPastMeetingSummaryResponseBodyToMeetingservicePastMeetingSummary(v *PastMeetingSummaryResponseBody) *meetingservice.PastMeetingSummary {
	res := &meetingservice.PastMeetingSummary{
		UID:              *v.UID,
		PastMeetingUID:   *v.PastMeetingUID,
		MeetingUID:       *v.MeetingUID,
		Platform:         *v.Platform,
		Password:         v.Password,
		RequiresApproval: *v.RequiresApproval,
		Approved:         *v.Approved,
		EmailSent:        *v.EmailSent,
		CreatedAt:        *v.CreatedAt,
		UpdatedAt:        *v.UpdatedAt,
	}
	if v.ZoomConfig != nil {
		res.ZoomConfig = unmarshalPastMeetingSummaryZoomConfigResponseBodyToMeetingservicePastMeetingSummaryZoomConfig(v.ZoomConfig)
	}
	res.SummaryData = unmarshalSummaryDataResponseBodyToMeetingserviceSummaryData(v.SummaryData)

	return res
}

// unmarshalPastMeetingSummaryZoomConfigResponseBodyToMeetingservicePastMeetingSummaryZoomConfig
// builds a value of type *meetingservice.PastMeetingSummaryZoomConfig from a
// value of type *PastMeetingSummaryZoomConfigResponseBody.
func unmarshalPastMeetingSummaryZoomConfigResponseBodyToMeetingservicePastMeetingSummaryZoomConfig(v *PastMeetingSummaryZoomConfigResponseBody) *meetingservice.PastMeetingSummaryZoomConfig {
	if v == nil {
		return nil
	}
	res := &meetingservice.PastMeetingSummaryZoomConfig{
		MeetingID:   v.MeetingID,
		MeetingUUID: v.MeetingUUID,
	}

	return res
}

// unmarshalSummaryDataResponseBodyToMeetingserviceSummaryData builds a value
// of type *meetingservice.SummaryData from a value of type
// *SummaryDataResponseBody.
func unmarshalSummaryDataResponseBodyToMeetingserviceSummaryData(v *SummaryDataResponseBody) *meetingservice.SummaryData {
	res := &meetingservice.SummaryData{
		StartTime:     *v.StartTime,
		EndTime:       *v.EndTime,
		Title:         v.Title,
		Content:       v.Content,
		DocURL:        v.DocURL,
		EditedContent: v.EditedContent,
	}

	return res
}

// unmarshalPastMeetingAttachmentResponseBodyToMeetingservicePastMeetingAttachment
// builds a value of type *meetingservice.PastMeetingAttachment from a value of
// type *PastMeetingAttachmentResponseBody.
func unmarshalPastMeetingAttachmentResponseBodyToMeetingservicePastMeetingAttachment(v *PastMeetingAttachmentResponseBody) *meetingservice.PastMeetingAttachment {
	res := &meetingservice.PastMeetingAttachment{
		UID:             *v.UID,
		PastMeetingUID:  *v.PastMeetingUID,
		Type:            *v.Type,
		Link:            v.Link,
		Name:            *v.Name,
		FileName:        v.FileName,
		FileSize:        v.FileSize,
		ContentType:     v.ContentType,
		UploadedBy:      *v.UploadedBy,
		UploadedAt:      v.UploadedAt,
		Description:     v.Description,
		SourceObjectUID: v.SourceObjectUID,
	}

	return res
}
