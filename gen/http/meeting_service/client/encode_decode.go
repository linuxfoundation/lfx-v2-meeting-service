// Code generated by goa v3.21.1, DO NOT EDIT.
//
// Meeting Service HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goahttp "goa.design/goa/v3/http"
)

// BuildGetMeetingsRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "get-meetings" endpoint
func (c *Client) BuildGetMeetingsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingsMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meetings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingsRequest returns an encoder for requests sent to the Meeting
// Service get-meetings server.
func EncodeGetMeetingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meetings", "*meetingservice.GetMeetingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingsResponse returns a decoder for responses returned by the
// Meeting Service get-meetings endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetMeetingsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetMeetingsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetMeetingsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetMeetingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meetings", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateMeetingRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "create-meeting" endpoint
func (c *Client) BuildCreateMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateMeetingMeetingServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateMeetingRequest returns an encoder for requests sent to the
// Meeting Service create-meeting server.
func EncodeCreateMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreateMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-meeting", "*meetingservice.CreateMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreateMeetingRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-meeting", err)
		}
		return nil
	}
}

// DecodeCreateMeetingResponse returns a decoder for responses returned by the
// Meeting Service create-meeting endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCreateMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreateMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateMeetingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			res := NewCreateMeetingMeetingFullCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreateMeetingConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreateMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreateMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingBaseRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-meeting-base"
// endpoint
func (c *Client) BuildGetMeetingBaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingBasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-base", "*meetingservice.GetMeetingBasePayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingBaseMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-base", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingBaseRequest returns an encoder for requests sent to the
// Meeting Service get-meeting-base server.
func EncodeGetMeetingBaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingBasePayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-base", "*meetingservice.GetMeetingBasePayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingBaseResponse returns a decoder for responses returned by the
// Meeting Service get-meeting-base endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetMeetingBaseResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingBaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingBaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingBaseResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingBaseInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingBaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingBaseServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-base", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingSettingsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-settings" endpoint
func (c *Client) BuildGetMeetingSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-settings", "*meetingservice.GetMeetingSettingsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingSettingsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-settings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingSettingsRequest returns an encoder for requests sent to the
// Meeting Service get-meeting-settings server.
func EncodeGetMeetingSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-settings", "*meetingservice.GetMeetingSettingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingSettingsResponse returns a decoder for responses returned by
// the Meeting Service get-meeting-settings endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetMeetingSettingsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingSettingsResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingSettingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingSettingsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingSettingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-settings", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingBaseRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "update-meeting-base"
// endpoint
func (c *Client) BuildUpdateMeetingBaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingBasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-base", "*meetingservice.UpdateMeetingBasePayload", v)
		}
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingBaseMeetingServicePath(uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-base", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingBaseRequest returns an encoder for requests sent to the
// Meeting Service update-meeting-base server.
func EncodeUpdateMeetingBaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingBasePayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-base", "*meetingservice.UpdateMeetingBasePayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingBaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-base", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingBaseResponse returns a decoder for responses returned by
// the Meeting Service update-meeting-base endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeUpdateMeetingBaseResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingBaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingBaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			res := NewUpdateMeetingBaseMeetingBaseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingBaseBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdateMeetingBaseConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseConflict(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingBaseInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingBaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingBaseServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-base", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingSettingsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "update-meeting-settings" endpoint
func (c *Client) BuildUpdateMeetingSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-settings", "*meetingservice.UpdateMeetingSettingsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingSettingsMeetingServicePath(uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-settings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingSettingsRequest returns an encoder for requests sent to
// the Meeting Service update-meeting-settings server.
func EncodeUpdateMeetingSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-settings", "*meetingservice.UpdateMeetingSettingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingSettingsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-settings", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingSettingsResponse returns a decoder for responses returned
// by the Meeting Service update-meeting-settings endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeUpdateMeetingSettingsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			res := NewUpdateMeetingSettingsMeetingSettingsOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingSettingsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingSettingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingSettingsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingSettingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-settings", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMeetingRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "delete-meeting" endpoint
func (c *Client) BuildDeleteMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.DeleteMeetingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-meeting", "*meetingservice.DeleteMeetingPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMeetingMeetingServicePath(uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMeetingRequest returns an encoder for requests sent to the
// Meeting Service delete-meeting server.
func EncodeDeleteMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeleteMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-meeting", "*meetingservice.DeleteMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeleteMeetingResponse returns a decoder for responses returned by the
// Meeting Service delete-meeting endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDeleteMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeleteMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeleteMeetingNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeleteMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingRegistrantsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-registrants" endpoint
func (c *Client) BuildGetMeetingRegistrantsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingRegistrantsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrants", "*meetingservice.GetMeetingRegistrantsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingRegistrantsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-registrants", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingRegistrantsRequest returns an encoder for requests sent to
// the Meeting Service get-meeting-registrants server.
func EncodeGetMeetingRegistrantsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingRegistrantsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrants", "*meetingservice.GetMeetingRegistrantsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingRegistrantsResponse returns a decoder for responses returned
// by the Meeting Service get-meeting-registrants endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeGetMeetingRegistrantsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingRegistrantsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingRegistrantsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetMeetingRegistrantsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingRegistrantsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingRegistrantsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingRegistrantsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-registrants", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "create-meeting-registrant" endpoint
func (c *Client) BuildCreateMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
	)
	{
		p, ok := v.(*meetingservice.CreateMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "create-meeting-registrant", "*meetingservice.CreateMeetingRegistrantPayload", v)
		}
		meetingUID = p.MeetingUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateMeetingRegistrantMeetingServicePath(meetingUID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service create-meeting-registrant server.
func EncodeCreateMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreateMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-meeting-registrant", "*meetingservice.CreateMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreateMeetingRegistrantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-meeting-registrant", err)
		}
		return nil
	}
}

// DecodeCreateMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service create-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeCreateMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreateMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			res := NewCreateMeetingRegistrantRegistrantCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreateMeetingRegistrantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreateMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body CreateMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreateMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-registrant" endpoint
func (c *Client) BuildGetMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrant", "*meetingservice.GetMeetingRegistrantPayload", v)
		}
		if p.MeetingUID != nil {
			meetingUID = *p.MeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service get-meeting-registrant server.
func EncodeGetMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrant", "*meetingservice.GetMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingRegistrantResponse returns a decoder for responses returned
// by the Meeting Service get-meeting-registrant endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetMeetingRegistrantResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingRegistrantResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "update-meeting-registrant" endpoint
func (c *Client) BuildUpdateMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-registrant", "*meetingservice.UpdateMeetingRegistrantPayload", v)
		}
		meetingUID = p.MeetingUID
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service update-meeting-registrant server.
func EncodeUpdateMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-registrant", "*meetingservice.UpdateMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingRegistrantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-registrant", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service update-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeUpdateMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			res := NewUpdateMeetingRegistrantRegistrantOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdateMeetingRegistrantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "delete-meeting-registrant" endpoint
func (c *Client) BuildDeleteMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.DeleteMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-meeting-registrant", "*meetingservice.DeleteMeetingRegistrantPayload", v)
		}
		if p.MeetingUID != nil {
			meetingUID = *p.MeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service delete-meeting-registrant server.
func EncodeDeleteMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeleteMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-meeting-registrant", "*meetingservice.DeleteMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeleteMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service delete-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeDeleteMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeleteMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeleteMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeleteMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildZoomWebhookRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "zoom-webhook" endpoint
func (c *Client) BuildZoomWebhookRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ZoomWebhookMeetingServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "zoom-webhook", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeZoomWebhookRequest returns an encoder for requests sent to the Meeting
// Service zoom-webhook server.
func EncodeZoomWebhookRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.ZoomWebhookPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "zoom-webhook", "*meetingservice.ZoomWebhookPayload", v)
		}
		if p.ZoomSignature != nil {
			head := *p.ZoomSignature
			req.Header.Set("x-zm-signature", head)
		}
		if p.ZoomTimestamp != nil {
			head := *p.ZoomTimestamp
			req.Header.Set("x-zm-request-timestamp", head)
		}
		body := NewZoomWebhookRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "zoom-webhook", err)
		}
		return nil
	}
}

// DecodeZoomWebhookResponse returns a decoder for responses returned by the
// Meeting Service zoom-webhook endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeZoomWebhookResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "Unauthorized" (type *meetingservice.UnauthorizedError): http.StatusUnauthorized
//   - error: internal error
func DecodeZoomWebhookResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ZoomWebhookResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "zoom-webhook", err)
			}
			err = ValidateZoomWebhookResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "zoom-webhook", err)
			}
			res := NewZoomWebhookResponseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body ZoomWebhookBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "zoom-webhook", err)
			}
			err = ValidateZoomWebhookBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "zoom-webhook", err)
			}
			return nil, NewZoomWebhookBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body ZoomWebhookInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "zoom-webhook", err)
			}
			err = ValidateZoomWebhookInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "zoom-webhook", err)
			}
			return nil, NewZoomWebhookInternalServerError(&body)
		case http.StatusUnauthorized:
			var (
				body ZoomWebhookUnauthorizedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "zoom-webhook", err)
			}
			err = ValidateZoomWebhookUnauthorizedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "zoom-webhook", err)
			}
			return nil, NewZoomWebhookUnauthorized(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "zoom-webhook", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingsRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-past-meetings"
// endpoint
func (c *Client) BuildGetPastMeetingsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingsMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meetings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingsRequest returns an encoder for requests sent to the
// Meeting Service get-past-meetings server.
func EncodeGetPastMeetingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meetings", "*meetingservice.GetPastMeetingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingsResponse returns a decoder for responses returned by
// the Meeting Service get-past-meetings endpoint. restoreBody controls whether
// the response body should be restored after having been read.
// DecodeGetPastMeetingsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meetings", err)
			}
			err = ValidateGetPastMeetingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meetings", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetPastMeetingsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetPastMeetingsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meetings", err)
			}
			err = ValidateGetPastMeetingsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meetings", err)
			}
			return nil, NewGetPastMeetingsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meetings", err)
			}
			err = ValidateGetPastMeetingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meetings", err)
			}
			return nil, NewGetPastMeetingsInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meetings", err)
			}
			err = ValidateGetPastMeetingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meetings", err)
			}
			return nil, NewGetPastMeetingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meetings", resp.StatusCode, string(body))
		}
	}
}

// BuildCreatePastMeetingRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "create-past-meeting"
// endpoint
func (c *Client) BuildCreatePastMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreatePastMeetingMeetingServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-past-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreatePastMeetingRequest returns an encoder for requests sent to the
// Meeting Service create-past-meeting server.
func EncodeCreatePastMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreatePastMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-past-meeting", "*meetingservice.CreatePastMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreatePastMeetingRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-past-meeting", err)
		}
		return nil
	}
}

// DecodeCreatePastMeetingResponse returns a decoder for responses returned by
// the Meeting Service create-past-meeting endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeCreatePastMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreatePastMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreatePastMeetingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			res := NewCreatePastMeetingPastMeetingCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreatePastMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			return nil, NewCreatePastMeetingBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreatePastMeetingConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			return nil, NewCreatePastMeetingConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreatePastMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			return nil, NewCreatePastMeetingInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreatePastMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting", err)
			}
			err = ValidateCreatePastMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting", err)
			}
			return nil, NewCreatePastMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-past-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-past-meeting"
// endpoint
func (c *Client) BuildGetPastMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting", "*meetingservice.GetPastMeetingPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingRequest returns an encoder for requests sent to the
// Meeting Service get-past-meeting server.
func EncodeGetPastMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting", "*meetingservice.GetPastMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingResponse returns a decoder for responses returned by the
// Meeting Service get-past-meeting endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetPastMeetingResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting", err)
			}
			err = ValidateGetPastMeetingResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetPastMeetingResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting", err)
			}
			err = ValidateGetPastMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting", err)
			}
			return nil, NewGetPastMeetingInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting", err)
			}
			err = ValidateGetPastMeetingNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting", err)
			}
			return nil, NewGetPastMeetingNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting", err)
			}
			err = ValidateGetPastMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting", err)
			}
			return nil, NewGetPastMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildDeletePastMeetingRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "delete-past-meeting"
// endpoint
func (c *Client) BuildDeletePastMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.DeletePastMeetingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting", "*meetingservice.DeletePastMeetingPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeletePastMeetingMeetingServicePath(uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-past-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeletePastMeetingRequest returns an encoder for requests sent to the
// Meeting Service delete-past-meeting server.
func EncodeDeletePastMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeletePastMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting", "*meetingservice.DeletePastMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeletePastMeetingResponse returns a decoder for responses returned by
// the Meeting Service delete-past-meeting endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeDeletePastMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeletePastMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeletePastMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting", err)
			}
			err = ValidateDeletePastMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting", err)
			}
			return nil, NewDeletePastMeetingBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeletePastMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting", err)
			}
			err = ValidateDeletePastMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting", err)
			}
			return nil, NewDeletePastMeetingInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeletePastMeetingNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting", err)
			}
			err = ValidateDeletePastMeetingNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting", err)
			}
			return nil, NewDeletePastMeetingNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeletePastMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting", err)
			}
			err = ValidateDeletePastMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting", err)
			}
			return nil, NewDeletePastMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-past-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingParticipantsRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "get-past-meeting-participants" endpoint
func (c *Client) BuildGetPastMeetingParticipantsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingParticipantsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-participants", "*meetingservice.GetPastMeetingParticipantsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingParticipantsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-participants", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingParticipantsRequest returns an encoder for requests sent
// to the Meeting Service get-past-meeting-participants server.
func EncodeGetPastMeetingParticipantsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingParticipantsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-participants", "*meetingservice.GetPastMeetingParticipantsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingParticipantsResponse returns a decoder for responses
// returned by the Meeting Service get-past-meeting-participants endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeGetPastMeetingParticipantsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingParticipantsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingParticipantsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participants", err)
			}
			err = ValidateGetPastMeetingParticipantsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participants", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetPastMeetingParticipantsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingParticipantsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participants", err)
			}
			err = ValidateGetPastMeetingParticipantsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participants", err)
			}
			return nil, NewGetPastMeetingParticipantsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingParticipantsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participants", err)
			}
			err = ValidateGetPastMeetingParticipantsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participants", err)
			}
			return nil, NewGetPastMeetingParticipantsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingParticipantsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participants", err)
			}
			err = ValidateGetPastMeetingParticipantsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participants", err)
			}
			return nil, NewGetPastMeetingParticipantsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-participants", resp.StatusCode, string(body))
		}
	}
}

// BuildCreatePastMeetingParticipantRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "create-past-meeting-participant" endpoint
func (c *Client) BuildCreatePastMeetingParticipantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.CreatePastMeetingParticipantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "create-past-meeting-participant", "*meetingservice.CreatePastMeetingParticipantPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreatePastMeetingParticipantMeetingServicePath(uid)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-past-meeting-participant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreatePastMeetingParticipantRequest returns an encoder for requests
// sent to the Meeting Service create-past-meeting-participant server.
func EncodeCreatePastMeetingParticipantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreatePastMeetingParticipantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-past-meeting-participant", "*meetingservice.CreatePastMeetingParticipantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreatePastMeetingParticipantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-past-meeting-participant", err)
		}
		return nil
	}
}

// DecodeCreatePastMeetingParticipantResponse returns a decoder for responses
// returned by the Meeting Service create-past-meeting-participant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeCreatePastMeetingParticipantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreatePastMeetingParticipantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreatePastMeetingParticipantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			res := NewCreatePastMeetingParticipantPastMeetingParticipantCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreatePastMeetingParticipantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreatePastMeetingParticipantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreatePastMeetingParticipantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body CreatePastMeetingParticipantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreatePastMeetingParticipantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-past-meeting-participant", err)
			}
			err = ValidateCreatePastMeetingParticipantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-past-meeting-participant", err)
			}
			return nil, NewCreatePastMeetingParticipantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-past-meeting-participant", resp.StatusCode, string(body))
		}
	}
}

// BuildGetPastMeetingParticipantRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "get-past-meeting-participant" endpoint
func (c *Client) BuildGetPastMeetingParticipantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.GetPastMeetingParticipantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-participant", "*meetingservice.GetPastMeetingParticipantPayload", v)
		}
		if p.PastMeetingUID != nil {
			pastMeetingUID = *p.PastMeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetPastMeetingParticipantMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-past-meeting-participant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetPastMeetingParticipantRequest returns an encoder for requests sent
// to the Meeting Service get-past-meeting-participant server.
func EncodeGetPastMeetingParticipantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetPastMeetingParticipantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-past-meeting-participant", "*meetingservice.GetPastMeetingParticipantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetPastMeetingParticipantResponse returns a decoder for responses
// returned by the Meeting Service get-past-meeting-participant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeGetPastMeetingParticipantResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetPastMeetingParticipantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetPastMeetingParticipantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participant", err)
			}
			err = ValidateGetPastMeetingParticipantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participant", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetPastMeetingParticipantResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetPastMeetingParticipantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participant", err)
			}
			err = ValidateGetPastMeetingParticipantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participant", err)
			}
			return nil, NewGetPastMeetingParticipantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetPastMeetingParticipantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participant", err)
			}
			err = ValidateGetPastMeetingParticipantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participant", err)
			}
			return nil, NewGetPastMeetingParticipantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetPastMeetingParticipantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-past-meeting-participant", err)
			}
			err = ValidateGetPastMeetingParticipantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-past-meeting-participant", err)
			}
			return nil, NewGetPastMeetingParticipantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-past-meeting-participant", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdatePastMeetingParticipantRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "update-past-meeting-participant" endpoint
func (c *Client) BuildUpdatePastMeetingParticipantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.UpdatePastMeetingParticipantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-past-meeting-participant", "*meetingservice.UpdatePastMeetingParticipantPayload", v)
		}
		pastMeetingUID = p.PastMeetingUID
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdatePastMeetingParticipantMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-past-meeting-participant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdatePastMeetingParticipantRequest returns an encoder for requests
// sent to the Meeting Service update-past-meeting-participant server.
func EncodeUpdatePastMeetingParticipantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdatePastMeetingParticipantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-past-meeting-participant", "*meetingservice.UpdatePastMeetingParticipantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdatePastMeetingParticipantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-past-meeting-participant", err)
		}
		return nil
	}
}

// DecodeUpdatePastMeetingParticipantResponse returns a decoder for responses
// returned by the Meeting Service update-past-meeting-participant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeUpdatePastMeetingParticipantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdatePastMeetingParticipantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdatePastMeetingParticipantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			res := NewUpdatePastMeetingParticipantPastMeetingParticipantOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdatePastMeetingParticipantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdatePastMeetingParticipantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body UpdatePastMeetingParticipantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdatePastMeetingParticipantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdatePastMeetingParticipantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-past-meeting-participant", err)
			}
			err = ValidateUpdatePastMeetingParticipantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-past-meeting-participant", err)
			}
			return nil, NewUpdatePastMeetingParticipantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-past-meeting-participant", resp.StatusCode, string(body))
		}
	}
}

// BuildDeletePastMeetingParticipantRequest instantiates a HTTP request object
// with method and path set to call the "Meeting Service" service
// "delete-past-meeting-participant" endpoint
func (c *Client) BuildDeletePastMeetingParticipantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		pastMeetingUID string
		uid            string
	)
	{
		p, ok := v.(*meetingservice.DeletePastMeetingParticipantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting-participant", "*meetingservice.DeletePastMeetingParticipantPayload", v)
		}
		if p.PastMeetingUID != nil {
			pastMeetingUID = *p.PastMeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeletePastMeetingParticipantMeetingServicePath(pastMeetingUID, uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-past-meeting-participant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeletePastMeetingParticipantRequest returns an encoder for requests
// sent to the Meeting Service delete-past-meeting-participant server.
func EncodeDeletePastMeetingParticipantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeletePastMeetingParticipantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-past-meeting-participant", "*meetingservice.DeletePastMeetingParticipantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeletePastMeetingParticipantResponse returns a decoder for responses
// returned by the Meeting Service delete-past-meeting-participant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeDeletePastMeetingParticipantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeletePastMeetingParticipantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeletePastMeetingParticipantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-participant", err)
			}
			err = ValidateDeletePastMeetingParticipantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-participant", err)
			}
			return nil, NewDeletePastMeetingParticipantBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeletePastMeetingParticipantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-participant", err)
			}
			err = ValidateDeletePastMeetingParticipantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-participant", err)
			}
			return nil, NewDeletePastMeetingParticipantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeletePastMeetingParticipantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-participant", err)
			}
			err = ValidateDeletePastMeetingParticipantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-participant", err)
			}
			return nil, NewDeletePastMeetingParticipantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeletePastMeetingParticipantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-past-meeting-participant", err)
			}
			err = ValidateDeletePastMeetingParticipantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-past-meeting-participant", err)
			}
			return nil, NewDeletePastMeetingParticipantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-past-meeting-participant", resp.StatusCode, string(body))
		}
	}
}

// BuildReadyzRequest instantiates a HTTP request object with method and path
// set to call the "Meeting Service" service "readyz" endpoint
func (c *Client) BuildReadyzRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReadyzMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "readyz", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeReadyzResponse returns a decoder for responses returned by the Meeting
// Service readyz endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeReadyzResponse may return the following errors:
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeReadyzResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []byte
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "readyz", err)
			}
			return body, nil
		case http.StatusServiceUnavailable:
			var (
				body ReadyzServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "readyz", err)
			}
			err = ValidateReadyzServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "readyz", err)
			}
			return nil, NewReadyzServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "readyz", resp.StatusCode, string(body))
		}
	}
}

// BuildLivezRequest instantiates a HTTP request object with method and path
// set to call the "Meeting Service" service "livez" endpoint
func (c *Client) BuildLivezRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LivezMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "livez", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeLivezResponse returns a decoder for responses returned by the Meeting
// Service livez endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeLivezResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []byte
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "livez", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "livez", resp.StatusCode, string(body))
		}
	}
}

// unmarshalMeetingFullResponseBodyToMeetingserviceMeetingFull builds a value
// of type *meetingservice.MeetingFull from a value of type
// *MeetingFullResponseBody.
func unmarshalMeetingFullResponseBodyToMeetingserviceMeetingFull(v *MeetingFullResponseBody) *meetingservice.MeetingFull {
	res := &meetingservice.MeetingFull{
		UID:                             v.UID,
		ProjectUID:                      v.ProjectUID,
		StartTime:                       v.StartTime,
		Duration:                        v.Duration,
		Timezone:                        v.Timezone,
		Title:                           v.Title,
		Description:                     v.Description,
		Platform:                        v.Platform,
		EarlyJoinTimeMinutes:            v.EarlyJoinTimeMinutes,
		MeetingType:                     v.MeetingType,
		Visibility:                      v.Visibility,
		Restricted:                      v.Restricted,
		ArtifactVisibility:              v.ArtifactVisibility,
		JoinURL:                         v.JoinURL,
		PublicLink:                      v.PublicLink,
		EmailDeliveryErrorCount:         v.EmailDeliveryErrorCount,
		RecordingEnabled:                v.RecordingEnabled,
		TranscriptEnabled:               v.TranscriptEnabled,
		YoutubeUploadEnabled:            v.YoutubeUploadEnabled,
		RegistrantCount:                 v.RegistrantCount,
		RegistrantResponseDeclinedCount: v.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: v.RegistrantResponseAcceptedCount,
		CreatedAt:                       v.CreatedAt,
		UpdatedAt:                       v.UpdatedAt,
	}
	if v.Recurrence != nil {
		res.Recurrence = unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v.Recurrence)
	}
	if v.Committees != nil {
		res.Committees = make([]*meetingservice.Committee, len(v.Committees))
		for i, val := range v.Committees {
			res.Committees[i] = unmarshalCommitteeResponseBodyToMeetingserviceCommittee(val)
		}
	}
	if v.ZoomConfig != nil {
		res.ZoomConfig = unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull(v.ZoomConfig)
	}
	if v.Occurrences != nil {
		res.Occurrences = make([]*meetingservice.Occurrence, len(v.Occurrences))
		for i, val := range v.Occurrences {
			res.Occurrences[i] = unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence(val)
		}
	}
	if v.Organizers != nil {
		res.Organizers = make([]string, len(v.Organizers))
		for i, val := range v.Organizers {
			res.Organizers[i] = val
		}
	}

	return res
}

// unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence builds a value of
// type *meetingservice.Recurrence from a value of type *RecurrenceResponseBody.
func unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v *RecurrenceResponseBody) *meetingservice.Recurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Recurrence{
		Type:           *v.Type,
		RepeatInterval: *v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// unmarshalCommitteeResponseBodyToMeetingserviceCommittee builds a value of
// type *meetingservice.Committee from a value of type *CommitteeResponseBody.
func unmarshalCommitteeResponseBodyToMeetingserviceCommittee(v *CommitteeResponseBody) *meetingservice.Committee {
	if v == nil {
		return nil
	}
	res := &meetingservice.Committee{
		UID: *v.UID,
	}
	res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
	for i, val := range v.AllowedVotingStatuses {
		res.AllowedVotingStatuses[i] = val
	}

	return res
}

// unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull builds a
// value of type *meetingservice.ZoomConfigFull from a value of type
// *ZoomConfigFullResponseBody.
func unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull(v *ZoomConfigFullResponseBody) *meetingservice.ZoomConfigFull {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigFull{
		MeetingID:                v.MeetingID,
		Passcode:                 v.Passcode,
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence builds a value of
// type *meetingservice.Occurrence from a value of type *OccurrenceResponseBody.
func unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence(v *OccurrenceResponseBody) *meetingservice.Occurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Occurrence{
		OccurrenceID:     v.OccurrenceID,
		StartTime:        v.StartTime,
		Title:            v.Title,
		Description:      v.Description,
		Duration:         v.Duration,
		RegistrantCount:  v.RegistrantCount,
		ResponseCountNo:  v.ResponseCountNo,
		ResponseCountYes: v.ResponseCountYes,
		IsCancelled:      v.IsCancelled,
	}
	if v.Recurrence != nil {
		res.Recurrence = unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v.Recurrence)
	}

	return res
}

// marshalMeetingserviceRecurrenceToRecurrenceRequestBody builds a value of
// type *RecurrenceRequestBody from a value of type *meetingservice.Recurrence.
func marshalMeetingserviceRecurrenceToRecurrenceRequestBody(v *meetingservice.Recurrence) *RecurrenceRequestBody {
	if v == nil {
		return nil
	}
	res := &RecurrenceRequestBody{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalMeetingserviceCommitteeToCommitteeRequestBody builds a value of type
// *CommitteeRequestBody from a value of type *meetingservice.Committee.
func marshalMeetingserviceCommitteeToCommitteeRequestBody(v *meetingservice.Committee) *CommitteeRequestBody {
	if v == nil {
		return nil
	}
	res := &CommitteeRequestBody{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	} else {
		res.AllowedVotingStatuses = []string{}
	}

	return res
}

// marshalMeetingserviceZoomConfigPostToZoomConfigPostRequestBody builds a
// value of type *ZoomConfigPostRequestBody from a value of type
// *meetingservice.ZoomConfigPost.
func marshalMeetingserviceZoomConfigPostToZoomConfigPostRequestBody(v *meetingservice.ZoomConfigPost) *ZoomConfigPostRequestBody {
	if v == nil {
		return nil
	}
	res := &ZoomConfigPostRequestBody{
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalRecurrenceRequestBodyToMeetingserviceRecurrence builds a value of
// type *meetingservice.Recurrence from a value of type *RecurrenceRequestBody.
func marshalRecurrenceRequestBodyToMeetingserviceRecurrence(v *RecurrenceRequestBody) *meetingservice.Recurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Recurrence{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalCommitteeRequestBodyToMeetingserviceCommittee builds a value of type
// *meetingservice.Committee from a value of type *CommitteeRequestBody.
func marshalCommitteeRequestBodyToMeetingserviceCommittee(v *CommitteeRequestBody) *meetingservice.Committee {
	if v == nil {
		return nil
	}
	res := &meetingservice.Committee{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	} else {
		res.AllowedVotingStatuses = []string{}
	}

	return res
}

// marshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost builds a
// value of type *meetingservice.ZoomConfigPost from a value of type
// *ZoomConfigPostRequestBody.
func marshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(v *ZoomConfigPostRequestBody) *meetingservice.ZoomConfigPost {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigPost{
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// unmarshalRegistrantResponseBodyToMeetingserviceRegistrant builds a value of
// type *meetingservice.Registrant from a value of type *RegistrantResponseBody.
func unmarshalRegistrantResponseBodyToMeetingserviceRegistrant(v *RegistrantResponseBody) *meetingservice.Registrant {
	res := &meetingservice.Registrant{
		UID:                *v.UID,
		MeetingUID:         *v.MeetingUID,
		Email:              *v.Email,
		FirstName:          v.FirstName,
		LastName:           v.LastName,
		Host:               v.Host,
		JobTitle:           v.JobTitle,
		OccurrenceID:       v.OccurrenceID,
		OrgName:            v.OrgName,
		OrgIsMember:        v.OrgIsMember,
		OrgIsProjectMember: v.OrgIsProjectMember,
		AvatarURL:          v.AvatarURL,
		Username:           v.Username,
		CreatedAt:          v.CreatedAt,
		UpdatedAt:          v.UpdatedAt,
	}

	return res
}

// unmarshalPastMeetingResponseBodyToMeetingservicePastMeeting builds a value
// of type *meetingservice.PastMeeting from a value of type
// *PastMeetingResponseBody.
func unmarshalPastMeetingResponseBodyToMeetingservicePastMeeting(v *PastMeetingResponseBody) *meetingservice.PastMeeting {
	res := &meetingservice.PastMeeting{
		UID:                  v.UID,
		MeetingUID:           v.MeetingUID,
		OccurrenceID:         v.OccurrenceID,
		ProjectUID:           v.ProjectUID,
		ScheduledStartTime:   v.ScheduledStartTime,
		ScheduledEndTime:     v.ScheduledEndTime,
		Duration:             v.Duration,
		Timezone:             v.Timezone,
		Title:                v.Title,
		Description:          v.Description,
		Platform:             v.Platform,
		PlatformMeetingID:    v.PlatformMeetingID,
		EarlyJoinTimeMinutes: v.EarlyJoinTimeMinutes,
		MeetingType:          v.MeetingType,
		Visibility:           v.Visibility,
		Restricted:           v.Restricted,
		ArtifactVisibility:   v.ArtifactVisibility,
		PublicLink:           v.PublicLink,
		RecordingEnabled:     v.RecordingEnabled,
		TranscriptEnabled:    v.TranscriptEnabled,
		YoutubeUploadEnabled: v.YoutubeUploadEnabled,
		CreatedAt:            v.CreatedAt,
		UpdatedAt:            v.UpdatedAt,
	}
	if v.Recurrence != nil {
		res.Recurrence = unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v.Recurrence)
	}
	if v.Committees != nil {
		res.Committees = make([]*meetingservice.Committee, len(v.Committees))
		for i, val := range v.Committees {
			res.Committees[i] = unmarshalCommitteeResponseBodyToMeetingserviceCommittee(val)
		}
	}
	if v.ZoomConfig != nil {
		res.ZoomConfig = unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull(v.ZoomConfig)
	}
	if v.Sessions != nil {
		res.Sessions = make([]*meetingservice.Session, len(v.Sessions))
		for i, val := range v.Sessions {
			res.Sessions[i] = unmarshalSessionResponseBodyToMeetingserviceSession(val)
		}
	}

	return res
}

// unmarshalSessionResponseBodyToMeetingserviceSession builds a value of type
// *meetingservice.Session from a value of type *SessionResponseBody.
func unmarshalSessionResponseBodyToMeetingserviceSession(v *SessionResponseBody) *meetingservice.Session {
	if v == nil {
		return nil
	}
	res := &meetingservice.Session{
		UID:       *v.UID,
		StartTime: *v.StartTime,
		EndTime:   v.EndTime,
	}

	return res
}

// marshalMeetingserviceZoomConfigFullToZoomConfigFullRequestBody builds a
// value of type *ZoomConfigFullRequestBody from a value of type
// *meetingservice.ZoomConfigFull.
func marshalMeetingserviceZoomConfigFullToZoomConfigFullRequestBody(v *meetingservice.ZoomConfigFull) *ZoomConfigFullRequestBody {
	if v == nil {
		return nil
	}
	res := &ZoomConfigFullRequestBody{
		MeetingID:                v.MeetingID,
		Passcode:                 v.Passcode,
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalMeetingserviceSessionToSessionRequestBody builds a value of type
// *SessionRequestBody from a value of type *meetingservice.Session.
func marshalMeetingserviceSessionToSessionRequestBody(v *meetingservice.Session) *SessionRequestBody {
	if v == nil {
		return nil
	}
	res := &SessionRequestBody{
		UID:       v.UID,
		StartTime: v.StartTime,
		EndTime:   v.EndTime,
	}

	return res
}

// marshalZoomConfigFullRequestBodyToMeetingserviceZoomConfigFull builds a
// value of type *meetingservice.ZoomConfigFull from a value of type
// *ZoomConfigFullRequestBody.
func marshalZoomConfigFullRequestBodyToMeetingserviceZoomConfigFull(v *ZoomConfigFullRequestBody) *meetingservice.ZoomConfigFull {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigFull{
		MeetingID:                v.MeetingID,
		Passcode:                 v.Passcode,
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalSessionRequestBodyToMeetingserviceSession builds a value of type
// *meetingservice.Session from a value of type *SessionRequestBody.
func marshalSessionRequestBodyToMeetingserviceSession(v *SessionRequestBody) *meetingservice.Session {
	if v == nil {
		return nil
	}
	res := &meetingservice.Session{
		UID:       v.UID,
		StartTime: v.StartTime,
		EndTime:   v.EndTime,
	}

	return res
}

// unmarshalPastMeetingParticipantResponseBodyToMeetingservicePastMeetingParticipant
// builds a value of type *meetingservice.PastMeetingParticipant from a value
// of type *PastMeetingParticipantResponseBody.
func unmarshalPastMeetingParticipantResponseBodyToMeetingservicePastMeetingParticipant(v *PastMeetingParticipantResponseBody) *meetingservice.PastMeetingParticipant {
	res := &meetingservice.PastMeetingParticipant{
		UID:                *v.UID,
		PastMeetingUID:     *v.PastMeetingUID,
		MeetingUID:         *v.MeetingUID,
		Email:              *v.Email,
		FirstName:          v.FirstName,
		LastName:           v.LastName,
		Host:               v.Host,
		JobTitle:           v.JobTitle,
		OrgName:            v.OrgName,
		OrgIsMember:        v.OrgIsMember,
		OrgIsProjectMember: v.OrgIsProjectMember,
		AvatarURL:          v.AvatarURL,
		Username:           v.Username,
		IsInvited:          v.IsInvited,
		IsAttended:         v.IsAttended,
		CreatedAt:          v.CreatedAt,
		UpdatedAt:          v.UpdatedAt,
	}

	return res
}
