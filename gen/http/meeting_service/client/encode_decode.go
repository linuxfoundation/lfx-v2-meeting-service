// Code generated by goa v3.21.1, DO NOT EDIT.
//
// Meeting Service HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goahttp "goa.design/goa/v3/http"
)

// BuildGetMeetingsRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "get-meetings" endpoint
func (c *Client) BuildGetMeetingsRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingsMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meetings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingsRequest returns an encoder for requests sent to the Meeting
// Service get-meetings server.
func EncodeGetMeetingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meetings", "*meetingservice.GetMeetingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingsResponse returns a decoder for responses returned by the
// Meeting Service get-meetings endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetMeetingsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetMeetingsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusBadRequest:
			var (
				body GetMeetingsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body GetMeetingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meetings", err)
			}
			err = ValidateGetMeetingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meetings", err)
			}
			return nil, NewGetMeetingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meetings", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateMeetingRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "create-meeting" endpoint
func (c *Client) BuildCreateMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateMeetingMeetingServicePath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateMeetingRequest returns an encoder for requests sent to the
// Meeting Service create-meeting server.
func EncodeCreateMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreateMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-meeting", "*meetingservice.CreateMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreateMeetingRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-meeting", err)
		}
		return nil
	}
}

// DecodeCreateMeetingResponse returns a decoder for responses returned by the
// Meeting Service create-meeting endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeCreateMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreateMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateMeetingResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			res := NewCreateMeetingMeetingFullCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreateMeetingConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreateMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingInternalServerError(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreateMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting", err)
			}
			err = ValidateCreateMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting", err)
			}
			return nil, NewCreateMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingBaseRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "get-meeting-base"
// endpoint
func (c *Client) BuildGetMeetingBaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingBasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-base", "*meetingservice.GetMeetingBasePayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingBaseMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-base", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingBaseRequest returns an encoder for requests sent to the
// Meeting Service get-meeting-base server.
func EncodeGetMeetingBaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingBasePayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-base", "*meetingservice.GetMeetingBasePayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingBaseResponse returns a decoder for responses returned by the
// Meeting Service get-meeting-base endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetMeetingBaseResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingBaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingBaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingBaseResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingBaseInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingBaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingBaseServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-base", err)
			}
			err = ValidateGetMeetingBaseServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-base", err)
			}
			return nil, NewGetMeetingBaseServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-base", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingSettingsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-settings" endpoint
func (c *Client) BuildGetMeetingSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-settings", "*meetingservice.GetMeetingSettingsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingSettingsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-settings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingSettingsRequest returns an encoder for requests sent to the
// Meeting Service get-meeting-settings server.
func EncodeGetMeetingSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-settings", "*meetingservice.GetMeetingSettingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingSettingsResponse returns a decoder for responses returned by
// the Meeting Service get-meeting-settings endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetMeetingSettingsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingSettingsResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingSettingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingSettingsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingSettingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-settings", err)
			}
			err = ValidateGetMeetingSettingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-settings", err)
			}
			return nil, NewGetMeetingSettingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-settings", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingBaseRequest instantiates a HTTP request object with method
// and path set to call the "Meeting Service" service "update-meeting-base"
// endpoint
func (c *Client) BuildUpdateMeetingBaseRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingBasePayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-base", "*meetingservice.UpdateMeetingBasePayload", v)
		}
		uid = p.UID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingBaseMeetingServicePath(uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-base", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingBaseRequest returns an encoder for requests sent to the
// Meeting Service update-meeting-base server.
func EncodeUpdateMeetingBaseRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingBasePayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-base", "*meetingservice.UpdateMeetingBasePayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingBaseRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-base", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingBaseResponse returns a decoder for responses returned by
// the Meeting Service update-meeting-base endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeUpdateMeetingBaseResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingBaseResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingBaseResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			res := NewUpdateMeetingBaseMeetingBaseOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingBaseBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdateMeetingBaseConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseConflict(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingBaseInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingBaseNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingBaseServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-base", err)
			}
			err = ValidateUpdateMeetingBaseServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-base", err)
			}
			return nil, NewUpdateMeetingBaseServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-base", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingSettingsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "update-meeting-settings" endpoint
func (c *Client) BuildUpdateMeetingSettingsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingSettingsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-settings", "*meetingservice.UpdateMeetingSettingsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingSettingsMeetingServicePath(uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-settings", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingSettingsRequest returns an encoder for requests sent to
// the Meeting Service update-meeting-settings server.
func EncodeUpdateMeetingSettingsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingSettingsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-settings", "*meetingservice.UpdateMeetingSettingsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingSettingsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-settings", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingSettingsResponse returns a decoder for responses returned
// by the Meeting Service update-meeting-settings endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeUpdateMeetingSettingsResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingSettingsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingSettingsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			res := NewUpdateMeetingSettingsMeetingSettingsOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingSettingsBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingSettingsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingSettingsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingSettingsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-settings", err)
			}
			err = ValidateUpdateMeetingSettingsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-settings", err)
			}
			return nil, NewUpdateMeetingSettingsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-settings", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMeetingRequest instantiates a HTTP request object with method and
// path set to call the "Meeting Service" service "delete-meeting" endpoint
func (c *Client) BuildDeleteMeetingRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.DeleteMeetingPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-meeting", "*meetingservice.DeleteMeetingPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMeetingMeetingServicePath(uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-meeting", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMeetingRequest returns an encoder for requests sent to the
// Meeting Service delete-meeting server.
func EncodeDeleteMeetingRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeleteMeetingPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-meeting", "*meetingservice.DeleteMeetingPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeleteMeetingResponse returns a decoder for responses returned by the
// Meeting Service delete-meeting endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeDeleteMeetingResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeleteMeetingResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteMeetingBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteMeetingInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeleteMeetingNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeleteMeetingServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting", err)
			}
			err = ValidateDeleteMeetingServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting", err)
			}
			return nil, NewDeleteMeetingServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-meeting", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingRegistrantsRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-registrants" endpoint
func (c *Client) BuildGetMeetingRegistrantsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		uid string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingRegistrantsPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrants", "*meetingservice.GetMeetingRegistrantsPayload", v)
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingRegistrantsMeetingServicePath(uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-registrants", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingRegistrantsRequest returns an encoder for requests sent to
// the Meeting Service get-meeting-registrants server.
func EncodeGetMeetingRegistrantsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingRegistrantsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrants", "*meetingservice.GetMeetingRegistrantsPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingRegistrantsResponse returns a decoder for responses returned
// by the Meeting Service get-meeting-registrants endpoint. restoreBody
// controls whether the response body should be restored after having been read.
// DecodeGetMeetingRegistrantsResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingRegistrantsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingRegistrantsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			var (
				cacheControl *string
			)
			cacheControlRaw := resp.Header.Get("Cache-Control")
			if cacheControlRaw != "" {
				cacheControl = &cacheControlRaw
			}
			res := NewGetMeetingRegistrantsResultOK(&body, cacheControl)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingRegistrantsInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingRegistrantsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingRegistrantsServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrants", err)
			}
			err = ValidateGetMeetingRegistrantsServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrants", err)
			}
			return nil, NewGetMeetingRegistrantsServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-registrants", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "create-meeting-registrant" endpoint
func (c *Client) BuildCreateMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
	)
	{
		p, ok := v.(*meetingservice.CreateMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "create-meeting-registrant", "*meetingservice.CreateMeetingRegistrantPayload", v)
		}
		meetingUID = p.MeetingUID
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateMeetingRegistrantMeetingServicePath(meetingUID)}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "create-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service create-meeting-registrant server.
func EncodeCreateMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.CreateMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "create-meeting-registrant", "*meetingservice.CreateMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewCreateMeetingRegistrantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "create-meeting-registrant", err)
		}
		return nil
	}
}

// DecodeCreateMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service create-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeCreateMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeCreateMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body CreateMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			res := NewCreateMeetingRegistrantRegistrantCreated(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body CreateMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantBadRequest(&body)
		case http.StatusConflict:
			var (
				body CreateMeetingRegistrantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body CreateMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body CreateMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body CreateMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "create-meeting-registrant", err)
			}
			err = ValidateCreateMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "create-meeting-registrant", err)
			}
			return nil, NewCreateMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "create-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildGetMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "get-meeting-registrant" endpoint
func (c *Client) BuildGetMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.GetMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrant", "*meetingservice.GetMeetingRegistrantPayload", v)
		}
		if p.MeetingUID != nil {
			meetingUID = *p.MeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "get-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service get-meeting-registrant server.
func EncodeGetMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.GetMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "get-meeting-registrant", "*meetingservice.GetMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetMeetingRegistrantResponse returns a decoder for responses returned
// by the Meeting Service get-meeting-registrant endpoint. restoreBody controls
// whether the response body should be restored after having been read.
// DecodeGetMeetingRegistrantResponse may return the following errors:
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeGetMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			var (
				etag *string
			)
			etagRaw := resp.Header.Get("Etag")
			if etagRaw != "" {
				etag = &etagRaw
			}
			res := NewGetMeetingRegistrantResultOK(&body, etag)
			return res, nil
		case http.StatusInternalServerError:
			var (
				body GetMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body GetMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body GetMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "get-meeting-registrant", err)
			}
			err = ValidateGetMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "get-meeting-registrant", err)
			}
			return nil, NewGetMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "get-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildUpdateMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "update-meeting-registrant" endpoint
func (c *Client) BuildUpdateMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.UpdateMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "update-meeting-registrant", "*meetingservice.UpdateMeetingRegistrantPayload", v)
		}
		meetingUID = p.MeetingUID
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: UpdateMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("PUT", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "update-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeUpdateMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service update-meeting-registrant server.
func EncodeUpdateMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.UpdateMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "update-meeting-registrant", "*meetingservice.UpdateMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		body := NewUpdateMeetingRegistrantRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Meeting Service", "update-meeting-registrant", err)
		}
		return nil
	}
}

// DecodeUpdateMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service update-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeUpdateMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "Conflict" (type *meetingservice.ConflictError): http.StatusConflict
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeUpdateMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body UpdateMeetingRegistrantResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			res := NewUpdateMeetingRegistrantRegistrantOK(&body)
			return res, nil
		case http.StatusBadRequest:
			var (
				body UpdateMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantBadRequest(&body)
		case http.StatusConflict:
			var (
				body UpdateMeetingRegistrantConflictResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantConflictResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantConflict(&body)
		case http.StatusInternalServerError:
			var (
				body UpdateMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body UpdateMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body UpdateMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "update-meeting-registrant", err)
			}
			err = ValidateUpdateMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "update-meeting-registrant", err)
			}
			return nil, NewUpdateMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "update-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildDeleteMeetingRegistrantRequest instantiates a HTTP request object with
// method and path set to call the "Meeting Service" service
// "delete-meeting-registrant" endpoint
func (c *Client) BuildDeleteMeetingRegistrantRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		meetingUID string
		uid        string
	)
	{
		p, ok := v.(*meetingservice.DeleteMeetingRegistrantPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Meeting Service", "delete-meeting-registrant", "*meetingservice.DeleteMeetingRegistrantPayload", v)
		}
		if p.MeetingUID != nil {
			meetingUID = *p.MeetingUID
		}
		if p.UID != nil {
			uid = *p.UID
		}
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DeleteMeetingRegistrantMeetingServicePath(meetingUID, uid)}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "delete-meeting-registrant", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDeleteMeetingRegistrantRequest returns an encoder for requests sent to
// the Meeting Service delete-meeting-registrant server.
func EncodeDeleteMeetingRegistrantRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*meetingservice.DeleteMeetingRegistrantPayload)
		if !ok {
			return goahttp.ErrInvalidType("Meeting Service", "delete-meeting-registrant", "*meetingservice.DeleteMeetingRegistrantPayload", v)
		}
		if p.BearerToken != nil {
			head := *p.BearerToken
			if !strings.Contains(head, " ") {
				req.Header.Set("Authorization", "Bearer "+head)
			} else {
				req.Header.Set("Authorization", head)
			}
		}
		if p.IfMatch != nil {
			head := *p.IfMatch
			req.Header.Set("If-Match", head)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("v", *p.Version)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeDeleteMeetingRegistrantResponse returns a decoder for responses
// returned by the Meeting Service delete-meeting-registrant endpoint.
// restoreBody controls whether the response body should be restored after
// having been read.
// DecodeDeleteMeetingRegistrantResponse may return the following errors:
//   - "BadRequest" (type *meetingservice.BadRequestError): http.StatusBadRequest
//   - "InternalServerError" (type *meetingservice.InternalServerError): http.StatusInternalServerError
//   - "NotFound" (type *meetingservice.NotFoundError): http.StatusNotFound
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeDeleteMeetingRegistrantResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusNoContent:
			return nil, nil
		case http.StatusBadRequest:
			var (
				body DeleteMeetingRegistrantBadRequestResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantBadRequestResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantBadRequest(&body)
		case http.StatusInternalServerError:
			var (
				body DeleteMeetingRegistrantInternalServerErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantInternalServerErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantInternalServerError(&body)
		case http.StatusNotFound:
			var (
				body DeleteMeetingRegistrantNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantNotFound(&body)
		case http.StatusServiceUnavailable:
			var (
				body DeleteMeetingRegistrantServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "delete-meeting-registrant", err)
			}
			err = ValidateDeleteMeetingRegistrantServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "delete-meeting-registrant", err)
			}
			return nil, NewDeleteMeetingRegistrantServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "delete-meeting-registrant", resp.StatusCode, string(body))
		}
	}
}

// BuildReadyzRequest instantiates a HTTP request object with method and path
// set to call the "Meeting Service" service "readyz" endpoint
func (c *Client) BuildReadyzRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ReadyzMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "readyz", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeReadyzResponse returns a decoder for responses returned by the Meeting
// Service readyz endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeReadyzResponse may return the following errors:
//   - "ServiceUnavailable" (type *meetingservice.ServiceUnavailableError): http.StatusServiceUnavailable
//   - error: internal error
func DecodeReadyzResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []byte
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "readyz", err)
			}
			return body, nil
		case http.StatusServiceUnavailable:
			var (
				body ReadyzServiceUnavailableResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "readyz", err)
			}
			err = ValidateReadyzServiceUnavailableResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Meeting Service", "readyz", err)
			}
			return nil, NewReadyzServiceUnavailable(&body)
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "readyz", resp.StatusCode, string(body))
		}
	}
}

// BuildLivezRequest instantiates a HTTP request object with method and path
// set to call the "Meeting Service" service "livez" endpoint
func (c *Client) BuildLivezRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: LivezMeetingServicePath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Meeting Service", "livez", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeLivezResponse returns a decoder for responses returned by the Meeting
// Service livez endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeLivezResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []byte
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Meeting Service", "livez", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Meeting Service", "livez", resp.StatusCode, string(body))
		}
	}
}

// unmarshalMeetingFullResponseBodyToMeetingserviceMeetingFull builds a value
// of type *meetingservice.MeetingFull from a value of type
// *MeetingFullResponseBody.
func unmarshalMeetingFullResponseBodyToMeetingserviceMeetingFull(v *MeetingFullResponseBody) *meetingservice.MeetingFull {
	res := &meetingservice.MeetingFull{
		UID:                             v.UID,
		ProjectUID:                      v.ProjectUID,
		StartTime:                       v.StartTime,
		Duration:                        v.Duration,
		Timezone:                        v.Timezone,
		Title:                           v.Title,
		Description:                     v.Description,
		Platform:                        v.Platform,
		EarlyJoinTimeMinutes:            v.EarlyJoinTimeMinutes,
		MeetingType:                     v.MeetingType,
		Visibility:                      v.Visibility,
		Restricted:                      v.Restricted,
		ArtifactVisibility:              v.ArtifactVisibility,
		JoinURL:                         v.JoinURL,
		PublicLink:                      v.PublicLink,
		EmailDeliveryErrorCount:         v.EmailDeliveryErrorCount,
		RecordingEnabled:                v.RecordingEnabled,
		TranscriptEnabled:               v.TranscriptEnabled,
		YoutubeUploadEnabled:            v.YoutubeUploadEnabled,
		RegistrantCount:                 v.RegistrantCount,
		RegistrantResponseDeclinedCount: v.RegistrantResponseDeclinedCount,
		RegistrantResponseAcceptedCount: v.RegistrantResponseAcceptedCount,
		CreatedAt:                       v.CreatedAt,
		UpdatedAt:                       v.UpdatedAt,
	}
	if v.Recurrence != nil {
		res.Recurrence = unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v.Recurrence)
	}
	if v.Committees != nil {
		res.Committees = make([]*meetingservice.Committee, len(v.Committees))
		for i, val := range v.Committees {
			res.Committees[i] = unmarshalCommitteeResponseBodyToMeetingserviceCommittee(val)
		}
	}
	if v.ZoomConfig != nil {
		res.ZoomConfig = unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull(v.ZoomConfig)
	}
	if v.Occurrences != nil {
		res.Occurrences = make([]*meetingservice.Occurrence, len(v.Occurrences))
		for i, val := range v.Occurrences {
			res.Occurrences[i] = unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence(val)
		}
	}
	if v.Organizers != nil {
		res.Organizers = make([]string, len(v.Organizers))
		for i, val := range v.Organizers {
			res.Organizers[i] = val
		}
	}

	return res
}

// unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence builds a value of
// type *meetingservice.Recurrence from a value of type *RecurrenceResponseBody.
func unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v *RecurrenceResponseBody) *meetingservice.Recurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Recurrence{
		Type:           *v.Type,
		RepeatInterval: *v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// unmarshalCommitteeResponseBodyToMeetingserviceCommittee builds a value of
// type *meetingservice.Committee from a value of type *CommitteeResponseBody.
func unmarshalCommitteeResponseBodyToMeetingserviceCommittee(v *CommitteeResponseBody) *meetingservice.Committee {
	if v == nil {
		return nil
	}
	res := &meetingservice.Committee{
		UID: *v.UID,
	}
	res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
	for i, val := range v.AllowedVotingStatuses {
		res.AllowedVotingStatuses[i] = val
	}

	return res
}

// unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull builds a
// value of type *meetingservice.ZoomConfigFull from a value of type
// *ZoomConfigFullResponseBody.
func unmarshalZoomConfigFullResponseBodyToMeetingserviceZoomConfigFull(v *ZoomConfigFullResponseBody) *meetingservice.ZoomConfigFull {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigFull{
		MeetingID:                v.MeetingID,
		Passcode:                 v.Passcode,
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence builds a value of
// type *meetingservice.Occurrence from a value of type *OccurrenceResponseBody.
func unmarshalOccurrenceResponseBodyToMeetingserviceOccurrence(v *OccurrenceResponseBody) *meetingservice.Occurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Occurrence{
		OccurrenceID:     v.OccurrenceID,
		StartTime:        v.StartTime,
		Title:            v.Title,
		Description:      v.Description,
		Duration:         v.Duration,
		RegistrantCount:  v.RegistrantCount,
		ResponseCountNo:  v.ResponseCountNo,
		ResponseCountYes: v.ResponseCountYes,
		Status:           v.Status,
	}
	if v.Recurrence != nil {
		res.Recurrence = unmarshalRecurrenceResponseBodyToMeetingserviceRecurrence(v.Recurrence)
	}

	return res
}

// marshalMeetingserviceRecurrenceToRecurrenceRequestBody builds a value of
// type *RecurrenceRequestBody from a value of type *meetingservice.Recurrence.
func marshalMeetingserviceRecurrenceToRecurrenceRequestBody(v *meetingservice.Recurrence) *RecurrenceRequestBody {
	if v == nil {
		return nil
	}
	res := &RecurrenceRequestBody{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalMeetingserviceCommitteeToCommitteeRequestBody builds a value of type
// *CommitteeRequestBody from a value of type *meetingservice.Committee.
func marshalMeetingserviceCommitteeToCommitteeRequestBody(v *meetingservice.Committee) *CommitteeRequestBody {
	if v == nil {
		return nil
	}
	res := &CommitteeRequestBody{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	} else {
		res.AllowedVotingStatuses = []string{}
	}

	return res
}

// marshalMeetingserviceZoomConfigPostToZoomConfigPostRequestBody builds a
// value of type *ZoomConfigPostRequestBody from a value of type
// *meetingservice.ZoomConfigPost.
func marshalMeetingserviceZoomConfigPostToZoomConfigPostRequestBody(v *meetingservice.ZoomConfigPost) *ZoomConfigPostRequestBody {
	if v == nil {
		return nil
	}
	res := &ZoomConfigPostRequestBody{
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// marshalRecurrenceRequestBodyToMeetingserviceRecurrence builds a value of
// type *meetingservice.Recurrence from a value of type *RecurrenceRequestBody.
func marshalRecurrenceRequestBodyToMeetingserviceRecurrence(v *RecurrenceRequestBody) *meetingservice.Recurrence {
	if v == nil {
		return nil
	}
	res := &meetingservice.Recurrence{
		Type:           v.Type,
		RepeatInterval: v.RepeatInterval,
		WeeklyDays:     v.WeeklyDays,
		MonthlyDay:     v.MonthlyDay,
		MonthlyWeek:    v.MonthlyWeek,
		MonthlyWeekDay: v.MonthlyWeekDay,
		EndTimes:       v.EndTimes,
		EndDateTime:    v.EndDateTime,
	}

	return res
}

// marshalCommitteeRequestBodyToMeetingserviceCommittee builds a value of type
// *meetingservice.Committee from a value of type *CommitteeRequestBody.
func marshalCommitteeRequestBodyToMeetingserviceCommittee(v *CommitteeRequestBody) *meetingservice.Committee {
	if v == nil {
		return nil
	}
	res := &meetingservice.Committee{
		UID: v.UID,
	}
	if v.AllowedVotingStatuses != nil {
		res.AllowedVotingStatuses = make([]string, len(v.AllowedVotingStatuses))
		for i, val := range v.AllowedVotingStatuses {
			res.AllowedVotingStatuses[i] = val
		}
	} else {
		res.AllowedVotingStatuses = []string{}
	}

	return res
}

// marshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost builds a
// value of type *meetingservice.ZoomConfigPost from a value of type
// *ZoomConfigPostRequestBody.
func marshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(v *ZoomConfigPostRequestBody) *meetingservice.ZoomConfigPost {
	if v == nil {
		return nil
	}
	res := &meetingservice.ZoomConfigPost{
		AiCompanionEnabled:       v.AiCompanionEnabled,
		AiSummaryRequireApproval: v.AiSummaryRequireApproval,
	}

	return res
}

// unmarshalRegistrantResponseBodyToMeetingserviceRegistrant builds a value of
// type *meetingservice.Registrant from a value of type *RegistrantResponseBody.
func unmarshalRegistrantResponseBodyToMeetingserviceRegistrant(v *RegistrantResponseBody) *meetingservice.Registrant {
	res := &meetingservice.Registrant{
		UID:                *v.UID,
		MeetingUID:         *v.MeetingUID,
		Email:              *v.Email,
		FirstName:          *v.FirstName,
		LastName:           *v.LastName,
		Host:               v.Host,
		JobTitle:           v.JobTitle,
		OccurrenceID:       v.OccurrenceID,
		OrgName:            v.OrgName,
		OrgIsMember:        v.OrgIsMember,
		OrgIsProjectMember: v.OrgIsProjectMember,
		AvatarURL:          v.AvatarURL,
		Username:           v.Username,
		CreatedAt:          v.CreatedAt,
		UpdatedAt:          v.UpdatedAt,
	}

	return res
}
