// Code generated by goa v3.23.1, DO NOT EDIT.
//
// Meeting Service HTTP client CLI support package
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goa "goa.design/goa/v3/pkg"
)

// BuildGetMeetingsPayload builds the payload for the Meeting Service
// get-meetings endpoint from CLI flags.
func BuildGetMeetingsPayload(meetingServiceGetMeetingsVersion string, meetingServiceGetMeetingsIncludeCancelledOccurrences string, meetingServiceGetMeetingsBearerToken string) (*meetingservice.GetMeetingsPayload, error) {
	var err error
	var version *string
	{
		if meetingServiceGetMeetingsVersion != "" {
			version = &meetingServiceGetMeetingsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var includeCancelledOccurrences bool
	{
		if meetingServiceGetMeetingsIncludeCancelledOccurrences != "" {
			includeCancelledOccurrences, err = strconv.ParseBool(meetingServiceGetMeetingsIncludeCancelledOccurrences)
			if err != nil {
				return nil, fmt.Errorf("invalid value for includeCancelledOccurrences, must be BOOL")
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingsBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingsBearerToken
		}
	}
	v := &meetingservice.GetMeetingsPayload{}
	v.Version = version
	v.IncludeCancelledOccurrences = includeCancelledOccurrences
	v.BearerToken = bearerToken

	return v, nil
}

// BuildCreateMeetingPayload builds the payload for the Meeting Service
// create-meeting endpoint from CLI flags.
func BuildCreateMeetingPayload(meetingServiceCreateMeetingBody string, meetingServiceCreateMeetingVersion string, meetingServiceCreateMeetingBearerToken string, meetingServiceCreateMeetingXSync string) (*meetingservice.CreateMeetingPayload, error) {
	var err error
	var body CreateMeetingRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateMeetingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"public\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         }\n      ],\n      \"description\": \"ti7\",\n      \"duration\": 44,\n      \"early_join_time_minutes\": 28,\n      \"meeting_type\": \"Marketing\",\n      \"organizers\": [\n         \"Maiores porro at itaque qui nemo dolores.\",\n         \"Autem tempore dolor ad sit voluptatem delectus.\"\n      ],\n      \"platform\": \"Zoom\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"recording_enabled\": false,\n      \"recurrence\": {\n         \"end_date_time\": \"1977-02-15T17:20:58Z\",\n         \"end_times\": 1614259243833301344,\n         \"monthly_day\": 15,\n         \"monthly_week\": 3,\n         \"monthly_week_day\": 2,\n         \"repeat_interval\": 7893986229654679884,\n         \"type\": 3,\n         \"weekly_days\": \"1,3,5\"\n      },\n      \"restricted\": false,\n      \"show_meeting_attendees\": false,\n      \"start_time\": \"2021-01-01T00:00:00Z\",\n      \"timezone\": \"Culpa voluptatibus natus quisquam eveniet ullam.\",\n      \"title\": \"Quidem voluptatem.\",\n      \"transcript_enabled\": false,\n      \"visibility\": \"private\",\n      \"youtube_upload_enabled\": true,\n      \"zoom_config\": {\n         \"ai_companion_enabled\": false,\n         \"ai_summary_require_approval\": true\n      }\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", body.ProjectUID, goa.FormatUUID))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", body.StartTime, goa.FormatDateTime))
		if body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 0, true))
		}
		if body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 600, false))
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if utf8.RuneCountInString(body.Description) > 2000 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", body.Description, utf8.RuneCountInString(body.Description), 2000, false))
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.Platform != nil {
			if !(*body.Platform == "Zoom") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.Visibility != nil {
			if !(*body.Visibility == "public" || *body.Visibility == "private") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreateMeetingVersion != "" {
			version = &meetingServiceCreateMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateMeetingBearerToken != "" {
			bearerToken = &meetingServiceCreateMeetingBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreateMeetingXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreateMeetingXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreateMeetingPayload{
		ProjectUID:           body.ProjectUID,
		StartTime:            body.StartTime,
		Duration:             body.Duration,
		Timezone:             body.Timezone,
		Title:                body.Title,
		Description:          body.Description,
		Platform:             body.Platform,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		MeetingType:          body.MeetingType,
		Visibility:           body.Visibility,
		Restricted:           body.Restricted,
		ArtifactVisibility:   body.ArtifactVisibility,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
		ShowMeetingAttendees: body.ShowMeetingAttendees,
	}
	if body.Recurrence != nil {
		v.Recurrence = marshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.Organizers != nil {
		v.Organizers = make([]string, len(body.Organizers))
		for i, val := range body.Organizers {
			v.Organizers[i] = val
		}
	}
	if body.ZoomConfig != nil {
		v.ZoomConfig = marshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(body.ZoomConfig)
	}
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetMeetingBasePayload builds the payload for the Meeting Service
// get-meeting-base endpoint from CLI flags.
func BuildGetMeetingBasePayload(meetingServiceGetMeetingBaseUID string, meetingServiceGetMeetingBaseVersion string, meetingServiceGetMeetingBaseIncludeCancelledOccurrences string, meetingServiceGetMeetingBaseBearerToken string) (*meetingservice.GetMeetingBasePayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceGetMeetingBaseUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetMeetingBaseVersion != "" {
			version = &meetingServiceGetMeetingBaseVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var includeCancelledOccurrences bool
	{
		if meetingServiceGetMeetingBaseIncludeCancelledOccurrences != "" {
			includeCancelledOccurrences, err = strconv.ParseBool(meetingServiceGetMeetingBaseIncludeCancelledOccurrences)
			if err != nil {
				return nil, fmt.Errorf("invalid value for includeCancelledOccurrences, must be BOOL")
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingBaseBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingBaseBearerToken
		}
	}
	v := &meetingservice.GetMeetingBasePayload{}
	v.UID = &uid
	v.Version = version
	v.IncludeCancelledOccurrences = includeCancelledOccurrences
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetMeetingSettingsPayload builds the payload for the Meeting Service
// get-meeting-settings endpoint from CLI flags.
func BuildGetMeetingSettingsPayload(meetingServiceGetMeetingSettingsUID string, meetingServiceGetMeetingSettingsVersion string, meetingServiceGetMeetingSettingsBearerToken string) (*meetingservice.GetMeetingSettingsPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceGetMeetingSettingsUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetMeetingSettingsVersion != "" {
			version = &meetingServiceGetMeetingSettingsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingSettingsBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingSettingsBearerToken
		}
	}
	v := &meetingservice.GetMeetingSettingsPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetMeetingJoinURLPayload builds the payload for the Meeting Service
// get-meeting-join-url endpoint from CLI flags.
func BuildGetMeetingJoinURLPayload(meetingServiceGetMeetingJoinURLUID string, meetingServiceGetMeetingJoinURLVersion string, meetingServiceGetMeetingJoinURLBearerToken string) (*meetingservice.GetMeetingJoinURLPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceGetMeetingJoinURLUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetMeetingJoinURLVersion != "" {
			version = &meetingServiceGetMeetingJoinURLVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingJoinURLBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingJoinURLBearerToken
		}
	}
	v := &meetingservice.GetMeetingJoinURLPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateMeetingBasePayload builds the payload for the Meeting Service
// update-meeting-base endpoint from CLI flags.
func BuildUpdateMeetingBasePayload(meetingServiceUpdateMeetingBaseBody string, meetingServiceUpdateMeetingBaseUID string, meetingServiceUpdateMeetingBaseVersion string, meetingServiceUpdateMeetingBaseBearerToken string, meetingServiceUpdateMeetingBaseXSync string, meetingServiceUpdateMeetingBaseIfMatch string) (*meetingservice.UpdateMeetingBasePayload, error) {
	var err error
	var body UpdateMeetingBaseRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateMeetingBaseBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"meeting_hosts\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         }\n      ],\n      \"description\": \"f20\",\n      \"duration\": 518,\n      \"early_join_time_minutes\": 29,\n      \"meeting_type\": \"Technical\",\n      \"platform\": \"Zoom\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"recording_enabled\": false,\n      \"recurrence\": {\n         \"end_date_time\": \"1977-02-15T17:20:58Z\",\n         \"end_times\": 1614259243833301344,\n         \"monthly_day\": 15,\n         \"monthly_week\": 3,\n         \"monthly_week_day\": 2,\n         \"repeat_interval\": 7893986229654679884,\n         \"type\": 3,\n         \"weekly_days\": \"1,3,5\"\n      },\n      \"restricted\": true,\n      \"show_meeting_attendees\": true,\n      \"start_time\": \"2021-01-01T00:00:00Z\",\n      \"timezone\": \"Vero perspiciatis voluptatem aspernatur mollitia dicta.\",\n      \"title\": \"Sint animi maxime rem sed.\",\n      \"transcript_enabled\": true,\n      \"visibility\": \"public\",\n      \"youtube_upload_enabled\": true,\n      \"zoom_config\": {\n         \"ai_companion_enabled\": false,\n         \"ai_summary_require_approval\": true\n      }\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", body.ProjectUID, goa.FormatUUID))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", body.StartTime, goa.FormatDateTime))
		if body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 0, true))
		}
		if body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 600, false))
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if utf8.RuneCountInString(body.Description) > 2000 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", body.Description, utf8.RuneCountInString(body.Description), 2000, false))
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.Platform != nil {
			if !(*body.Platform == "Zoom") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", *body.Platform, []any{"Zoom"}))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.Visibility != nil {
			if !(*body.Visibility == "public" || *body.Visibility == "private") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceUpdateMeetingBaseUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceUpdateMeetingBaseVersion != "" {
			version = &meetingServiceUpdateMeetingBaseVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateMeetingBaseBearerToken != "" {
			bearerToken = &meetingServiceUpdateMeetingBaseBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceUpdateMeetingBaseXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceUpdateMeetingBaseXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceUpdateMeetingBaseIfMatch != "" {
			ifMatch = &meetingServiceUpdateMeetingBaseIfMatch
		}
	}
	v := &meetingservice.UpdateMeetingBasePayload{
		ProjectUID:           body.ProjectUID,
		StartTime:            body.StartTime,
		Duration:             body.Duration,
		Timezone:             body.Timezone,
		Title:                body.Title,
		Description:          body.Description,
		Platform:             body.Platform,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		MeetingType:          body.MeetingType,
		Visibility:           body.Visibility,
		Restricted:           body.Restricted,
		ArtifactVisibility:   body.ArtifactVisibility,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
		ShowMeetingAttendees: body.ShowMeetingAttendees,
	}
	if body.Recurrence != nil {
		v.Recurrence = marshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.ZoomConfig != nil {
		v.ZoomConfig = marshalZoomConfigPostRequestBodyToMeetingserviceZoomConfigPost(body.ZoomConfig)
	}
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildUpdateMeetingSettingsPayload builds the payload for the Meeting Service
// update-meeting-settings endpoint from CLI flags.
func BuildUpdateMeetingSettingsPayload(meetingServiceUpdateMeetingSettingsBody string, meetingServiceUpdateMeetingSettingsUID string, meetingServiceUpdateMeetingSettingsVersion string, meetingServiceUpdateMeetingSettingsBearerToken string, meetingServiceUpdateMeetingSettingsXSync string, meetingServiceUpdateMeetingSettingsIfMatch string) (*meetingservice.UpdateMeetingSettingsPayload, error) {
	var err error
	var body UpdateMeetingSettingsRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateMeetingSettingsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"organizers\": [\n         \"Ipsam voluptatem nulla molestiae in.\",\n         \"Qui mollitia nostrum eos magnam.\"\n      ]\n   }'")
		}
	}
	var uid string
	{
		uid = meetingServiceUpdateMeetingSettingsUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceUpdateMeetingSettingsVersion != "" {
			version = &meetingServiceUpdateMeetingSettingsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateMeetingSettingsBearerToken != "" {
			bearerToken = &meetingServiceUpdateMeetingSettingsBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceUpdateMeetingSettingsXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceUpdateMeetingSettingsXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceUpdateMeetingSettingsIfMatch != "" {
			ifMatch = &meetingServiceUpdateMeetingSettingsIfMatch
		}
	}
	v := &meetingservice.UpdateMeetingSettingsPayload{}
	if body.Organizers != nil {
		v.Organizers = make([]string, len(body.Organizers))
		for i, val := range body.Organizers {
			v.Organizers[i] = val
		}
	}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildDeleteMeetingPayload builds the payload for the Meeting Service
// delete-meeting endpoint from CLI flags.
func BuildDeleteMeetingPayload(meetingServiceDeleteMeetingUID string, meetingServiceDeleteMeetingVersion string, meetingServiceDeleteMeetingBearerToken string, meetingServiceDeleteMeetingXSync string, meetingServiceDeleteMeetingIfMatch string) (*meetingservice.DeleteMeetingPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceDeleteMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceDeleteMeetingVersion != "" {
			version = &meetingServiceDeleteMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteMeetingBearerToken != "" {
			bearerToken = &meetingServiceDeleteMeetingBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceDeleteMeetingXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceDeleteMeetingXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceDeleteMeetingIfMatch != "" {
			ifMatch = &meetingServiceDeleteMeetingIfMatch
		}
	}
	v := &meetingservice.DeleteMeetingPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildDeleteMeetingOccurrencePayload builds the payload for the Meeting
// Service delete-meeting-occurrence endpoint from CLI flags.
func BuildDeleteMeetingOccurrencePayload(meetingServiceDeleteMeetingOccurrenceUID string, meetingServiceDeleteMeetingOccurrenceOccurrenceID string, meetingServiceDeleteMeetingOccurrenceVersion string, meetingServiceDeleteMeetingOccurrenceBearerToken string, meetingServiceDeleteMeetingOccurrenceXSync string, meetingServiceDeleteMeetingOccurrenceIfMatch string) (*meetingservice.DeleteMeetingOccurrencePayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceDeleteMeetingOccurrenceUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var occurrenceID string
	{
		occurrenceID = meetingServiceDeleteMeetingOccurrenceOccurrenceID
	}
	var version *string
	{
		if meetingServiceDeleteMeetingOccurrenceVersion != "" {
			version = &meetingServiceDeleteMeetingOccurrenceVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteMeetingOccurrenceBearerToken != "" {
			bearerToken = &meetingServiceDeleteMeetingOccurrenceBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceDeleteMeetingOccurrenceXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceDeleteMeetingOccurrenceXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceDeleteMeetingOccurrenceIfMatch != "" {
			ifMatch = &meetingServiceDeleteMeetingOccurrenceIfMatch
		}
	}
	v := &meetingservice.DeleteMeetingOccurrencePayload{}
	v.UID = uid
	v.OccurrenceID = occurrenceID
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildGetMeetingRegistrantsPayload builds the payload for the Meeting Service
// get-meeting-registrants endpoint from CLI flags.
func BuildGetMeetingRegistrantsPayload(meetingServiceGetMeetingRegistrantsUID string, meetingServiceGetMeetingRegistrantsVersion string, meetingServiceGetMeetingRegistrantsBearerToken string) (*meetingservice.GetMeetingRegistrantsPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceGetMeetingRegistrantsUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetMeetingRegistrantsVersion != "" {
			version = &meetingServiceGetMeetingRegistrantsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingRegistrantsBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingRegistrantsBearerToken
		}
	}
	v := &meetingservice.GetMeetingRegistrantsPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildCreateMeetingRegistrantPayload builds the payload for the Meeting
// Service create-meeting-registrant endpoint from CLI flags.
func BuildCreateMeetingRegistrantPayload(meetingServiceCreateMeetingRegistrantBody string, meetingServiceCreateMeetingRegistrantMeetingUID string, meetingServiceCreateMeetingRegistrantVersion string, meetingServiceCreateMeetingRegistrantBearerToken string, meetingServiceCreateMeetingRegistrantXSync string) (*meetingservice.CreateMeetingRegistrantPayload, error) {
	var err error
	var body CreateMeetingRegistrantRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateMeetingRegistrantBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"avatar_url\": \"https://example.com/avatar.jpg\",\n      \"email\": \"user@example.com\",\n      \"first_name\": \"John\",\n      \"host\": true,\n      \"job_title\": \"Software Engineer\",\n      \"last_name\": \"Doe\",\n      \"linkedin_profile\": \"https://www.linkedin.com/in/username\",\n      \"occurrence_id\": \"1640995200\",\n      \"org_name\": \"Dolorem velit quia sed et consequatur enim.\",\n      \"username\": \"Soluta ab.\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if body.FirstName != nil {
			if utf8.RuneCountInString(*body.FirstName) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
			}
		}
		if body.FirstName != nil {
			if utf8.RuneCountInString(*body.FirstName) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
			}
		}
		if body.LastName != nil {
			if utf8.RuneCountInString(*body.LastName) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
			}
		}
		if body.LastName != nil {
			if utf8.RuneCountInString(*body.LastName) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
			}
		}
		if body.OccurrenceID != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.occurrence_id", *body.OccurrenceID, "^[0-9]*$"))
		}
		if body.AvatarURL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
		}
		if body.LinkedinProfile != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.linkedin_profile", *body.LinkedinProfile, goa.FormatURI))
		}
		if body.LinkedinProfile != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.linkedin_profile", *body.LinkedinProfile, "^(https?://)?([a-z]{2,3}\\.)?linkedin\\.com/.*$"))
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingUID string
	{
		meetingUID = meetingServiceCreateMeetingRegistrantMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreateMeetingRegistrantVersion != "" {
			version = &meetingServiceCreateMeetingRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateMeetingRegistrantBearerToken != "" {
			bearerToken = &meetingServiceCreateMeetingRegistrantBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreateMeetingRegistrantXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreateMeetingRegistrantXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreateMeetingRegistrantPayload{
		Email:           body.Email,
		FirstName:       body.FirstName,
		LastName:        body.LastName,
		Host:            body.Host,
		JobTitle:        body.JobTitle,
		OrgName:         body.OrgName,
		OccurrenceID:    body.OccurrenceID,
		AvatarURL:       body.AvatarURL,
		LinkedinProfile: body.LinkedinProfile,
		Username:        body.Username,
	}
	v.MeetingUID = meetingUID
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetMeetingRegistrantPayload builds the payload for the Meeting Service
// get-meeting-registrant endpoint from CLI flags.
func BuildGetMeetingRegistrantPayload(meetingServiceGetMeetingRegistrantMeetingUID string, meetingServiceGetMeetingRegistrantUID string, meetingServiceGetMeetingRegistrantVersion string, meetingServiceGetMeetingRegistrantBearerToken string) (*meetingservice.GetMeetingRegistrantPayload, error) {
	var err error
	var meetingUID string
	{
		meetingUID = meetingServiceGetMeetingRegistrantMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceGetMeetingRegistrantUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetMeetingRegistrantVersion != "" {
			version = &meetingServiceGetMeetingRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingRegistrantBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingRegistrantBearerToken
		}
	}
	v := &meetingservice.GetMeetingRegistrantPayload{}
	v.MeetingUID = &meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateMeetingRegistrantPayload builds the payload for the Meeting
// Service update-meeting-registrant endpoint from CLI flags.
func BuildUpdateMeetingRegistrantPayload(meetingServiceUpdateMeetingRegistrantBody string, meetingServiceUpdateMeetingRegistrantMeetingUID string, meetingServiceUpdateMeetingRegistrantUID string, meetingServiceUpdateMeetingRegistrantVersion string, meetingServiceUpdateMeetingRegistrantBearerToken string, meetingServiceUpdateMeetingRegistrantXSync string, meetingServiceUpdateMeetingRegistrantIfMatch string) (*meetingservice.UpdateMeetingRegistrantPayload, error) {
	var err error
	var body UpdateMeetingRegistrantRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateMeetingRegistrantBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"avatar_url\": \"https://example.com/avatar.jpg\",\n      \"email\": \"user@example.com\",\n      \"first_name\": \"John\",\n      \"host\": true,\n      \"job_title\": \"Software Engineer\",\n      \"last_name\": \"Doe\",\n      \"linkedin_profile\": \"https://www.linkedin.com/in/username\",\n      \"occurrence_id\": \"1640995200\",\n      \"org_name\": \"Sit doloribus unde.\",\n      \"username\": \"Nemo vero est.\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if body.FirstName != nil {
			if utf8.RuneCountInString(*body.FirstName) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
			}
		}
		if body.FirstName != nil {
			if utf8.RuneCountInString(*body.FirstName) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
			}
		}
		if body.LastName != nil {
			if utf8.RuneCountInString(*body.LastName) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
			}
		}
		if body.LastName != nil {
			if utf8.RuneCountInString(*body.LastName) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
			}
		}
		if body.OccurrenceID != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.occurrence_id", *body.OccurrenceID, "^[0-9]*$"))
		}
		if body.AvatarURL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
		}
		if body.LinkedinProfile != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.linkedin_profile", *body.LinkedinProfile, goa.FormatURI))
		}
		if body.LinkedinProfile != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.linkedin_profile", *body.LinkedinProfile, "^(https?://)?([a-z]{2,3}\\.)?linkedin\\.com/.*$"))
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingUID string
	{
		meetingUID = meetingServiceUpdateMeetingRegistrantMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceUpdateMeetingRegistrantUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceUpdateMeetingRegistrantVersion != "" {
			version = &meetingServiceUpdateMeetingRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateMeetingRegistrantBearerToken != "" {
			bearerToken = &meetingServiceUpdateMeetingRegistrantBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceUpdateMeetingRegistrantXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceUpdateMeetingRegistrantXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceUpdateMeetingRegistrantIfMatch != "" {
			ifMatch = &meetingServiceUpdateMeetingRegistrantIfMatch
		}
	}
	v := &meetingservice.UpdateMeetingRegistrantPayload{
		Email:           body.Email,
		FirstName:       body.FirstName,
		LastName:        body.LastName,
		Host:            body.Host,
		JobTitle:        body.JobTitle,
		OrgName:         body.OrgName,
		OccurrenceID:    body.OccurrenceID,
		AvatarURL:       body.AvatarURL,
		LinkedinProfile: body.LinkedinProfile,
		Username:        body.Username,
	}
	v.MeetingUID = meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildDeleteMeetingRegistrantPayload builds the payload for the Meeting
// Service delete-meeting-registrant endpoint from CLI flags.
func BuildDeleteMeetingRegistrantPayload(meetingServiceDeleteMeetingRegistrantMeetingUID string, meetingServiceDeleteMeetingRegistrantUID string, meetingServiceDeleteMeetingRegistrantVersion string, meetingServiceDeleteMeetingRegistrantBearerToken string, meetingServiceDeleteMeetingRegistrantXSync string, meetingServiceDeleteMeetingRegistrantIfMatch string) (*meetingservice.DeleteMeetingRegistrantPayload, error) {
	var err error
	var meetingUID string
	{
		meetingUID = meetingServiceDeleteMeetingRegistrantMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceDeleteMeetingRegistrantUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceDeleteMeetingRegistrantVersion != "" {
			version = &meetingServiceDeleteMeetingRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteMeetingRegistrantBearerToken != "" {
			bearerToken = &meetingServiceDeleteMeetingRegistrantBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceDeleteMeetingRegistrantXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceDeleteMeetingRegistrantXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceDeleteMeetingRegistrantIfMatch != "" {
			ifMatch = &meetingServiceDeleteMeetingRegistrantIfMatch
		}
	}
	v := &meetingservice.DeleteMeetingRegistrantPayload{}
	v.MeetingUID = &meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildResendMeetingRegistrantInvitationPayload builds the payload for the
// Meeting Service resend-meeting-registrant-invitation endpoint from CLI flags.
func BuildResendMeetingRegistrantInvitationPayload(meetingServiceResendMeetingRegistrantInvitationMeetingUID string, meetingServiceResendMeetingRegistrantInvitationUID string, meetingServiceResendMeetingRegistrantInvitationVersion string, meetingServiceResendMeetingRegistrantInvitationBearerToken string) (*meetingservice.ResendMeetingRegistrantInvitationPayload, error) {
	var err error
	var meetingUID string
	{
		meetingUID = meetingServiceResendMeetingRegistrantInvitationMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceResendMeetingRegistrantInvitationUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceResendMeetingRegistrantInvitationVersion != "" {
			version = &meetingServiceResendMeetingRegistrantInvitationVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceResendMeetingRegistrantInvitationBearerToken != "" {
			bearerToken = &meetingServiceResendMeetingRegistrantInvitationBearerToken
		}
	}
	v := &meetingservice.ResendMeetingRegistrantInvitationPayload{}
	v.MeetingUID = &meetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildCreateMeetingRsvpPayload builds the payload for the Meeting Service
// create-meeting-rsvp endpoint from CLI flags.
func BuildCreateMeetingRsvpPayload(meetingServiceCreateMeetingRsvpBody string, meetingServiceCreateMeetingRsvpMeetingUID string, meetingServiceCreateMeetingRsvpVersion string, meetingServiceCreateMeetingRsvpBearerToken string, meetingServiceCreateMeetingRsvpXSync string) (*meetingservice.CreateMeetingRsvpPayload, error) {
	var err error
	var body CreateMeetingRsvpRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateMeetingRsvpBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"occurrence_id\": \"1640995200\",\n      \"registrant_id\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"response\": \"accepted\",\n      \"scope\": \"all\",\n      \"username\": \"jdoe\"\n   }'")
		}
		if body.RegistrantID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.registrant_id", *body.RegistrantID, goa.FormatUUID))
		}
		if !(body.Response == "accepted" || body.Response == "maybe" || body.Response == "declined") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.response", body.Response, []any{"accepted", "maybe", "declined"}))
		}
		if !(body.Scope == "single" || body.Scope == "all" || body.Scope == "this_and_following") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.scope", body.Scope, []any{"single", "all", "this_and_following"}))
		}
		if body.OccurrenceID != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.occurrence_id", *body.OccurrenceID, "^[0-9]*$"))
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingUID string
	{
		meetingUID = meetingServiceCreateMeetingRsvpMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreateMeetingRsvpVersion != "" {
			version = &meetingServiceCreateMeetingRsvpVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateMeetingRsvpBearerToken != "" {
			bearerToken = &meetingServiceCreateMeetingRsvpBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreateMeetingRsvpXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreateMeetingRsvpXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreateMeetingRsvpPayload{
		RegistrantID: body.RegistrantID,
		Username:     body.Username,
		Response:     body.Response,
		Scope:        body.Scope,
		OccurrenceID: body.OccurrenceID,
	}
	v.MeetingUID = meetingUID
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetMeetingRsvpsPayload builds the payload for the Meeting Service
// get-meeting-rsvps endpoint from CLI flags.
func BuildGetMeetingRsvpsPayload(meetingServiceGetMeetingRsvpsMeetingUID string, meetingServiceGetMeetingRsvpsVersion string, meetingServiceGetMeetingRsvpsBearerToken string) (*meetingservice.GetMeetingRsvpsPayload, error) {
	var err error
	var meetingUID string
	{
		meetingUID = meetingServiceGetMeetingRsvpsMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetMeetingRsvpsVersion != "" {
			version = &meetingServiceGetMeetingRsvpsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingRsvpsBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingRsvpsBearerToken
		}
	}
	v := &meetingservice.GetMeetingRsvpsPayload{}
	v.MeetingUID = meetingUID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildZoomWebhookPayload builds the payload for the Meeting Service
// zoom-webhook endpoint from CLI flags.
func BuildZoomWebhookPayload(meetingServiceZoomWebhookBody string, meetingServiceZoomWebhookZoomSignature string, meetingServiceZoomWebhookZoomTimestamp string) (*meetingservice.ZoomWebhookPayload, error) {
	var err error
	var body ZoomWebhookRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceZoomWebhookBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"event\": \"meeting.started\",\n      \"event_ts\": 1609459200000,\n      \"payload\": \"Sed consequatur vitae in voluptatem repellendus.\"\n   }'")
		}
		if body.Payload == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("payload", "body"))
		}
		if !(body.Event == "meeting.started" || body.Event == "meeting.ended" || body.Event == "meeting.deleted" || body.Event == "meeting.participant_joined" || body.Event == "meeting.participant_left" || body.Event == "recording.completed" || body.Event == "recording.transcript_completed" || body.Event == "meeting.summary_completed" || body.Event == "endpoint.url_validation") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.event", body.Event, []any{"meeting.started", "meeting.ended", "meeting.deleted", "meeting.participant_joined", "meeting.participant_left", "recording.completed", "recording.transcript_completed", "meeting.summary_completed", "endpoint.url_validation"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var zoomSignature string
	{
		zoomSignature = meetingServiceZoomWebhookZoomSignature
	}
	var zoomTimestamp string
	{
		zoomTimestamp = meetingServiceZoomWebhookZoomTimestamp
	}
	v := &meetingservice.ZoomWebhookPayload{
		Event:   body.Event,
		EventTs: body.EventTs,
		Payload: body.Payload,
	}
	v.ZoomSignature = zoomSignature
	v.ZoomTimestamp = zoomTimestamp

	return v, nil
}

// BuildGetPastMeetingsPayload builds the payload for the Meeting Service
// get-past-meetings endpoint from CLI flags.
func BuildGetPastMeetingsPayload(meetingServiceGetPastMeetingsVersion string, meetingServiceGetPastMeetingsBearerToken string) (*meetingservice.GetPastMeetingsPayload, error) {
	var err error
	var version *string
	{
		if meetingServiceGetPastMeetingsVersion != "" {
			version = &meetingServiceGetPastMeetingsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingsBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingsBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingsPayload{}
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildCreatePastMeetingPayload builds the payload for the Meeting Service
// create-past-meeting endpoint from CLI flags.
func BuildCreatePastMeetingPayload(meetingServiceCreatePastMeetingBody string, meetingServiceCreatePastMeetingVersion string, meetingServiceCreatePastMeetingBearerToken string, meetingServiceCreatePastMeetingXSync string) (*meetingservice.CreatePastMeetingPayload, error) {
	var err error
	var body CreatePastMeetingRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreatePastMeetingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"meeting_participants\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         }\n      ],\n      \"description\": \"ced\",\n      \"duration\": 198,\n      \"early_join_time_minutes\": 31,\n      \"meeting_type\": \"Marketing\",\n      \"meeting_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"occurrence_id\": \"1640995200\",\n      \"platform\": \"Zoom\",\n      \"platform_meeting_id\": \"1234567890\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"public_link\": \"http://hoegertoy.biz/laury_carroll\",\n      \"recording_enabled\": false,\n      \"recurrence\": {\n         \"end_date_time\": \"1977-02-15T17:20:58Z\",\n         \"end_times\": 1614259243833301344,\n         \"monthly_day\": 15,\n         \"monthly_week\": 3,\n         \"monthly_week_day\": 2,\n         \"repeat_interval\": 7893986229654679884,\n         \"type\": 3,\n         \"weekly_days\": \"1,3,5\"\n      },\n      \"restricted\": true,\n      \"scheduled_end_time\": \"2021-01-01T11:00:00Z\",\n      \"scheduled_start_time\": \"2021-01-01T10:00:00Z\",\n      \"sessions\": [\n         {\n            \"end_time\": \"2021-01-01T11:00:00Z\",\n            \"start_time\": \"2021-01-01T10:00:00Z\",\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"end_time\": \"2021-01-01T11:00:00Z\",\n            \"start_time\": \"2021-01-01T10:00:00Z\",\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         }\n      ],\n      \"show_meeting_attendees\": true,\n      \"timezone\": \"Facilis laboriosam veritatis in nulla suscipit.\",\n      \"title\": \"Rerum nam in explicabo reprehenderit.\",\n      \"transcript_enabled\": false,\n      \"visibility\": \"public\",\n      \"youtube_upload_enabled\": false,\n      \"zoom_config\": {\n         \"ai_companion_enabled\": false,\n         \"ai_summary_require_approval\": true,\n         \"meeting_id\": \"1234567890\",\n         \"passcode\": \"147258\"\n      }\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.meeting_uid", body.MeetingUID, goa.FormatUUID))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.project_uid", body.ProjectUID, goa.FormatUUID))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.scheduled_start_time", body.ScheduledStartTime, goa.FormatDateTime))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.scheduled_end_time", body.ScheduledEndTime, goa.FormatDateTime))
		if body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 0, true))
		}
		if body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 600, false))
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if utf8.RuneCountInString(body.Description) > 2000 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", body.Description, utf8.RuneCountInString(body.Description), 2000, false))
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if !(body.Platform == "Zoom") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.platform", body.Platform, []any{"Zoom"}))
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.Visibility != nil {
			if !(*body.Visibility == "public" || *body.Visibility == "private") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if body.PublicLink != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.public_link", *body.PublicLink, goa.FormatURI))
		}
		if body.ZoomConfig != nil {
			if err2 := ValidateZoomConfigFullRequestBody(body.ZoomConfig); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		for _, e := range body.Sessions {
			if e != nil {
				if err2 := ValidateSessionRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreatePastMeetingVersion != "" {
			version = &meetingServiceCreatePastMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreatePastMeetingBearerToken != "" {
			bearerToken = &meetingServiceCreatePastMeetingBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreatePastMeetingXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreatePastMeetingXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreatePastMeetingPayload{
		MeetingUID:           body.MeetingUID,
		OccurrenceID:         body.OccurrenceID,
		ProjectUID:           body.ProjectUID,
		ScheduledStartTime:   body.ScheduledStartTime,
		ScheduledEndTime:     body.ScheduledEndTime,
		Duration:             body.Duration,
		Timezone:             body.Timezone,
		Title:                body.Title,
		Description:          body.Description,
		Platform:             body.Platform,
		PlatformMeetingID:    body.PlatformMeetingID,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		MeetingType:          body.MeetingType,
		Visibility:           body.Visibility,
		Restricted:           body.Restricted,
		ArtifactVisibility:   body.ArtifactVisibility,
		PublicLink:           body.PublicLink,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
		ShowMeetingAttendees: body.ShowMeetingAttendees,
	}
	if body.Recurrence != nil {
		v.Recurrence = marshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.ZoomConfig != nil {
		v.ZoomConfig = marshalZoomConfigFullRequestBodyToMeetingserviceZoomConfigFull(body.ZoomConfig)
	}
	if body.Sessions != nil {
		v.Sessions = make([]*meetingservice.Session, len(body.Sessions))
		for i, val := range body.Sessions {
			if val == nil {
				v.Sessions[i] = nil
				continue
			}
			v.Sessions[i] = marshalSessionRequestBodyToMeetingserviceSession(val)
		}
	}
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetPastMeetingPayload builds the payload for the Meeting Service
// get-past-meeting endpoint from CLI flags.
func BuildGetPastMeetingPayload(meetingServiceGetPastMeetingUID string, meetingServiceGetPastMeetingVersion string, meetingServiceGetPastMeetingBearerToken string) (*meetingservice.GetPastMeetingPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceGetPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetPastMeetingVersion != "" {
			version = &meetingServiceGetPastMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeletePastMeetingPayload builds the payload for the Meeting Service
// delete-past-meeting endpoint from CLI flags.
func BuildDeletePastMeetingPayload(meetingServiceDeletePastMeetingUID string, meetingServiceDeletePastMeetingVersion string, meetingServiceDeletePastMeetingBearerToken string, meetingServiceDeletePastMeetingXSync string, meetingServiceDeletePastMeetingIfMatch string) (*meetingservice.DeletePastMeetingPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceDeletePastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceDeletePastMeetingVersion != "" {
			version = &meetingServiceDeletePastMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeletePastMeetingBearerToken != "" {
			bearerToken = &meetingServiceDeletePastMeetingBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceDeletePastMeetingXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceDeletePastMeetingXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceDeletePastMeetingIfMatch != "" {
			ifMatch = &meetingServiceDeletePastMeetingIfMatch
		}
	}
	v := &meetingservice.DeletePastMeetingPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildGetPastMeetingParticipantsPayload builds the payload for the Meeting
// Service get-past-meeting-participants endpoint from CLI flags.
func BuildGetPastMeetingParticipantsPayload(meetingServiceGetPastMeetingParticipantsUID string, meetingServiceGetPastMeetingParticipantsVersion string, meetingServiceGetPastMeetingParticipantsBearerToken string) (*meetingservice.GetPastMeetingParticipantsPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceGetPastMeetingParticipantsUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetPastMeetingParticipantsVersion != "" {
			version = &meetingServiceGetPastMeetingParticipantsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingParticipantsBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingParticipantsBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingParticipantsPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildCreatePastMeetingParticipantPayload builds the payload for the Meeting
// Service create-past-meeting-participant endpoint from CLI flags.
func BuildCreatePastMeetingParticipantPayload(meetingServiceCreatePastMeetingParticipantBody string, meetingServiceCreatePastMeetingParticipantUID string, meetingServiceCreatePastMeetingParticipantVersion string, meetingServiceCreatePastMeetingParticipantBearerToken string, meetingServiceCreatePastMeetingParticipantXSync string) (*meetingservice.CreatePastMeetingParticipantPayload, error) {
	var err error
	var body CreatePastMeetingParticipantRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreatePastMeetingParticipantBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"avatar_url\": \"https://example.com/avatar.jpg\",\n      \"email\": \"user@example.com\",\n      \"first_name\": \"John\",\n      \"host\": true,\n      \"is_attended\": true,\n      \"is_invited\": true,\n      \"job_title\": \"Software Engineer\",\n      \"last_name\": \"Doe\",\n      \"linkedin_profile\": \"https://www.linkedin.com/in/username\",\n      \"org_name\": \"Omnis quis laudantium cupiditate delectus atque.\",\n      \"past_meeting_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"username\": \"Fugiat hic dolores quasi.\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.past_meeting_uid", body.PastMeetingUID, goa.FormatUUID))
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if body.FirstName != nil {
			if utf8.RuneCountInString(*body.FirstName) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
			}
		}
		if body.FirstName != nil {
			if utf8.RuneCountInString(*body.FirstName) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
			}
		}
		if body.LastName != nil {
			if utf8.RuneCountInString(*body.LastName) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
			}
		}
		if body.LastName != nil {
			if utf8.RuneCountInString(*body.LastName) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
			}
		}
		if body.AvatarURL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
		}
		if body.LinkedinProfile != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.linkedin_profile", *body.LinkedinProfile, goa.FormatURI))
		}
		if body.LinkedinProfile != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.linkedin_profile", *body.LinkedinProfile, "^(https?://)?([a-z]{2,3}\\.)?linkedin\\.com/.*$"))
		}
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceCreatePastMeetingParticipantUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreatePastMeetingParticipantVersion != "" {
			version = &meetingServiceCreatePastMeetingParticipantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreatePastMeetingParticipantBearerToken != "" {
			bearerToken = &meetingServiceCreatePastMeetingParticipantBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreatePastMeetingParticipantXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreatePastMeetingParticipantXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreatePastMeetingParticipantPayload{
		PastMeetingUID:  body.PastMeetingUID,
		Email:           body.Email,
		FirstName:       body.FirstName,
		LastName:        body.LastName,
		Host:            body.Host,
		JobTitle:        body.JobTitle,
		OrgName:         body.OrgName,
		AvatarURL:       body.AvatarURL,
		LinkedinProfile: body.LinkedinProfile,
		Username:        body.Username,
		IsInvited:       body.IsInvited,
		IsAttended:      body.IsAttended,
	}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetPastMeetingParticipantPayload builds the payload for the Meeting
// Service get-past-meeting-participant endpoint from CLI flags.
func BuildGetPastMeetingParticipantPayload(meetingServiceGetPastMeetingParticipantPastMeetingUID string, meetingServiceGetPastMeetingParticipantUID string, meetingServiceGetPastMeetingParticipantVersion string, meetingServiceGetPastMeetingParticipantBearerToken string) (*meetingservice.GetPastMeetingParticipantPayload, error) {
	var err error
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceGetPastMeetingParticipantPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceGetPastMeetingParticipantUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetPastMeetingParticipantVersion != "" {
			version = &meetingServiceGetPastMeetingParticipantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingParticipantBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingParticipantBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingParticipantPayload{}
	v.PastMeetingUID = &pastMeetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdatePastMeetingParticipantPayload builds the payload for the Meeting
// Service update-past-meeting-participant endpoint from CLI flags.
func BuildUpdatePastMeetingParticipantPayload(meetingServiceUpdatePastMeetingParticipantBody string, meetingServiceUpdatePastMeetingParticipantPastMeetingUID string, meetingServiceUpdatePastMeetingParticipantUID string, meetingServiceUpdatePastMeetingParticipantVersion string, meetingServiceUpdatePastMeetingParticipantBearerToken string, meetingServiceUpdatePastMeetingParticipantXSync string, meetingServiceUpdatePastMeetingParticipantIfMatch string) (*meetingservice.UpdatePastMeetingParticipantPayload, error) {
	var err error
	var body UpdatePastMeetingParticipantRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdatePastMeetingParticipantBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"avatar_url\": \"https://example.com/avatar.jpg\",\n      \"email\": \"user@example.com\",\n      \"first_name\": \"John\",\n      \"host\": false,\n      \"is_attended\": true,\n      \"is_invited\": true,\n      \"job_title\": \"Software Engineer\",\n      \"last_name\": \"Doe\",\n      \"linkedin_profile\": \"https://www.linkedin.com/in/username\",\n      \"org_name\": \"Et officiis qui ut.\",\n      \"username\": \"Alias est.\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.email", body.Email, goa.FormatEmail))
		if body.FirstName != nil {
			if utf8.RuneCountInString(*body.FirstName) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 1, true))
			}
		}
		if body.FirstName != nil {
			if utf8.RuneCountInString(*body.FirstName) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.first_name", *body.FirstName, utf8.RuneCountInString(*body.FirstName), 100, false))
			}
		}
		if body.LastName != nil {
			if utf8.RuneCountInString(*body.LastName) < 1 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 1, true))
			}
		}
		if body.LastName != nil {
			if utf8.RuneCountInString(*body.LastName) > 100 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.last_name", *body.LastName, utf8.RuneCountInString(*body.LastName), 100, false))
			}
		}
		if body.AvatarURL != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.avatar_url", *body.AvatarURL, goa.FormatURI))
		}
		if body.LinkedinProfile != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.linkedin_profile", *body.LinkedinProfile, goa.FormatURI))
		}
		if body.LinkedinProfile != nil {
			err = goa.MergeErrors(err, goa.ValidatePattern("body.linkedin_profile", *body.LinkedinProfile, "^(https?://)?([a-z]{2,3}\\.)?linkedin\\.com/.*$"))
		}
		if err != nil {
			return nil, err
		}
	}
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceUpdatePastMeetingParticipantPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceUpdatePastMeetingParticipantUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceUpdatePastMeetingParticipantVersion != "" {
			version = &meetingServiceUpdatePastMeetingParticipantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdatePastMeetingParticipantBearerToken != "" {
			bearerToken = &meetingServiceUpdatePastMeetingParticipantBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceUpdatePastMeetingParticipantXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceUpdatePastMeetingParticipantXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceUpdatePastMeetingParticipantIfMatch != "" {
			ifMatch = &meetingServiceUpdatePastMeetingParticipantIfMatch
		}
	}
	v := &meetingservice.UpdatePastMeetingParticipantPayload{
		Email:           body.Email,
		FirstName:       body.FirstName,
		LastName:        body.LastName,
		Host:            body.Host,
		JobTitle:        body.JobTitle,
		OrgName:         body.OrgName,
		AvatarURL:       body.AvatarURL,
		LinkedinProfile: body.LinkedinProfile,
		Username:        body.Username,
		IsInvited:       body.IsInvited,
		IsAttended:      body.IsAttended,
	}
	v.PastMeetingUID = pastMeetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildDeletePastMeetingParticipantPayload builds the payload for the Meeting
// Service delete-past-meeting-participant endpoint from CLI flags.
func BuildDeletePastMeetingParticipantPayload(meetingServiceDeletePastMeetingParticipantPastMeetingUID string, meetingServiceDeletePastMeetingParticipantUID string, meetingServiceDeletePastMeetingParticipantVersion string, meetingServiceDeletePastMeetingParticipantBearerToken string, meetingServiceDeletePastMeetingParticipantXSync string, meetingServiceDeletePastMeetingParticipantIfMatch string) (*meetingservice.DeletePastMeetingParticipantPayload, error) {
	var err error
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceDeletePastMeetingParticipantPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceDeletePastMeetingParticipantUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceDeletePastMeetingParticipantVersion != "" {
			version = &meetingServiceDeletePastMeetingParticipantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeletePastMeetingParticipantBearerToken != "" {
			bearerToken = &meetingServiceDeletePastMeetingParticipantBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceDeletePastMeetingParticipantXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceDeletePastMeetingParticipantXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceDeletePastMeetingParticipantIfMatch != "" {
			ifMatch = &meetingServiceDeletePastMeetingParticipantIfMatch
		}
	}
	v := &meetingservice.DeletePastMeetingParticipantPayload{}
	v.PastMeetingUID = &pastMeetingUID
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildGetPastMeetingSummariesPayload builds the payload for the Meeting
// Service get-past-meeting-summaries endpoint from CLI flags.
func BuildGetPastMeetingSummariesPayload(meetingServiceGetPastMeetingSummariesUID string, meetingServiceGetPastMeetingSummariesVersion string, meetingServiceGetPastMeetingSummariesBearerToken string) (*meetingservice.GetPastMeetingSummariesPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceGetPastMeetingSummariesUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetPastMeetingSummariesVersion != "" {
			version = &meetingServiceGetPastMeetingSummariesVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingSummariesBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingSummariesBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingSummariesPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetPastMeetingSummaryPayload builds the payload for the Meeting Service
// get-past-meeting-summary endpoint from CLI flags.
func BuildGetPastMeetingSummaryPayload(meetingServiceGetPastMeetingSummaryPastMeetingUID string, meetingServiceGetPastMeetingSummarySummaryUID string, meetingServiceGetPastMeetingSummaryVersion string, meetingServiceGetPastMeetingSummaryBearerToken string) (*meetingservice.GetPastMeetingSummaryPayload, error) {
	var err error
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceGetPastMeetingSummaryPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var summaryUID string
	{
		summaryUID = meetingServiceGetPastMeetingSummarySummaryUID
		err = goa.MergeErrors(err, goa.ValidateFormat("summary_uid", summaryUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetPastMeetingSummaryVersion != "" {
			version = &meetingServiceGetPastMeetingSummaryVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingSummaryBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingSummaryBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingSummaryPayload{}
	v.PastMeetingUID = pastMeetingUID
	v.SummaryUID = summaryUID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdatePastMeetingSummaryPayload builds the payload for the Meeting
// Service update-past-meeting-summary endpoint from CLI flags.
func BuildUpdatePastMeetingSummaryPayload(meetingServiceUpdatePastMeetingSummaryBody string, meetingServiceUpdatePastMeetingSummaryPastMeetingUID string, meetingServiceUpdatePastMeetingSummarySummaryUID string, meetingServiceUpdatePastMeetingSummaryVersion string, meetingServiceUpdatePastMeetingSummaryBearerToken string, meetingServiceUpdatePastMeetingSummaryXSync string, meetingServiceUpdatePastMeetingSummaryIfMatch string) (*meetingservice.UpdatePastMeetingSummaryPayload, error) {
	var err error
	var body UpdatePastMeetingSummaryRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdatePastMeetingSummaryBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"approved\": true,\n      \"edited_content\": \"Updated meeting summary with additional details and action items.\"\n   }'")
		}
	}
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceUpdatePastMeetingSummaryPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var summaryUID string
	{
		summaryUID = meetingServiceUpdatePastMeetingSummarySummaryUID
		err = goa.MergeErrors(err, goa.ValidateFormat("summary_uid", summaryUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceUpdatePastMeetingSummaryVersion != "" {
			version = &meetingServiceUpdatePastMeetingSummaryVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdatePastMeetingSummaryBearerToken != "" {
			bearerToken = &meetingServiceUpdatePastMeetingSummaryBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceUpdatePastMeetingSummaryXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceUpdatePastMeetingSummaryXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	var ifMatch *string
	{
		if meetingServiceUpdatePastMeetingSummaryIfMatch != "" {
			ifMatch = &meetingServiceUpdatePastMeetingSummaryIfMatch
		}
	}
	v := &meetingservice.UpdatePastMeetingSummaryPayload{
		EditedContent: body.EditedContent,
		Approved:      body.Approved,
	}
	v.PastMeetingUID = pastMeetingUID
	v.SummaryUID = summaryUID
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync
	v.IfMatch = ifMatch

	return v, nil
}

// BuildCreateMeetingAttachmentPayload builds the payload for the Meeting
// Service create-meeting-attachment endpoint from CLI flags.
func BuildCreateMeetingAttachmentPayload(meetingServiceCreateMeetingAttachmentBody string, meetingServiceCreateMeetingAttachmentMeetingUID string, meetingServiceCreateMeetingAttachmentVersion string, meetingServiceCreateMeetingAttachmentBearerToken string, meetingServiceCreateMeetingAttachmentXSync string) (*meetingservice.CreateMeetingAttachmentPayload, error) {
	var err error
	var body CreateMeetingAttachmentRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateMeetingAttachmentBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Meeting agenda for Q1 2024\",\n      \"file\": \"RXNzZSByZXJ1bSBkZWxlbml0aSBlc3QgZXQgb2NjYWVjYXRpLg==\",\n      \"file_content_type\": \"Ut et cum itaque magni.\",\n      \"file_name\": \"Dolor dolorem exercitationem.\",\n      \"link\": \"https://example.com/meeting-notes\",\n      \"name\": \"Q1 Meeting Agenda\",\n      \"type\": \"file\"\n   }'")
		}
		if !(body.Type == "file" || body.Type == "link") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"file", "link"}))
		}
		if body.Link != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.link", *body.Link, goa.FormatURI))
		}
		if body.Link != nil {
			if utf8.RuneCountInString(*body.Link) > 2048 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.link", *body.Link, utf8.RuneCountInString(*body.Link), 2048, false))
			}
		}
		if utf8.RuneCountInString(body.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 1, true))
		}
		if utf8.RuneCountInString(body.Name) > 255 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 255, false))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 500 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 500, false))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingUID string
	{
		meetingUID = meetingServiceCreateMeetingAttachmentMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreateMeetingAttachmentVersion != "" {
			version = &meetingServiceCreateMeetingAttachmentVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateMeetingAttachmentBearerToken != "" {
			bearerToken = &meetingServiceCreateMeetingAttachmentBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreateMeetingAttachmentXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreateMeetingAttachmentXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreateMeetingAttachmentPayload{
		Type:            body.Type,
		Link:            body.Link,
		Name:            body.Name,
		Description:     body.Description,
		File:            body.File,
		FileName:        body.FileName,
		FileContentType: body.FileContentType,
	}
	v.MeetingUID = meetingUID
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetMeetingAttachmentPayload builds the payload for the Meeting Service
// get-meeting-attachment endpoint from CLI flags.
func BuildGetMeetingAttachmentPayload(meetingServiceGetMeetingAttachmentMeetingUID string, meetingServiceGetMeetingAttachmentUID string, meetingServiceGetMeetingAttachmentVersion string, meetingServiceGetMeetingAttachmentBearerToken string) (*meetingservice.GetMeetingAttachmentPayload, error) {
	var err error
	var meetingUID string
	{
		meetingUID = meetingServiceGetMeetingAttachmentMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceGetMeetingAttachmentUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetMeetingAttachmentVersion != "" {
			version = &meetingServiceGetMeetingAttachmentVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingAttachmentBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingAttachmentBearerToken
		}
	}
	v := &meetingservice.GetMeetingAttachmentPayload{}
	v.MeetingUID = meetingUID
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetMeetingAttachmentMetadataPayload builds the payload for the Meeting
// Service get-meeting-attachment-metadata endpoint from CLI flags.
func BuildGetMeetingAttachmentMetadataPayload(meetingServiceGetMeetingAttachmentMetadataMeetingUID string, meetingServiceGetMeetingAttachmentMetadataUID string, meetingServiceGetMeetingAttachmentMetadataVersion string, meetingServiceGetMeetingAttachmentMetadataBearerToken string) (*meetingservice.GetMeetingAttachmentMetadataPayload, error) {
	var err error
	var meetingUID string
	{
		meetingUID = meetingServiceGetMeetingAttachmentMetadataMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceGetMeetingAttachmentMetadataUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetMeetingAttachmentMetadataVersion != "" {
			version = &meetingServiceGetMeetingAttachmentMetadataVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetMeetingAttachmentMetadataBearerToken != "" {
			bearerToken = &meetingServiceGetMeetingAttachmentMetadataBearerToken
		}
	}
	v := &meetingservice.GetMeetingAttachmentMetadataPayload{}
	v.MeetingUID = meetingUID
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeleteMeetingAttachmentPayload builds the payload for the Meeting
// Service delete-meeting-attachment endpoint from CLI flags.
func BuildDeleteMeetingAttachmentPayload(meetingServiceDeleteMeetingAttachmentMeetingUID string, meetingServiceDeleteMeetingAttachmentUID string, meetingServiceDeleteMeetingAttachmentVersion string, meetingServiceDeleteMeetingAttachmentBearerToken string, meetingServiceDeleteMeetingAttachmentXSync string) (*meetingservice.DeleteMeetingAttachmentPayload, error) {
	var err error
	var meetingUID string
	{
		meetingUID = meetingServiceDeleteMeetingAttachmentMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("meeting_uid", meetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceDeleteMeetingAttachmentUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceDeleteMeetingAttachmentVersion != "" {
			version = &meetingServiceDeleteMeetingAttachmentVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteMeetingAttachmentBearerToken != "" {
			bearerToken = &meetingServiceDeleteMeetingAttachmentBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceDeleteMeetingAttachmentXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceDeleteMeetingAttachmentXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.DeleteMeetingAttachmentPayload{}
	v.MeetingUID = meetingUID
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildCreatePastMeetingAttachmentPayload builds the payload for the Meeting
// Service create-past-meeting-attachment endpoint from CLI flags.
func BuildCreatePastMeetingAttachmentPayload(meetingServiceCreatePastMeetingAttachmentBody string, meetingServiceCreatePastMeetingAttachmentPastMeetingUID string, meetingServiceCreatePastMeetingAttachmentVersion string, meetingServiceCreatePastMeetingAttachmentBearerToken string, meetingServiceCreatePastMeetingAttachmentXSync string) (*meetingservice.CreatePastMeetingAttachmentPayload, error) {
	var err error
	var body CreatePastMeetingAttachmentRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreatePastMeetingAttachmentBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"description\": \"Meeting recording for Q1 2024\",\n      \"file\": \"UGVyZmVyZW5kaXMgZWFydW0gbmFtIHRlbXBvcmUgdm9sdXB0YXRlbSBvZGl0Lg==\",\n      \"file_content_type\": \"Neque dignissimos inventore at velit.\",\n      \"file_name\": \"Accusamus ea non sequi.\",\n      \"link\": \"https://example.com/meeting-notes\",\n      \"name\": \"Q1 Meeting Recording\",\n      \"source_object_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"type\": \"file\"\n   }'")
		}
		if !(body.Type == "file" || body.Type == "link") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", body.Type, []any{"file", "link"}))
		}
		if body.Link != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.link", *body.Link, goa.FormatURI))
		}
		if body.Link != nil {
			if utf8.RuneCountInString(*body.Link) > 2048 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.link", *body.Link, utf8.RuneCountInString(*body.Link), 2048, false))
			}
		}
		if utf8.RuneCountInString(body.Name) < 1 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 1, true))
		}
		if utf8.RuneCountInString(body.Name) > 255 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.name", body.Name, utf8.RuneCountInString(body.Name), 255, false))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 500 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 500, false))
			}
		}
		if body.SourceObjectUID != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.source_object_uid", *body.SourceObjectUID, goa.FormatUUID))
		}
		if err != nil {
			return nil, err
		}
	}
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceCreatePastMeetingAttachmentPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreatePastMeetingAttachmentVersion != "" {
			version = &meetingServiceCreatePastMeetingAttachmentVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreatePastMeetingAttachmentBearerToken != "" {
			bearerToken = &meetingServiceCreatePastMeetingAttachmentBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreatePastMeetingAttachmentXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreatePastMeetingAttachmentXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreatePastMeetingAttachmentPayload{
		Type:            body.Type,
		Link:            body.Link,
		Name:            body.Name,
		Description:     body.Description,
		SourceObjectUID: body.SourceObjectUID,
		File:            body.File,
		FileName:        body.FileName,
		FileContentType: body.FileContentType,
	}
	v.PastMeetingUID = pastMeetingUID
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetPastMeetingAttachmentsPayload builds the payload for the Meeting
// Service get-past-meeting-attachments endpoint from CLI flags.
func BuildGetPastMeetingAttachmentsPayload(meetingServiceGetPastMeetingAttachmentsUID string, meetingServiceGetPastMeetingAttachmentsVersion string, meetingServiceGetPastMeetingAttachmentsBearerToken string) (*meetingservice.GetPastMeetingAttachmentsPayload, error) {
	var err error
	var uid string
	{
		uid = meetingServiceGetPastMeetingAttachmentsUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetPastMeetingAttachmentsVersion != "" {
			version = &meetingServiceGetPastMeetingAttachmentsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingAttachmentsBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingAttachmentsBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingAttachmentsPayload{}
	v.UID = &uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetPastMeetingAttachmentPayload builds the payload for the Meeting
// Service get-past-meeting-attachment endpoint from CLI flags.
func BuildGetPastMeetingAttachmentPayload(meetingServiceGetPastMeetingAttachmentPastMeetingUID string, meetingServiceGetPastMeetingAttachmentUID string, meetingServiceGetPastMeetingAttachmentVersion string, meetingServiceGetPastMeetingAttachmentBearerToken string) (*meetingservice.GetPastMeetingAttachmentPayload, error) {
	var err error
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceGetPastMeetingAttachmentPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceGetPastMeetingAttachmentUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetPastMeetingAttachmentVersion != "" {
			version = &meetingServiceGetPastMeetingAttachmentVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingAttachmentBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingAttachmentBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingAttachmentPayload{}
	v.PastMeetingUID = pastMeetingUID
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetPastMeetingAttachmentMetadataPayload builds the payload for the
// Meeting Service get-past-meeting-attachment-metadata endpoint from CLI flags.
func BuildGetPastMeetingAttachmentMetadataPayload(meetingServiceGetPastMeetingAttachmentMetadataPastMeetingUID string, meetingServiceGetPastMeetingAttachmentMetadataUID string, meetingServiceGetPastMeetingAttachmentMetadataVersion string, meetingServiceGetPastMeetingAttachmentMetadataBearerToken string) (*meetingservice.GetPastMeetingAttachmentMetadataPayload, error) {
	var err error
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceGetPastMeetingAttachmentMetadataPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceGetPastMeetingAttachmentMetadataUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceGetPastMeetingAttachmentMetadataVersion != "" {
			version = &meetingServiceGetPastMeetingAttachmentMetadataVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetPastMeetingAttachmentMetadataBearerToken != "" {
			bearerToken = &meetingServiceGetPastMeetingAttachmentMetadataBearerToken
		}
	}
	v := &meetingservice.GetPastMeetingAttachmentMetadataPayload{}
	v.PastMeetingUID = pastMeetingUID
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeletePastMeetingAttachmentPayload builds the payload for the Meeting
// Service delete-past-meeting-attachment endpoint from CLI flags.
func BuildDeletePastMeetingAttachmentPayload(meetingServiceDeletePastMeetingAttachmentPastMeetingUID string, meetingServiceDeletePastMeetingAttachmentUID string, meetingServiceDeletePastMeetingAttachmentVersion string, meetingServiceDeletePastMeetingAttachmentBearerToken string, meetingServiceDeletePastMeetingAttachmentXSync string) (*meetingservice.DeletePastMeetingAttachmentPayload, error) {
	var err error
	var pastMeetingUID string
	{
		pastMeetingUID = meetingServiceDeletePastMeetingAttachmentPastMeetingUID
		err = goa.MergeErrors(err, goa.ValidateFormat("past_meeting_uid", pastMeetingUID, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var uid string
	{
		uid = meetingServiceDeletePastMeetingAttachmentUID
		err = goa.MergeErrors(err, goa.ValidateFormat("uid", uid, goa.FormatUUID))
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceDeletePastMeetingAttachmentVersion != "" {
			version = &meetingServiceDeletePastMeetingAttachmentVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeletePastMeetingAttachmentBearerToken != "" {
			bearerToken = &meetingServiceDeletePastMeetingAttachmentBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceDeletePastMeetingAttachmentXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceDeletePastMeetingAttachmentXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.DeletePastMeetingAttachmentPayload{}
	v.PastMeetingUID = pastMeetingUID
	v.UID = uid
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildCreateItxMeetingPayload builds the payload for the Meeting Service
// create-itx-meeting endpoint from CLI flags.
func BuildCreateItxMeetingPayload(meetingServiceCreateItxMeetingBody string, meetingServiceCreateItxMeetingVersion string, meetingServiceCreateItxMeetingBearerToken string, meetingServiceCreateItxMeetingXSync string) (*meetingservice.CreateItxMeetingPayload, error) {
	var err error
	var body CreateItxMeetingRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateItxMeetingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"public\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         }\n      ],\n      \"description\": \"reo\",\n      \"duration\": 484,\n      \"early_join_time_minutes\": 28,\n      \"meeting_type\": \"Legal\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"recording_enabled\": false,\n      \"recurrence\": {\n         \"end_date_time\": \"1977-02-15T17:20:58Z\",\n         \"end_times\": 1614259243833301344,\n         \"monthly_day\": 15,\n         \"monthly_week\": 3,\n         \"monthly_week_day\": 2,\n         \"repeat_interval\": 7893986229654679884,\n         \"type\": 3,\n         \"weekly_days\": \"1,3,5\"\n      },\n      \"restricted\": true,\n      \"start_time\": \"2021-01-01T00:00:00Z\",\n      \"timezone\": \"Qui aut delectus.\",\n      \"title\": \"Adipisci est et ea consequatur a animi.\",\n      \"transcript_enabled\": false,\n      \"visibility\": \"private\",\n      \"youtube_upload_enabled\": true\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", body.StartTime, goa.FormatDateTime))
		if body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 0, true))
		}
		if body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 600, false))
		}
		if !(body.Visibility == "public" || body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", body.Visibility, []any{"public", "private"}))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 2000 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 2000, false))
			}
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreateItxMeetingVersion != "" {
			version = &meetingServiceCreateItxMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateItxMeetingBearerToken != "" {
			bearerToken = &meetingServiceCreateItxMeetingBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreateItxMeetingXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreateItxMeetingXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreateItxMeetingPayload{
		ProjectUID:           body.ProjectUID,
		Title:                body.Title,
		StartTime:            body.StartTime,
		Duration:             body.Duration,
		Timezone:             body.Timezone,
		Visibility:           body.Visibility,
		Description:          body.Description,
		Restricted:           body.Restricted,
		MeetingType:          body.MeetingType,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
		ArtifactVisibility:   body.ArtifactVisibility,
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.Recurrence != nil {
		v.Recurrence = marshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetItxMeetingPayload builds the payload for the Meeting Service
// get-itx-meeting endpoint from CLI flags.
func BuildGetItxMeetingPayload(meetingServiceGetItxMeetingMeetingID string, meetingServiceGetItxMeetingVersion string, meetingServiceGetItxMeetingBearerToken string) (*meetingservice.GetItxMeetingPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceGetItxMeetingMeetingID
	}
	var version *string
	{
		if meetingServiceGetItxMeetingVersion != "" {
			version = &meetingServiceGetItxMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxMeetingBearerToken != "" {
			bearerToken = &meetingServiceGetItxMeetingBearerToken
		}
	}
	v := &meetingservice.GetItxMeetingPayload{}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeleteItxMeetingPayload builds the payload for the Meeting Service
// delete-itx-meeting endpoint from CLI flags.
func BuildDeleteItxMeetingPayload(meetingServiceDeleteItxMeetingMeetingID string, meetingServiceDeleteItxMeetingVersion string, meetingServiceDeleteItxMeetingBearerToken string) (*meetingservice.DeleteItxMeetingPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceDeleteItxMeetingMeetingID
	}
	var version *string
	{
		if meetingServiceDeleteItxMeetingVersion != "" {
			version = &meetingServiceDeleteItxMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteItxMeetingBearerToken != "" {
			bearerToken = &meetingServiceDeleteItxMeetingBearerToken
		}
	}
	v := &meetingservice.DeleteItxMeetingPayload{}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateItxMeetingPayload builds the payload for the Meeting Service
// update-itx-meeting endpoint from CLI flags.
func BuildUpdateItxMeetingPayload(meetingServiceUpdateItxMeetingBody string, meetingServiceUpdateItxMeetingMeetingID string, meetingServiceUpdateItxMeetingVersion string, meetingServiceUpdateItxMeetingBearerToken string, meetingServiceUpdateItxMeetingXSync string) (*meetingservice.UpdateItxMeetingPayload, error) {
	var err error
	var body UpdateItxMeetingRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateItxMeetingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"public\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Quasi non ut repudiandae quia et eligendi.\",\n               \"Occaecati ut delectus.\",\n               \"Dolores explicabo minima est non tenetur aliquid.\"\n            ],\n            \"uid\": \"Reprehenderit possimus unde aut dicta.\"\n         }\n      ],\n      \"description\": \"mxt\",\n      \"duration\": 1,\n      \"early_join_time_minutes\": 36,\n      \"meeting_type\": \"Marketing\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"recording_enabled\": false,\n      \"recurrence\": {\n         \"end_date_time\": \"1977-02-15T17:20:58Z\",\n         \"end_times\": 1614259243833301344,\n         \"monthly_day\": 15,\n         \"monthly_week\": 3,\n         \"monthly_week_day\": 2,\n         \"repeat_interval\": 7893986229654679884,\n         \"type\": 3,\n         \"weekly_days\": \"1,3,5\"\n      },\n      \"restricted\": false,\n      \"start_time\": \"2021-01-01T00:00:00Z\",\n      \"timezone\": \"Quia voluptas maxime et.\",\n      \"title\": \"Ipsam omnis.\",\n      \"transcript_enabled\": true,\n      \"visibility\": \"public\",\n      \"youtube_upload_enabled\": false\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", body.StartTime, goa.FormatDateTime))
		if body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 0, true))
		}
		if body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 600, false))
		}
		if !(body.Visibility == "public" || body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", body.Visibility, []any{"public", "private"}))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 2000 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 2000, false))
			}
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceUpdateItxMeetingMeetingID
	}
	var version *string
	{
		if meetingServiceUpdateItxMeetingVersion != "" {
			version = &meetingServiceUpdateItxMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateItxMeetingBearerToken != "" {
			bearerToken = &meetingServiceUpdateItxMeetingBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceUpdateItxMeetingXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceUpdateItxMeetingXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.UpdateItxMeetingPayload{
		ProjectUID:           body.ProjectUID,
		Title:                body.Title,
		StartTime:            body.StartTime,
		Duration:             body.Duration,
		Timezone:             body.Timezone,
		Visibility:           body.Visibility,
		Description:          body.Description,
		Restricted:           body.Restricted,
		MeetingType:          body.MeetingType,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
		ArtifactVisibility:   body.ArtifactVisibility,
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.Recurrence != nil {
		v.Recurrence = marshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetItxMeetingCountPayload builds the payload for the Meeting Service
// get-itx-meeting-count endpoint from CLI flags.
func BuildGetItxMeetingCountPayload(meetingServiceGetItxMeetingCountVersion string, meetingServiceGetItxMeetingCountProjectUID string, meetingServiceGetItxMeetingCountBearerToken string) (*meetingservice.GetItxMeetingCountPayload, error) {
	var err error
	var version *string
	{
		if meetingServiceGetItxMeetingCountVersion != "" {
			version = &meetingServiceGetItxMeetingCountVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var projectUID string
	{
		projectUID = meetingServiceGetItxMeetingCountProjectUID
	}
	var bearerToken *string
	{
		if meetingServiceGetItxMeetingCountBearerToken != "" {
			bearerToken = &meetingServiceGetItxMeetingCountBearerToken
		}
	}
	v := &meetingservice.GetItxMeetingCountPayload{}
	v.Version = version
	v.ProjectUID = projectUID
	v.BearerToken = bearerToken

	return v, nil
}

// BuildCreateItxRegistrantPayload builds the payload for the Meeting Service
// create-itx-registrant endpoint from CLI flags.
func BuildCreateItxRegistrantPayload(meetingServiceCreateItxRegistrantBody string, meetingServiceCreateItxRegistrantMeetingID string, meetingServiceCreateItxRegistrantVersion string, meetingServiceCreateItxRegistrantBearerToken string) (*meetingservice.CreateItxRegistrantPayload, error) {
	var err error
	var body CreateItxRegistrantRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateItxRegistrantBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"attended_occurrence_count\": 6197729625601561100,\n      \"committee_id\": \"Ut tempora quo doloribus distinctio tenetur unde.\",\n      \"created_at\": \"Optio occaecati veritatis iure quidem.\",\n      \"created_by\": {\n         \"email\": \"john.doe@example.com\",\n         \"id\": \"user123\",\n         \"name\": \"John Doe\",\n         \"profile_picture\": \"https://example.com/avatar.jpg\",\n         \"username\": \"jdoe\"\n      },\n      \"email\": \"bobsmith@gmail.com\",\n      \"first_name\": \"Bob\",\n      \"host\": true,\n      \"id\": \"Illum dolorum deleniti voluptatem non.\",\n      \"job_title\": \"developer\",\n      \"last_invite_delivery_description\": \"Neque aperiam voluptatem omnis enim qui voluptas.\",\n      \"last_invite_delivery_status\": \"Quia non et tempora est reiciendis tempore.\",\n      \"last_invite_received_message_id\": \"Illo qui incidunt porro earum quis.\",\n      \"last_invite_received_time\": \"Quibusdam fugit expedita.\",\n      \"last_name\": \"Smith\",\n      \"modified_at\": \"Fuga illum aut sit quaerat iusto vel.\",\n      \"occurrence\": \"1666848600\",\n      \"org\": \"google\",\n      \"profile_picture\": \"Quam aperiam magnam placeat est recusandae.\",\n      \"total_occurrence_count\": 8556415290593003667,\n      \"type\": \"committee\",\n      \"updated_by\": {\n         \"email\": \"john.doe@example.com\",\n         \"id\": \"user123\",\n         \"name\": \"John Doe\",\n         \"profile_picture\": \"https://example.com/avatar.jpg\",\n         \"username\": \"jdoe\"\n      },\n      \"user_id\": \"Quasi consequatur facere veniam voluptas.\",\n      \"username\": \"testuser\"\n   }'")
		}
		if body.Type != nil {
			if !(*body.Type == "direct" || *body.Type == "committee") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"direct", "committee"}))
			}
		}
		if body.Email != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
		}
		if body.CreatedBy != nil {
			if err2 := ValidateITXUserRequestBody(body.CreatedBy); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if body.UpdatedBy != nil {
			if err2 := ValidateITXUserRequestBody(body.UpdatedBy); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceCreateItxRegistrantMeetingID
	}
	var version *string
	{
		if meetingServiceCreateItxRegistrantVersion != "" {
			version = &meetingServiceCreateItxRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateItxRegistrantBearerToken != "" {
			bearerToken = &meetingServiceCreateItxRegistrantBearerToken
		}
	}
	v := &meetingservice.CreateItxRegistrantPayload{
		ID:                            body.ID,
		Type:                          body.Type,
		CommitteeID:                   body.CommitteeID,
		UserID:                        body.UserID,
		Email:                         body.Email,
		Username:                      body.Username,
		FirstName:                     body.FirstName,
		LastName:                      body.LastName,
		Org:                           body.Org,
		JobTitle:                      body.JobTitle,
		ProfilePicture:                body.ProfilePicture,
		Host:                          body.Host,
		Occurrence:                    body.Occurrence,
		AttendedOccurrenceCount:       body.AttendedOccurrenceCount,
		TotalOccurrenceCount:          body.TotalOccurrenceCount,
		LastInviteReceivedTime:        body.LastInviteReceivedTime,
		LastInviteReceivedMessageID:   body.LastInviteReceivedMessageID,
		LastInviteDeliveryStatus:      body.LastInviteDeliveryStatus,
		LastInviteDeliveryDescription: body.LastInviteDeliveryDescription,
		CreatedAt:                     body.CreatedAt,
		ModifiedAt:                    body.ModifiedAt,
	}
	if body.CreatedBy != nil {
		v.CreatedBy = marshalITXUserRequestBodyToMeetingserviceITXUser(body.CreatedBy)
	}
	if body.UpdatedBy != nil {
		v.UpdatedBy = marshalITXUserRequestBodyToMeetingserviceITXUser(body.UpdatedBy)
	}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetItxRegistrantPayload builds the payload for the Meeting Service
// get-itx-registrant endpoint from CLI flags.
func BuildGetItxRegistrantPayload(meetingServiceGetItxRegistrantMeetingID string, meetingServiceGetItxRegistrantRegistrantID string, meetingServiceGetItxRegistrantVersion string, meetingServiceGetItxRegistrantBearerToken string) (*meetingservice.GetItxRegistrantPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceGetItxRegistrantMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceGetItxRegistrantRegistrantID
	}
	var version *string
	{
		if meetingServiceGetItxRegistrantVersion != "" {
			version = &meetingServiceGetItxRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxRegistrantBearerToken != "" {
			bearerToken = &meetingServiceGetItxRegistrantBearerToken
		}
	}
	v := &meetingservice.GetItxRegistrantPayload{}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateItxRegistrantPayload builds the payload for the Meeting Service
// update-itx-registrant endpoint from CLI flags.
func BuildUpdateItxRegistrantPayload(meetingServiceUpdateItxRegistrantBody string, meetingServiceUpdateItxRegistrantMeetingID string, meetingServiceUpdateItxRegistrantRegistrantID string, meetingServiceUpdateItxRegistrantVersion string, meetingServiceUpdateItxRegistrantBearerToken string) (*meetingservice.UpdateItxRegistrantPayload, error) {
	var err error
	var body UpdateItxRegistrantRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateItxRegistrantBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"attended_occurrence_count\": 2148846708945024273,\n      \"committee_id\": \"Ratione sunt id illum aliquam ut.\",\n      \"created_at\": \"Ut et quidem mollitia et eos.\",\n      \"created_by\": {\n         \"email\": \"john.doe@example.com\",\n         \"id\": \"user123\",\n         \"name\": \"John Doe\",\n         \"profile_picture\": \"https://example.com/avatar.jpg\",\n         \"username\": \"jdoe\"\n      },\n      \"email\": \"bobsmith@gmail.com\",\n      \"first_name\": \"Bob\",\n      \"host\": true,\n      \"id\": \"Ea id harum ut quos saepe.\",\n      \"job_title\": \"developer\",\n      \"last_invite_delivery_description\": \"Aut eum itaque amet dolores repudiandae.\",\n      \"last_invite_delivery_status\": \"Suscipit accusamus ad distinctio rerum sed.\",\n      \"last_invite_received_message_id\": \"Aut ducimus hic molestiae est officiis.\",\n      \"last_invite_received_time\": \"Odit temporibus sit vel doloremque.\",\n      \"last_name\": \"Smith\",\n      \"modified_at\": \"Et et voluptates earum occaecati.\",\n      \"occurrence\": \"1666848600\",\n      \"org\": \"google\",\n      \"profile_picture\": \"Error officia.\",\n      \"total_occurrence_count\": 2136528178996142538,\n      \"type\": \"direct\",\n      \"updated_by\": {\n         \"email\": \"john.doe@example.com\",\n         \"id\": \"user123\",\n         \"name\": \"John Doe\",\n         \"profile_picture\": \"https://example.com/avatar.jpg\",\n         \"username\": \"jdoe\"\n      },\n      \"user_id\": \"Velit non.\",\n      \"username\": \"testuser\"\n   }'")
		}
		if body.Type != nil {
			if !(*body.Type == "direct" || *body.Type == "committee") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"direct", "committee"}))
			}
		}
		if body.Email != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
		}
		if body.CreatedBy != nil {
			if err2 := ValidateITXUserRequestBody(body.CreatedBy); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if body.UpdatedBy != nil {
			if err2 := ValidateITXUserRequestBody(body.UpdatedBy); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceUpdateItxRegistrantMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceUpdateItxRegistrantRegistrantID
	}
	var version *string
	{
		if meetingServiceUpdateItxRegistrantVersion != "" {
			version = &meetingServiceUpdateItxRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateItxRegistrantBearerToken != "" {
			bearerToken = &meetingServiceUpdateItxRegistrantBearerToken
		}
	}
	v := &meetingservice.UpdateItxRegistrantPayload{
		ID:                            body.ID,
		Type:                          body.Type,
		CommitteeID:                   body.CommitteeID,
		UserID:                        body.UserID,
		Email:                         body.Email,
		Username:                      body.Username,
		FirstName:                     body.FirstName,
		LastName:                      body.LastName,
		Org:                           body.Org,
		JobTitle:                      body.JobTitle,
		ProfilePicture:                body.ProfilePicture,
		Host:                          body.Host,
		Occurrence:                    body.Occurrence,
		AttendedOccurrenceCount:       body.AttendedOccurrenceCount,
		TotalOccurrenceCount:          body.TotalOccurrenceCount,
		LastInviteReceivedTime:        body.LastInviteReceivedTime,
		LastInviteReceivedMessageID:   body.LastInviteReceivedMessageID,
		LastInviteDeliveryStatus:      body.LastInviteDeliveryStatus,
		LastInviteDeliveryDescription: body.LastInviteDeliveryDescription,
		CreatedAt:                     body.CreatedAt,
		ModifiedAt:                    body.ModifiedAt,
	}
	if body.CreatedBy != nil {
		v.CreatedBy = marshalITXUserRequestBodyToMeetingserviceITXUser(body.CreatedBy)
	}
	if body.UpdatedBy != nil {
		v.UpdatedBy = marshalITXUserRequestBodyToMeetingserviceITXUser(body.UpdatedBy)
	}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeleteItxRegistrantPayload builds the payload for the Meeting Service
// delete-itx-registrant endpoint from CLI flags.
func BuildDeleteItxRegistrantPayload(meetingServiceDeleteItxRegistrantMeetingID string, meetingServiceDeleteItxRegistrantRegistrantID string, meetingServiceDeleteItxRegistrantVersion string, meetingServiceDeleteItxRegistrantBearerToken string) (*meetingservice.DeleteItxRegistrantPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceDeleteItxRegistrantMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceDeleteItxRegistrantRegistrantID
	}
	var version *string
	{
		if meetingServiceDeleteItxRegistrantVersion != "" {
			version = &meetingServiceDeleteItxRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteItxRegistrantBearerToken != "" {
			bearerToken = &meetingServiceDeleteItxRegistrantBearerToken
		}
	}
	v := &meetingservice.DeleteItxRegistrantPayload{}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetItxJoinLinkPayload builds the payload for the Meeting Service
// get-itx-join-link endpoint from CLI flags.
func BuildGetItxJoinLinkPayload(meetingServiceGetItxJoinLinkMeetingID string, meetingServiceGetItxJoinLinkVersion string, meetingServiceGetItxJoinLinkUseEmail string, meetingServiceGetItxJoinLinkUserID string, meetingServiceGetItxJoinLinkName string, meetingServiceGetItxJoinLinkEmail string, meetingServiceGetItxJoinLinkRegister string, meetingServiceGetItxJoinLinkBearerToken string) (*meetingservice.GetItxJoinLinkPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceGetItxJoinLinkMeetingID
	}
	var version *string
	{
		if meetingServiceGetItxJoinLinkVersion != "" {
			version = &meetingServiceGetItxJoinLinkVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var useEmail *bool
	{
		if meetingServiceGetItxJoinLinkUseEmail != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceGetItxJoinLinkUseEmail)
			useEmail = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for useEmail, must be BOOL")
			}
		}
	}
	var userID *string
	{
		if meetingServiceGetItxJoinLinkUserID != "" {
			userID = &meetingServiceGetItxJoinLinkUserID
		}
	}
	var name *string
	{
		if meetingServiceGetItxJoinLinkName != "" {
			name = &meetingServiceGetItxJoinLinkName
		}
	}
	var email *string
	{
		if meetingServiceGetItxJoinLinkEmail != "" {
			email = &meetingServiceGetItxJoinLinkEmail
			err = goa.MergeErrors(err, goa.ValidateFormat("email", *email, goa.FormatEmail))
			if err != nil {
				return nil, err
			}
		}
	}
	var register *bool
	{
		if meetingServiceGetItxJoinLinkRegister != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceGetItxJoinLinkRegister)
			register = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for register, must be BOOL")
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxJoinLinkBearerToken != "" {
			bearerToken = &meetingServiceGetItxJoinLinkBearerToken
		}
	}
	v := &meetingservice.GetItxJoinLinkPayload{}
	v.MeetingID = meetingID
	v.Version = version
	v.UseEmail = useEmail
	v.UserID = userID
	v.Name = name
	v.Email = email
	v.Register = register
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetItxRegistrantIcsPayload builds the payload for the Meeting Service
// get-itx-registrant-ics endpoint from CLI flags.
func BuildGetItxRegistrantIcsPayload(meetingServiceGetItxRegistrantIcsMeetingID string, meetingServiceGetItxRegistrantIcsRegistrantID string, meetingServiceGetItxRegistrantIcsVersion string, meetingServiceGetItxRegistrantIcsBearerToken string) (*meetingservice.GetItxRegistrantIcsPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceGetItxRegistrantIcsMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceGetItxRegistrantIcsRegistrantID
	}
	var version *string
	{
		if meetingServiceGetItxRegistrantIcsVersion != "" {
			version = &meetingServiceGetItxRegistrantIcsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxRegistrantIcsBearerToken != "" {
			bearerToken = &meetingServiceGetItxRegistrantIcsBearerToken
		}
	}
	v := &meetingservice.GetItxRegistrantIcsPayload{}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildResendItxRegistrantInvitationPayload builds the payload for the Meeting
// Service resend-itx-registrant-invitation endpoint from CLI flags.
func BuildResendItxRegistrantInvitationPayload(meetingServiceResendItxRegistrantInvitationMeetingID string, meetingServiceResendItxRegistrantInvitationRegistrantID string, meetingServiceResendItxRegistrantInvitationVersion string, meetingServiceResendItxRegistrantInvitationBearerToken string) (*meetingservice.ResendItxRegistrantInvitationPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceResendItxRegistrantInvitationMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceResendItxRegistrantInvitationRegistrantID
	}
	var version *string
	{
		if meetingServiceResendItxRegistrantInvitationVersion != "" {
			version = &meetingServiceResendItxRegistrantInvitationVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceResendItxRegistrantInvitationBearerToken != "" {
			bearerToken = &meetingServiceResendItxRegistrantInvitationBearerToken
		}
	}
	v := &meetingservice.ResendItxRegistrantInvitationPayload{}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildResendItxMeetingInvitationsPayload builds the payload for the Meeting
// Service resend-itx-meeting-invitations endpoint from CLI flags.
func BuildResendItxMeetingInvitationsPayload(meetingServiceResendItxMeetingInvitationsBody string, meetingServiceResendItxMeetingInvitationsMeetingID string, meetingServiceResendItxMeetingInvitationsVersion string, meetingServiceResendItxMeetingInvitationsBearerToken string) (*meetingservice.ResendItxMeetingInvitationsPayload, error) {
	var err error
	var body ResendItxMeetingInvitationsRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceResendItxMeetingInvitationsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"exclude_registrant_ids\": [\n         \"reg123\",\n         \"reg456\"\n      ]\n   }'")
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceResendItxMeetingInvitationsMeetingID
	}
	var version *string
	{
		if meetingServiceResendItxMeetingInvitationsVersion != "" {
			version = &meetingServiceResendItxMeetingInvitationsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceResendItxMeetingInvitationsBearerToken != "" {
			bearerToken = &meetingServiceResendItxMeetingInvitationsBearerToken
		}
	}
	v := &meetingservice.ResendItxMeetingInvitationsPayload{}
	if body.ExcludeRegistrantIds != nil {
		v.ExcludeRegistrantIds = make([]string, len(body.ExcludeRegistrantIds))
		for i, val := range body.ExcludeRegistrantIds {
			v.ExcludeRegistrantIds[i] = val
		}
	}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}
