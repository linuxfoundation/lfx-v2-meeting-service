// Code generated by goa v3.23.1, DO NOT EDIT.
//
// Meeting Service HTTP client CLI support package
//
// Command:
// $ goa gen github.com/linuxfoundation/lfx-v2-meeting-service/design

package client

import (
	"encoding/json"
	"fmt"
	"strconv"
	"unicode/utf8"

	meetingservice "github.com/linuxfoundation/lfx-v2-meeting-service/gen/meeting_service"
	goa "goa.design/goa/v3/pkg"
)

// BuildCreateItxMeetingPayload builds the payload for the Meeting Service
// create-itx-meeting endpoint from CLI flags.
func BuildCreateItxMeetingPayload(meetingServiceCreateItxMeetingBody string, meetingServiceCreateItxMeetingVersion string, meetingServiceCreateItxMeetingBearerToken string, meetingServiceCreateItxMeetingXSync string) (*meetingservice.CreateItxMeetingPayload, error) {
	var err error
	var body CreateItxMeetingRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateItxMeetingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"meeting_participants\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         }\n      ],\n      \"description\": \"m4z\",\n      \"duration\": 30,\n      \"early_join_time_minutes\": 21,\n      \"meeting_type\": \"Legal\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"recording_enabled\": true,\n      \"recurrence\": {\n         \"end_date_time\": \"1987-04-13T13:49:56Z\",\n         \"end_times\": 1913219190205894832,\n         \"monthly_day\": 6131235544668774105,\n         \"monthly_week\": 6089942116645938903,\n         \"monthly_week_day\": 7677655015065989947,\n         \"repeat_interval\": 7700972562276912878,\n         \"type\": 2,\n         \"weekly_days\": \"Iure dolorem nobis et nihil quia.\"\n      },\n      \"restricted\": false,\n      \"start_time\": \"2021-01-01T00:00:00Z\",\n      \"timezone\": \"Qui eos quis.\",\n      \"title\": \"Qui eos quae eligendi.\",\n      \"transcript_enabled\": true,\n      \"visibility\": \"public\",\n      \"youtube_upload_enabled\": false\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", body.StartTime, goa.FormatDateTime))
		if body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 0, true))
		}
		if body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 600, false))
		}
		if !(body.Visibility == "public" || body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", body.Visibility, []any{"public", "private"}))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 2000 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 2000, false))
			}
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreateItxMeetingVersion != "" {
			version = &meetingServiceCreateItxMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateItxMeetingBearerToken != "" {
			bearerToken = &meetingServiceCreateItxMeetingBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceCreateItxMeetingXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceCreateItxMeetingXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.CreateItxMeetingPayload{
		ProjectUID:           body.ProjectUID,
		Title:                body.Title,
		StartTime:            body.StartTime,
		Duration:             body.Duration,
		Timezone:             body.Timezone,
		Visibility:           body.Visibility,
		Description:          body.Description,
		Restricted:           body.Restricted,
		MeetingType:          body.MeetingType,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
		ArtifactVisibility:   body.ArtifactVisibility,
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.Recurrence != nil {
		v.Recurrence = marshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetItxMeetingPayload builds the payload for the Meeting Service
// get-itx-meeting endpoint from CLI flags.
func BuildGetItxMeetingPayload(meetingServiceGetItxMeetingMeetingID string, meetingServiceGetItxMeetingVersion string, meetingServiceGetItxMeetingBearerToken string) (*meetingservice.GetItxMeetingPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceGetItxMeetingMeetingID
	}
	var version *string
	{
		if meetingServiceGetItxMeetingVersion != "" {
			version = &meetingServiceGetItxMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxMeetingBearerToken != "" {
			bearerToken = &meetingServiceGetItxMeetingBearerToken
		}
	}
	v := &meetingservice.GetItxMeetingPayload{}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeleteItxMeetingPayload builds the payload for the Meeting Service
// delete-itx-meeting endpoint from CLI flags.
func BuildDeleteItxMeetingPayload(meetingServiceDeleteItxMeetingMeetingID string, meetingServiceDeleteItxMeetingVersion string, meetingServiceDeleteItxMeetingBearerToken string) (*meetingservice.DeleteItxMeetingPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceDeleteItxMeetingMeetingID
	}
	var version *string
	{
		if meetingServiceDeleteItxMeetingVersion != "" {
			version = &meetingServiceDeleteItxMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteItxMeetingBearerToken != "" {
			bearerToken = &meetingServiceDeleteItxMeetingBearerToken
		}
	}
	v := &meetingservice.DeleteItxMeetingPayload{}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateItxMeetingPayload builds the payload for the Meeting Service
// update-itx-meeting endpoint from CLI flags.
func BuildUpdateItxMeetingPayload(meetingServiceUpdateItxMeetingBody string, meetingServiceUpdateItxMeetingMeetingID string, meetingServiceUpdateItxMeetingVersion string, meetingServiceUpdateItxMeetingBearerToken string, meetingServiceUpdateItxMeetingXSync string) (*meetingservice.UpdateItxMeetingPayload, error) {
	var err error
	var body UpdateItxMeetingRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateItxMeetingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"meeting_participants\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         }\n      ],\n      \"description\": \"ksa\",\n      \"duration\": 369,\n      \"early_join_time_minutes\": 10,\n      \"meeting_type\": \"None\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"recording_enabled\": true,\n      \"recurrence\": {\n         \"end_date_time\": \"1987-04-13T13:49:56Z\",\n         \"end_times\": 1913219190205894832,\n         \"monthly_day\": 6131235544668774105,\n         \"monthly_week\": 6089942116645938903,\n         \"monthly_week_day\": 7677655015065989947,\n         \"repeat_interval\": 7700972562276912878,\n         \"type\": 2,\n         \"weekly_days\": \"Iure dolorem nobis et nihil quia.\"\n      },\n      \"restricted\": true,\n      \"start_time\": \"2021-01-01T00:00:00Z\",\n      \"timezone\": \"Quia perferendis iusto et.\",\n      \"title\": \"Dolorem perferendis neque ut sint ducimus in.\",\n      \"transcript_enabled\": true,\n      \"visibility\": \"private\",\n      \"youtube_upload_enabled\": false\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", body.StartTime, goa.FormatDateTime))
		if body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 0, true))
		}
		if body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 600, false))
		}
		if !(body.Visibility == "public" || body.Visibility == "private") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", body.Visibility, []any{"public", "private"}))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 2000 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 2000, false))
			}
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes < 10 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 10, true))
			}
		}
		if body.EarlyJoinTimeMinutes != nil {
			if *body.EarlyJoinTimeMinutes > 60 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.early_join_time_minutes", *body.EarlyJoinTimeMinutes, 60, false))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceUpdateItxMeetingMeetingID
	}
	var version *string
	{
		if meetingServiceUpdateItxMeetingVersion != "" {
			version = &meetingServiceUpdateItxMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateItxMeetingBearerToken != "" {
			bearerToken = &meetingServiceUpdateItxMeetingBearerToken
		}
	}
	var xSync *bool
	{
		if meetingServiceUpdateItxMeetingXSync != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceUpdateItxMeetingXSync)
			xSync = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for xSync, must be BOOL")
			}
		}
	}
	v := &meetingservice.UpdateItxMeetingPayload{
		ProjectUID:           body.ProjectUID,
		Title:                body.Title,
		StartTime:            body.StartTime,
		Duration:             body.Duration,
		Timezone:             body.Timezone,
		Visibility:           body.Visibility,
		Description:          body.Description,
		Restricted:           body.Restricted,
		MeetingType:          body.MeetingType,
		EarlyJoinTimeMinutes: body.EarlyJoinTimeMinutes,
		RecordingEnabled:     body.RecordingEnabled,
		TranscriptEnabled:    body.TranscriptEnabled,
		YoutubeUploadEnabled: body.YoutubeUploadEnabled,
		ArtifactVisibility:   body.ArtifactVisibility,
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	if body.Recurrence != nil {
		v.Recurrence = marshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken
	v.XSync = xSync

	return v, nil
}

// BuildGetItxMeetingCountPayload builds the payload for the Meeting Service
// get-itx-meeting-count endpoint from CLI flags.
func BuildGetItxMeetingCountPayload(meetingServiceGetItxMeetingCountVersion string, meetingServiceGetItxMeetingCountProjectUID string, meetingServiceGetItxMeetingCountBearerToken string) (*meetingservice.GetItxMeetingCountPayload, error) {
	var err error
	var version *string
	{
		if meetingServiceGetItxMeetingCountVersion != "" {
			version = &meetingServiceGetItxMeetingCountVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var projectUID string
	{
		projectUID = meetingServiceGetItxMeetingCountProjectUID
	}
	var bearerToken *string
	{
		if meetingServiceGetItxMeetingCountBearerToken != "" {
			bearerToken = &meetingServiceGetItxMeetingCountBearerToken
		}
	}
	v := &meetingservice.GetItxMeetingCountPayload{}
	v.Version = version
	v.ProjectUID = projectUID
	v.BearerToken = bearerToken

	return v, nil
}

// BuildCreateItxRegistrantPayload builds the payload for the Meeting Service
// create-itx-registrant endpoint from CLI flags.
func BuildCreateItxRegistrantPayload(meetingServiceCreateItxRegistrantBody string, meetingServiceCreateItxRegistrantMeetingID string, meetingServiceCreateItxRegistrantVersion string, meetingServiceCreateItxRegistrantBearerToken string) (*meetingservice.CreateItxRegistrantPayload, error) {
	var err error
	var body CreateItxRegistrantRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateItxRegistrantBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"attended_occurrence_count\": 204364165474294847,\n      \"committee_uid\": \"Eveniet quae repellat debitis.\",\n      \"created_at\": \"Vero placeat in.\",\n      \"created_by\": {\n         \"email\": \"john.doe@example.com\",\n         \"name\": \"John Doe\",\n         \"profile_picture\": \"https://example.com/avatar.jpg\",\n         \"username\": \"jdoe\"\n      },\n      \"email\": \"bobsmith@gmail.com\",\n      \"first_name\": \"Bob\",\n      \"host\": false,\n      \"job_title\": \"developer\",\n      \"last_invite_delivery_description\": \"Aut iusto consectetur non.\",\n      \"last_invite_delivery_status\": \"Laborum iure quo.\",\n      \"last_invite_received_message_id\": \"Exercitationem reprehenderit nam reprehenderit.\",\n      \"last_invite_received_time\": \"Eum similique repellendus et qui quis tempore.\",\n      \"last_name\": \"Smith\",\n      \"modified_at\": \"Unde vitae.\",\n      \"occurrence\": \"1666848600\",\n      \"org\": \"google\",\n      \"profile_picture\": \"Rerum alias.\",\n      \"total_occurrence_count\": 6236854564526562637,\n      \"type\": \"committee\",\n      \"uid\": \"Soluta eius aut.\",\n      \"updated_by\": {\n         \"email\": \"john.doe@example.com\",\n         \"name\": \"John Doe\",\n         \"profile_picture\": \"https://example.com/avatar.jpg\",\n         \"username\": \"jdoe\"\n      },\n      \"username\": \"testuser\"\n   }'")
		}
		if body.Type != nil {
			if !(*body.Type == "direct" || *body.Type == "committee") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"direct", "committee"}))
			}
		}
		if body.Email != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
		}
		if body.CreatedBy != nil {
			if err2 := ValidateITXUserRequestBody(body.CreatedBy); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if body.UpdatedBy != nil {
			if err2 := ValidateITXUserRequestBody(body.UpdatedBy); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceCreateItxRegistrantMeetingID
	}
	var version *string
	{
		if meetingServiceCreateItxRegistrantVersion != "" {
			version = &meetingServiceCreateItxRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateItxRegistrantBearerToken != "" {
			bearerToken = &meetingServiceCreateItxRegistrantBearerToken
		}
	}
	v := &meetingservice.CreateItxRegistrantPayload{
		UID:                           body.UID,
		Type:                          body.Type,
		CommitteeUID:                  body.CommitteeUID,
		Email:                         body.Email,
		Username:                      body.Username,
		FirstName:                     body.FirstName,
		LastName:                      body.LastName,
		Org:                           body.Org,
		JobTitle:                      body.JobTitle,
		ProfilePicture:                body.ProfilePicture,
		Host:                          body.Host,
		Occurrence:                    body.Occurrence,
		AttendedOccurrenceCount:       body.AttendedOccurrenceCount,
		TotalOccurrenceCount:          body.TotalOccurrenceCount,
		LastInviteReceivedTime:        body.LastInviteReceivedTime,
		LastInviteReceivedMessageID:   body.LastInviteReceivedMessageID,
		LastInviteDeliveryStatus:      body.LastInviteDeliveryStatus,
		LastInviteDeliveryDescription: body.LastInviteDeliveryDescription,
		CreatedAt:                     body.CreatedAt,
		ModifiedAt:                    body.ModifiedAt,
	}
	if body.CreatedBy != nil {
		v.CreatedBy = marshalITXUserRequestBodyToMeetingserviceITXUser(body.CreatedBy)
	}
	if body.UpdatedBy != nil {
		v.UpdatedBy = marshalITXUserRequestBodyToMeetingserviceITXUser(body.UpdatedBy)
	}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetItxRegistrantPayload builds the payload for the Meeting Service
// get-itx-registrant endpoint from CLI flags.
func BuildGetItxRegistrantPayload(meetingServiceGetItxRegistrantMeetingID string, meetingServiceGetItxRegistrantRegistrantID string, meetingServiceGetItxRegistrantVersion string, meetingServiceGetItxRegistrantBearerToken string) (*meetingservice.GetItxRegistrantPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceGetItxRegistrantMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceGetItxRegistrantRegistrantID
	}
	var version *string
	{
		if meetingServiceGetItxRegistrantVersion != "" {
			version = &meetingServiceGetItxRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxRegistrantBearerToken != "" {
			bearerToken = &meetingServiceGetItxRegistrantBearerToken
		}
	}
	v := &meetingservice.GetItxRegistrantPayload{}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateItxRegistrantPayload builds the payload for the Meeting Service
// update-itx-registrant endpoint from CLI flags.
func BuildUpdateItxRegistrantPayload(meetingServiceUpdateItxRegistrantBody string, meetingServiceUpdateItxRegistrantMeetingID string, meetingServiceUpdateItxRegistrantRegistrantID string, meetingServiceUpdateItxRegistrantVersion string, meetingServiceUpdateItxRegistrantBearerToken string) (*meetingservice.UpdateItxRegistrantPayload, error) {
	var err error
	var body UpdateItxRegistrantRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateItxRegistrantBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"attended_occurrence_count\": 6262370327954619117,\n      \"committee_uid\": \"Blanditiis eius cumque eum modi.\",\n      \"created_at\": \"Sunt et rerum provident.\",\n      \"created_by\": {\n         \"email\": \"john.doe@example.com\",\n         \"name\": \"John Doe\",\n         \"profile_picture\": \"https://example.com/avatar.jpg\",\n         \"username\": \"jdoe\"\n      },\n      \"email\": \"bobsmith@gmail.com\",\n      \"first_name\": \"Bob\",\n      \"host\": false,\n      \"job_title\": \"developer\",\n      \"last_invite_delivery_description\": \"Ipsum qui officia nihil.\",\n      \"last_invite_delivery_status\": \"Et ratione nesciunt officiis vel.\",\n      \"last_invite_received_message_id\": \"Et aut quas.\",\n      \"last_invite_received_time\": \"Deleniti et nostrum numquam aliquid voluptas.\",\n      \"last_name\": \"Smith\",\n      \"modified_at\": \"Similique dignissimos alias quasi eum non ipsum.\",\n      \"occurrence\": \"1666848600\",\n      \"org\": \"google\",\n      \"profile_picture\": \"Minus et.\",\n      \"total_occurrence_count\": 7450094571460397270,\n      \"type\": \"committee\",\n      \"uid\": \"Possimus unde quia inventore error eveniet.\",\n      \"updated_by\": {\n         \"email\": \"john.doe@example.com\",\n         \"name\": \"John Doe\",\n         \"profile_picture\": \"https://example.com/avatar.jpg\",\n         \"username\": \"jdoe\"\n      },\n      \"username\": \"testuser\"\n   }'")
		}
		if body.Type != nil {
			if !(*body.Type == "direct" || *body.Type == "committee") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type", *body.Type, []any{"direct", "committee"}))
			}
		}
		if body.Email != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.email", *body.Email, goa.FormatEmail))
		}
		if body.CreatedBy != nil {
			if err2 := ValidateITXUserRequestBody(body.CreatedBy); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if body.UpdatedBy != nil {
			if err2 := ValidateITXUserRequestBody(body.UpdatedBy); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceUpdateItxRegistrantMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceUpdateItxRegistrantRegistrantID
	}
	var version *string
	{
		if meetingServiceUpdateItxRegistrantVersion != "" {
			version = &meetingServiceUpdateItxRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateItxRegistrantBearerToken != "" {
			bearerToken = &meetingServiceUpdateItxRegistrantBearerToken
		}
	}
	v := &meetingservice.UpdateItxRegistrantPayload{
		UID:                           body.UID,
		Type:                          body.Type,
		CommitteeUID:                  body.CommitteeUID,
		Email:                         body.Email,
		Username:                      body.Username,
		FirstName:                     body.FirstName,
		LastName:                      body.LastName,
		Org:                           body.Org,
		JobTitle:                      body.JobTitle,
		ProfilePicture:                body.ProfilePicture,
		Host:                          body.Host,
		Occurrence:                    body.Occurrence,
		AttendedOccurrenceCount:       body.AttendedOccurrenceCount,
		TotalOccurrenceCount:          body.TotalOccurrenceCount,
		LastInviteReceivedTime:        body.LastInviteReceivedTime,
		LastInviteReceivedMessageID:   body.LastInviteReceivedMessageID,
		LastInviteDeliveryStatus:      body.LastInviteDeliveryStatus,
		LastInviteDeliveryDescription: body.LastInviteDeliveryDescription,
		CreatedAt:                     body.CreatedAt,
		ModifiedAt:                    body.ModifiedAt,
	}
	if body.CreatedBy != nil {
		v.CreatedBy = marshalITXUserRequestBodyToMeetingserviceITXUser(body.CreatedBy)
	}
	if body.UpdatedBy != nil {
		v.UpdatedBy = marshalITXUserRequestBodyToMeetingserviceITXUser(body.UpdatedBy)
	}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeleteItxRegistrantPayload builds the payload for the Meeting Service
// delete-itx-registrant endpoint from CLI flags.
func BuildDeleteItxRegistrantPayload(meetingServiceDeleteItxRegistrantMeetingID string, meetingServiceDeleteItxRegistrantRegistrantID string, meetingServiceDeleteItxRegistrantVersion string, meetingServiceDeleteItxRegistrantBearerToken string) (*meetingservice.DeleteItxRegistrantPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceDeleteItxRegistrantMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceDeleteItxRegistrantRegistrantID
	}
	var version *string
	{
		if meetingServiceDeleteItxRegistrantVersion != "" {
			version = &meetingServiceDeleteItxRegistrantVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteItxRegistrantBearerToken != "" {
			bearerToken = &meetingServiceDeleteItxRegistrantBearerToken
		}
	}
	v := &meetingservice.DeleteItxRegistrantPayload{}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetItxJoinLinkPayload builds the payload for the Meeting Service
// get-itx-join-link endpoint from CLI flags.
func BuildGetItxJoinLinkPayload(meetingServiceGetItxJoinLinkMeetingID string, meetingServiceGetItxJoinLinkVersion string, meetingServiceGetItxJoinLinkUseEmail string, meetingServiceGetItxJoinLinkUserID string, meetingServiceGetItxJoinLinkName string, meetingServiceGetItxJoinLinkEmail string, meetingServiceGetItxJoinLinkRegister string, meetingServiceGetItxJoinLinkBearerToken string) (*meetingservice.GetItxJoinLinkPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceGetItxJoinLinkMeetingID
	}
	var version *string
	{
		if meetingServiceGetItxJoinLinkVersion != "" {
			version = &meetingServiceGetItxJoinLinkVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var useEmail *bool
	{
		if meetingServiceGetItxJoinLinkUseEmail != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceGetItxJoinLinkUseEmail)
			useEmail = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for useEmail, must be BOOL")
			}
		}
	}
	var userID *string
	{
		if meetingServiceGetItxJoinLinkUserID != "" {
			userID = &meetingServiceGetItxJoinLinkUserID
		}
	}
	var name *string
	{
		if meetingServiceGetItxJoinLinkName != "" {
			name = &meetingServiceGetItxJoinLinkName
		}
	}
	var email *string
	{
		if meetingServiceGetItxJoinLinkEmail != "" {
			email = &meetingServiceGetItxJoinLinkEmail
			err = goa.MergeErrors(err, goa.ValidateFormat("email", *email, goa.FormatEmail))
			if err != nil {
				return nil, err
			}
		}
	}
	var register *bool
	{
		if meetingServiceGetItxJoinLinkRegister != "" {
			var val bool
			val, err = strconv.ParseBool(meetingServiceGetItxJoinLinkRegister)
			register = &val
			if err != nil {
				return nil, fmt.Errorf("invalid value for register, must be BOOL")
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxJoinLinkBearerToken != "" {
			bearerToken = &meetingServiceGetItxJoinLinkBearerToken
		}
	}
	v := &meetingservice.GetItxJoinLinkPayload{}
	v.MeetingID = meetingID
	v.Version = version
	v.UseEmail = useEmail
	v.UserID = userID
	v.Name = name
	v.Email = email
	v.Register = register
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetItxRegistrantIcsPayload builds the payload for the Meeting Service
// get-itx-registrant-ics endpoint from CLI flags.
func BuildGetItxRegistrantIcsPayload(meetingServiceGetItxRegistrantIcsMeetingID string, meetingServiceGetItxRegistrantIcsRegistrantID string, meetingServiceGetItxRegistrantIcsVersion string, meetingServiceGetItxRegistrantIcsBearerToken string) (*meetingservice.GetItxRegistrantIcsPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceGetItxRegistrantIcsMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceGetItxRegistrantIcsRegistrantID
	}
	var version *string
	{
		if meetingServiceGetItxRegistrantIcsVersion != "" {
			version = &meetingServiceGetItxRegistrantIcsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxRegistrantIcsBearerToken != "" {
			bearerToken = &meetingServiceGetItxRegistrantIcsBearerToken
		}
	}
	v := &meetingservice.GetItxRegistrantIcsPayload{}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildResendItxRegistrantInvitationPayload builds the payload for the Meeting
// Service resend-itx-registrant-invitation endpoint from CLI flags.
func BuildResendItxRegistrantInvitationPayload(meetingServiceResendItxRegistrantInvitationMeetingID string, meetingServiceResendItxRegistrantInvitationRegistrantID string, meetingServiceResendItxRegistrantInvitationVersion string, meetingServiceResendItxRegistrantInvitationBearerToken string) (*meetingservice.ResendItxRegistrantInvitationPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceResendItxRegistrantInvitationMeetingID
	}
	var registrantID string
	{
		registrantID = meetingServiceResendItxRegistrantInvitationRegistrantID
	}
	var version *string
	{
		if meetingServiceResendItxRegistrantInvitationVersion != "" {
			version = &meetingServiceResendItxRegistrantInvitationVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceResendItxRegistrantInvitationBearerToken != "" {
			bearerToken = &meetingServiceResendItxRegistrantInvitationBearerToken
		}
	}
	v := &meetingservice.ResendItxRegistrantInvitationPayload{}
	v.MeetingID = meetingID
	v.RegistrantID = registrantID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildResendItxMeetingInvitationsPayload builds the payload for the Meeting
// Service resend-itx-meeting-invitations endpoint from CLI flags.
func BuildResendItxMeetingInvitationsPayload(meetingServiceResendItxMeetingInvitationsBody string, meetingServiceResendItxMeetingInvitationsMeetingID string, meetingServiceResendItxMeetingInvitationsVersion string, meetingServiceResendItxMeetingInvitationsBearerToken string) (*meetingservice.ResendItxMeetingInvitationsPayload, error) {
	var err error
	var body ResendItxMeetingInvitationsRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceResendItxMeetingInvitationsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"exclude_registrant_ids\": [\n         \"reg123\",\n         \"reg456\"\n      ]\n   }'")
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceResendItxMeetingInvitationsMeetingID
	}
	var version *string
	{
		if meetingServiceResendItxMeetingInvitationsVersion != "" {
			version = &meetingServiceResendItxMeetingInvitationsVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceResendItxMeetingInvitationsBearerToken != "" {
			bearerToken = &meetingServiceResendItxMeetingInvitationsBearerToken
		}
	}
	v := &meetingservice.ResendItxMeetingInvitationsPayload{}
	if body.ExcludeRegistrantIds != nil {
		v.ExcludeRegistrantIds = make([]string, len(body.ExcludeRegistrantIds))
		for i, val := range body.ExcludeRegistrantIds {
			v.ExcludeRegistrantIds[i] = val
		}
	}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildRegisterItxCommitteeMembersPayload builds the payload for the Meeting
// Service register-itx-committee-members endpoint from CLI flags.
func BuildRegisterItxCommitteeMembersPayload(meetingServiceRegisterItxCommitteeMembersMeetingID string, meetingServiceRegisterItxCommitteeMembersVersion string, meetingServiceRegisterItxCommitteeMembersBearerToken string) (*meetingservice.RegisterItxCommitteeMembersPayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceRegisterItxCommitteeMembersMeetingID
	}
	var version *string
	{
		if meetingServiceRegisterItxCommitteeMembersVersion != "" {
			version = &meetingServiceRegisterItxCommitteeMembersVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceRegisterItxCommitteeMembersBearerToken != "" {
			bearerToken = &meetingServiceRegisterItxCommitteeMembersBearerToken
		}
	}
	v := &meetingservice.RegisterItxCommitteeMembersPayload{}
	v.MeetingID = meetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateItxOccurrencePayload builds the payload for the Meeting Service
// update-itx-occurrence endpoint from CLI flags.
func BuildUpdateItxOccurrencePayload(meetingServiceUpdateItxOccurrenceBody string, meetingServiceUpdateItxOccurrenceMeetingID string, meetingServiceUpdateItxOccurrenceOccurrenceID string, meetingServiceUpdateItxOccurrenceVersion string, meetingServiceUpdateItxOccurrenceBearerToken string) (*meetingservice.UpdateItxOccurrencePayload, error) {
	var err error
	var body UpdateItxOccurrenceRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateItxOccurrenceBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"agenda\": \"Aut totam dolorem laborum earum praesentium.\",\n      \"duration\": 60,\n      \"recurrence\": {\n         \"end_date_time\": \"1987-04-13T13:49:56Z\",\n         \"end_times\": 1913219190205894832,\n         \"monthly_day\": 6131235544668774105,\n         \"monthly_week\": 6089942116645938903,\n         \"monthly_week_day\": 7677655015065989947,\n         \"repeat_interval\": 7700972562276912878,\n         \"type\": 2,\n         \"weekly_days\": \"Iure dolorem nobis et nihil quia.\"\n      },\n      \"start_time\": \"2024-01-15T10:00:00Z\",\n      \"topic\": \"Occaecati sed vitae.\"\n   }'")
		}
		if body.StartTime != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
		}
		if body.Duration != nil {
			if *body.Duration < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 1, true))
			}
		}
		if body.Recurrence != nil {
			if err2 := ValidateRecurrenceRequestBody(body.Recurrence); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var meetingID string
	{
		meetingID = meetingServiceUpdateItxOccurrenceMeetingID
	}
	var occurrenceID string
	{
		occurrenceID = meetingServiceUpdateItxOccurrenceOccurrenceID
	}
	var version *string
	{
		if meetingServiceUpdateItxOccurrenceVersion != "" {
			version = &meetingServiceUpdateItxOccurrenceVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateItxOccurrenceBearerToken != "" {
			bearerToken = &meetingServiceUpdateItxOccurrenceBearerToken
		}
	}
	v := &meetingservice.UpdateItxOccurrencePayload{
		StartTime: body.StartTime,
		Duration:  body.Duration,
		Topic:     body.Topic,
		Agenda:    body.Agenda,
	}
	if body.Recurrence != nil {
		v.Recurrence = marshalRecurrenceRequestBodyToMeetingserviceRecurrence(body.Recurrence)
	}
	v.MeetingID = meetingID
	v.OccurrenceID = occurrenceID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeleteItxOccurrencePayload builds the payload for the Meeting Service
// delete-itx-occurrence endpoint from CLI flags.
func BuildDeleteItxOccurrencePayload(meetingServiceDeleteItxOccurrenceMeetingID string, meetingServiceDeleteItxOccurrenceOccurrenceID string, meetingServiceDeleteItxOccurrenceVersion string, meetingServiceDeleteItxOccurrenceBearerToken string) (*meetingservice.DeleteItxOccurrencePayload, error) {
	var err error
	var meetingID string
	{
		meetingID = meetingServiceDeleteItxOccurrenceMeetingID
	}
	var occurrenceID string
	{
		occurrenceID = meetingServiceDeleteItxOccurrenceOccurrenceID
	}
	var version *string
	{
		if meetingServiceDeleteItxOccurrenceVersion != "" {
			version = &meetingServiceDeleteItxOccurrenceVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteItxOccurrenceBearerToken != "" {
			bearerToken = &meetingServiceDeleteItxOccurrenceBearerToken
		}
	}
	v := &meetingservice.DeleteItxOccurrencePayload{}
	v.MeetingID = meetingID
	v.OccurrenceID = occurrenceID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildCreateItxPastMeetingPayload builds the payload for the Meeting Service
// create-itx-past-meeting endpoint from CLI flags.
func BuildCreateItxPastMeetingPayload(meetingServiceCreateItxPastMeetingBody string, meetingServiceCreateItxPastMeetingVersion string, meetingServiceCreateItxPastMeetingBearerToken string) (*meetingservice.CreateItxPastMeetingPayload, error) {
	var err error
	var body CreateItxPastMeetingRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceCreateItxPastMeetingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"meeting_hosts\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         }\n      ],\n      \"description\": \"fki\",\n      \"duration\": 530,\n      \"meeting_id\": \"12343245463\",\n      \"meeting_type\": \"Other\",\n      \"occurrence_id\": \"1630560600000\",\n      \"project_uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\",\n      \"recording_enabled\": false,\n      \"restricted\": true,\n      \"start_time\": \"2021-01-01T00:00:00Z\",\n      \"timezone\": \"Recusandae voluptatem.\",\n      \"title\": \"Cupiditate a.\",\n      \"transcript_enabled\": true,\n      \"visibility\": \"public\"\n   }'")
		}
		err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", body.StartTime, goa.FormatDateTime))
		if body.Duration < 0 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 0, true))
		}
		if body.Duration > 600 {
			err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", body.Duration, 600, false))
		}
		if body.Description != nil {
			if utf8.RuneCountInString(*body.Description) > 2000 {
				err = goa.MergeErrors(err, goa.InvalidLengthError("body.description", *body.Description, utf8.RuneCountInString(*body.Description), 2000, false))
			}
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "Board" || *body.MeetingType == "Maintainers" || *body.MeetingType == "Marketing" || *body.MeetingType == "Technical" || *body.MeetingType == "Legal" || *body.MeetingType == "Other" || *body.MeetingType == "None") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"Board", "Maintainers", "Marketing", "Technical", "Legal", "Other", "None"}))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		if body.Visibility != nil {
			if !(*body.Visibility == "public" || *body.Visibility == "private") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var version *string
	{
		if meetingServiceCreateItxPastMeetingVersion != "" {
			version = &meetingServiceCreateItxPastMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceCreateItxPastMeetingBearerToken != "" {
			bearerToken = &meetingServiceCreateItxPastMeetingBearerToken
		}
	}
	v := &meetingservice.CreateItxPastMeetingPayload{
		MeetingID:          body.MeetingID,
		OccurrenceID:       body.OccurrenceID,
		ProjectUID:         body.ProjectUID,
		StartTime:          body.StartTime,
		Duration:           body.Duration,
		Timezone:           body.Timezone,
		Description:        body.Description,
		Restricted:         body.Restricted,
		MeetingType:        body.MeetingType,
		RecordingEnabled:   body.RecordingEnabled,
		TranscriptEnabled:  body.TranscriptEnabled,
		ArtifactVisibility: body.ArtifactVisibility,
		Visibility:         body.Visibility,
		Title:              body.Title,
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetItxPastMeetingPayload builds the payload for the Meeting Service
// get-itx-past-meeting endpoint from CLI flags.
func BuildGetItxPastMeetingPayload(meetingServiceGetItxPastMeetingPastMeetingID string, meetingServiceGetItxPastMeetingVersion string, meetingServiceGetItxPastMeetingBearerToken string) (*meetingservice.GetItxPastMeetingPayload, error) {
	var err error
	var pastMeetingID string
	{
		pastMeetingID = meetingServiceGetItxPastMeetingPastMeetingID
	}
	var version *string
	{
		if meetingServiceGetItxPastMeetingVersion != "" {
			version = &meetingServiceGetItxPastMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxPastMeetingBearerToken != "" {
			bearerToken = &meetingServiceGetItxPastMeetingBearerToken
		}
	}
	v := &meetingservice.GetItxPastMeetingPayload{}
	v.PastMeetingID = pastMeetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildDeleteItxPastMeetingPayload builds the payload for the Meeting Service
// delete-itx-past-meeting endpoint from CLI flags.
func BuildDeleteItxPastMeetingPayload(meetingServiceDeleteItxPastMeetingPastMeetingID string, meetingServiceDeleteItxPastMeetingVersion string, meetingServiceDeleteItxPastMeetingBearerToken string) (*meetingservice.DeleteItxPastMeetingPayload, error) {
	var err error
	var pastMeetingID string
	{
		pastMeetingID = meetingServiceDeleteItxPastMeetingPastMeetingID
	}
	var version *string
	{
		if meetingServiceDeleteItxPastMeetingVersion != "" {
			version = &meetingServiceDeleteItxPastMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceDeleteItxPastMeetingBearerToken != "" {
			bearerToken = &meetingServiceDeleteItxPastMeetingBearerToken
		}
	}
	v := &meetingservice.DeleteItxPastMeetingPayload{}
	v.PastMeetingID = pastMeetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateItxPastMeetingPayload builds the payload for the Meeting Service
// update-itx-past-meeting endpoint from CLI flags.
func BuildUpdateItxPastMeetingPayload(meetingServiceUpdateItxPastMeetingBody string, meetingServiceUpdateItxPastMeetingPastMeetingID string, meetingServiceUpdateItxPastMeetingVersion string, meetingServiceUpdateItxPastMeetingBearerToken string) (*meetingservice.UpdateItxPastMeetingPayload, error) {
	var err error
	var body UpdateItxPastMeetingRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateItxPastMeetingBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"artifact_visibility\": \"public\",\n      \"committees\": [\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         },\n         {\n            \"allowed_voting_statuses\": [\n               \"Nisi explicabo eos.\",\n               \"Odit ut assumenda maxime aut occaecati.\",\n               \"Non fuga.\"\n            ],\n            \"uid\": \"7cad5a8d-19d0-41a4-81a6-043453daf9ee\"\n         }\n      ],\n      \"description\": \"Quisquam nihil qui ea provident natus ut.\",\n      \"duration\": 60,\n      \"meeting_id\": \"12343245463\",\n      \"meeting_type\": \"regular\",\n      \"occurrence_id\": \"1630560600000\",\n      \"project_uid\": \"a09eaa48-231b-43e5-93ba-91c2e0a0e5f1\",\n      \"recording_enabled\": false,\n      \"restricted\": true,\n      \"start_time\": \"2024-01-15T10:00:00Z\",\n      \"timezone\": \"UTC\",\n      \"title\": \"A delectus dolores dolorem quam qui ratione.\",\n      \"transcript_enabled\": true,\n      \"visibility\": \"private\"\n   }'")
		}
		if body.StartTime != nil {
			err = goa.MergeErrors(err, goa.ValidateFormat("body.start_time", *body.StartTime, goa.FormatDateTime))
		}
		if body.Duration != nil {
			if *body.Duration < 1 {
				err = goa.MergeErrors(err, goa.InvalidRangeError("body.duration", *body.Duration, 1, true))
			}
		}
		if body.MeetingType != nil {
			if !(*body.MeetingType == "regular" || *body.MeetingType == "webinar") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.meeting_type", *body.MeetingType, []any{"regular", "webinar"}))
			}
		}
		if body.Visibility != nil {
			if !(*body.Visibility == "public" || *body.Visibility == "private") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.visibility", *body.Visibility, []any{"public", "private"}))
			}
		}
		if body.ArtifactVisibility != nil {
			if !(*body.ArtifactVisibility == "meeting_hosts" || *body.ArtifactVisibility == "meeting_participants" || *body.ArtifactVisibility == "public") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.artifact_visibility", *body.ArtifactVisibility, []any{"meeting_hosts", "meeting_participants", "public"}))
			}
		}
		for _, e := range body.Committees {
			if e != nil {
				if err2 := ValidateCommitteeRequestBody(e); err2 != nil {
					err = goa.MergeErrors(err, err2)
				}
			}
		}
		if err != nil {
			return nil, err
		}
	}
	var pastMeetingID string
	{
		pastMeetingID = meetingServiceUpdateItxPastMeetingPastMeetingID
	}
	var version *string
	{
		if meetingServiceUpdateItxPastMeetingVersion != "" {
			version = &meetingServiceUpdateItxPastMeetingVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateItxPastMeetingBearerToken != "" {
			bearerToken = &meetingServiceUpdateItxPastMeetingBearerToken
		}
	}
	v := &meetingservice.UpdateItxPastMeetingPayload{
		ProjectUID:         body.ProjectUID,
		MeetingID:          body.MeetingID,
		OccurrenceID:       body.OccurrenceID,
		StartTime:          body.StartTime,
		Duration:           body.Duration,
		Timezone:           body.Timezone,
		Title:              body.Title,
		Description:        body.Description,
		Restricted:         body.Restricted,
		MeetingType:        body.MeetingType,
		Visibility:         body.Visibility,
		RecordingEnabled:   body.RecordingEnabled,
		TranscriptEnabled:  body.TranscriptEnabled,
		ArtifactVisibility: body.ArtifactVisibility,
	}
	if body.Committees != nil {
		v.Committees = make([]*meetingservice.Committee, len(body.Committees))
		for i, val := range body.Committees {
			if val == nil {
				v.Committees[i] = nil
				continue
			}
			v.Committees[i] = marshalCommitteeRequestBodyToMeetingserviceCommittee(val)
		}
	}
	v.PastMeetingID = pastMeetingID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildGetItxPastMeetingSummaryPayload builds the payload for the Meeting
// Service get-itx-past-meeting-summary endpoint from CLI flags.
func BuildGetItxPastMeetingSummaryPayload(meetingServiceGetItxPastMeetingSummaryPastMeetingID string, meetingServiceGetItxPastMeetingSummarySummaryID string, meetingServiceGetItxPastMeetingSummaryVersion string, meetingServiceGetItxPastMeetingSummaryBearerToken string) (*meetingservice.GetItxPastMeetingSummaryPayload, error) {
	var err error
	var pastMeetingID string
	{
		pastMeetingID = meetingServiceGetItxPastMeetingSummaryPastMeetingID
	}
	var summaryID string
	{
		summaryID = meetingServiceGetItxPastMeetingSummarySummaryID
	}
	var version *string
	{
		if meetingServiceGetItxPastMeetingSummaryVersion != "" {
			version = &meetingServiceGetItxPastMeetingSummaryVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceGetItxPastMeetingSummaryBearerToken != "" {
			bearerToken = &meetingServiceGetItxPastMeetingSummaryBearerToken
		}
	}
	v := &meetingservice.GetItxPastMeetingSummaryPayload{}
	v.PastMeetingID = pastMeetingID
	v.SummaryID = summaryID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}

// BuildUpdateItxPastMeetingSummaryPayload builds the payload for the Meeting
// Service update-itx-past-meeting-summary endpoint from CLI flags.
func BuildUpdateItxPastMeetingSummaryPayload(meetingServiceUpdateItxPastMeetingSummaryBody string, meetingServiceUpdateItxPastMeetingSummaryPastMeetingID string, meetingServiceUpdateItxPastMeetingSummarySummaryID string, meetingServiceUpdateItxPastMeetingSummaryVersion string, meetingServiceUpdateItxPastMeetingSummaryBearerToken string) (*meetingservice.UpdateItxPastMeetingSummaryPayload, error) {
	var err error
	var body UpdateItxPastMeetingSummaryRequestBody
	{
		err = json.Unmarshal([]byte(meetingServiceUpdateItxPastMeetingSummaryBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"approved\": false,\n      \"edited_next_steps\": [\n         \"Excepturi et vel corporis.\",\n         \"Aliquid ut impedit quo.\",\n         \"Voluptas error numquam dignissimos magnam vero.\",\n         \"Eum vel.\"\n      ],\n      \"edited_summary_details\": [\n         {\n            \"label\": \"Discussion Topics\",\n            \"summary\": \"The team discussed the project roadmap and upcoming milestones\"\n         },\n         {\n            \"label\": \"Discussion Topics\",\n            \"summary\": \"The team discussed the project roadmap and upcoming milestones\"\n         }\n      ],\n      \"edited_summary_overview\": \"Debitis possimus qui est.\"\n   }'")
		}
	}
	var pastMeetingID string
	{
		pastMeetingID = meetingServiceUpdateItxPastMeetingSummaryPastMeetingID
	}
	var summaryID string
	{
		summaryID = meetingServiceUpdateItxPastMeetingSummarySummaryID
	}
	var version *string
	{
		if meetingServiceUpdateItxPastMeetingSummaryVersion != "" {
			version = &meetingServiceUpdateItxPastMeetingSummaryVersion
			if !(*version == "1") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("version", *version, []any{"1"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var bearerToken *string
	{
		if meetingServiceUpdateItxPastMeetingSummaryBearerToken != "" {
			bearerToken = &meetingServiceUpdateItxPastMeetingSummaryBearerToken
		}
	}
	v := &meetingservice.UpdateItxPastMeetingSummaryPayload{
		EditedSummaryOverview: body.EditedSummaryOverview,
		Approved:              body.Approved,
	}
	if body.EditedSummaryDetails != nil {
		v.EditedSummaryDetails = make([]*meetingservice.ZoomMeetingSummaryDetails, len(body.EditedSummaryDetails))
		for i, val := range body.EditedSummaryDetails {
			if val == nil {
				v.EditedSummaryDetails[i] = nil
				continue
			}
			v.EditedSummaryDetails[i] = marshalZoomMeetingSummaryDetailsRequestBodyToMeetingserviceZoomMeetingSummaryDetails(val)
		}
	}
	if body.EditedNextSteps != nil {
		v.EditedNextSteps = make([]string, len(body.EditedNextSteps))
		for i, val := range body.EditedNextSteps {
			v.EditedNextSteps[i] = val
		}
	}
	v.PastMeetingID = pastMeetingID
	v.SummaryID = summaryID
	v.Version = version
	v.BearerToken = bearerToken

	return v, nil
}
